<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mondaycha.github.io/blog</id>
    <title>L1l Blog</title>
    <updated>2021-02-04T06:17:25.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mondaycha.github.io/blog"/>
    <subtitle>L1l Blog</subtitle>
    <icon>https://mondaycha.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Windows 10 安装 Ubuntu 20.04 双系统不完全踩坑记录]]></title>
        <id>Windows 10 安装 Ubuntu 20.04 双系统不完全踩坑记录</id>
        <link href="https://mondaycha.github.io/blog/2021/02/04/Windows-10-安装-Ubuntu-20.04-双系统不完全踩坑记录"/>
        <updated>2021-02-04T06:17:25.000Z</updated>
        <summary type="html"><![CDATA[2021.2.2 在第三次重装后终于成功了……记录下中间踩的坑]]></summary>
        <content type="html"><![CDATA[<blockquote><p>2021.2.2 在第三次重装后终于成功了……记录下中间踩的坑
硬件设备: 联想Y7000 2018, GTX1050显卡</p></blockquote><p>网上关于Windows 10 安装 Ubuntu双系统的文章已经非常多了，然而中间存在大量过时的内容，让人摸不到头脑。</p><p>这篇文章对于具体的安装流程仅是略微带过，重点放在遇到的坑点和如何优化双系统使用体验上。最后感谢 <a href="https://zhuanlan.zhihu.com/people/7dc6cfef3681ffebfea8c09248694e7e">@火村夕</a> <a href="https://zhuanlan.zhihu.com/people/f65376327795a1683cbf777170f30b0c">@比企谷雪乃</a> 大佬们在知乎评论区的指正，否则感觉这篇文章同样是误人子弟（捂脸）……</p><h2>准备工作</h2><p>首先需要划分出Ubuntu所需的硬盘空间，在Windows的磁盘管理中压缩卷即可，不需要分配盘符。</p><p><img src="https://pic3.zhimg.com/v2-1c67104be0c9cfdad1692cf9e7f86012_b.png"/></p><p><img src="https://pic4.zhimg.com/v2-a3add0facbcf1c31305308024c79a417_b.png"/></p><p>目前在用的系统盘是光威弈系列的Nvme M.2 512G，所以划分了100G的空闲空间。之后下载Ubuntu20.04 LTS的镜像，使用rufus等工具制作启动盘。</p><p><img src="https://pic1.zhimg.com/v2-a90b3db94d3f58e2ddc0a6f9a50a9cac_b.png"/></p><p>为了保证开机能进入BIOS界面，先关闭Windows快速启动，采用UEFI方式进行引导。</p><h2>Linux安装坑点</h2><ul><li>按F12进入Boot Manager，找到看起来像Ubuntu引导盘的选项</li><li>由于笔记本外接显卡可能存在种种问题，选择“Install Ubuntu (safe graogics)”选项</li><li>不要联网，还没换源的话下载很慢</li><li>在安装界面，勾选“为图形或者无线硬件……”选项</li><li>在安装类型，记得选“其他选项”，不要相信Ubuntu自己的共存或者重装，每次都要自己分区（这就是我重装三次的理由orz）</li></ul><p>重点说说分区，我物理内存16G，所以最后分了8G虚拟内存，500M EFI引导文件，60G“/分区”，30G“home分区”（现在貌似已经没必要为usr挂载单独的分区了）。</p><p>由于Y7000的显卡问题，在安装完成进入系统选择界面时按e，然后将倒数第2行ro后面的内容全部删掉并改为 nouveau.modeset=0 ，F10保存开机。</p><h2>无法输出HDMI信号</h2><p>此时无法识别外接显示器，显卡驱动未更新。</p><p>将软件源更新为阿里源，更新完成后，外接显卡功能正常。更新过程出现长时间黑屏要有耐心，否则就会像第二次的我一样强制关机之后进GRUB并得知内核已损坏……</p><h2>解决时间相差8小时问题</h2><p>在切换双系统时，发现Windows的时间总是会慢8小时，查询后发现是Linux系统将电脑的物理时间当作UTC时间并修正的结果。</p><p>解决方法有两种，一种是修改Windows的注册表，另外就是在Linux上做文章：使用命令sudo hwclock -w --localtime 完成adjtime 文件的修改。（文章中的办法三我试了，没有用……）</p><h2>将Ubuntu中文字体替换为微软雅黑</h2><p>在Ubuntu下访问Windows的系统盘，拷贝相关字体。</p><p><img src="https://pic1.zhimg.com/v2-6f463d3f0abbf8f96a6762a2b7759df0_b.png"/></p><p>之后就要修改窗格的默认字体了，我没能启动unity tweak tool，所以使用gnome-tweak-tools，通过sudo apt install gnome-tweak-tool安装。</p><p>之后可以在“显示应用程序/工具/优化”中启动，并修改字体。</p><h2>当Firefox浏览网页时提醒你安装Flash插件</h2><p>那就在Ubuntu下安装个Chrome试试：</p><p>目前20.04不需要修改配置文件，可以直接启动。不过Chrome的账号同步是个大问题，Edge也推出了Linux版，可惜暂不支持登录账号，要不想必会成为我的主力浏览器了。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[『DP』房间传送门问题]]></title>
        <id>『DP』房间传送门问题</id>
        <link href="https://mondaycha.github.io/blog/2021/01/19/『DP』房间传送门问题"/>
        <updated>2021-01-19T03:42:02.000Z</updated>
        <summary type="html"><![CDATA[问题描述]]></summary>
        <content type="html"><![CDATA[<h2>问题描述</h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/58b04ed2865f4ff4921290f1bd4ee486">https://www.nowcoder.com/questionTerminal/58b04ed2865f4ff4921290f1bd4ee486</a>
来源：牛客网</p></blockquote><p>存在n+1个房间，每个房间依次为房间1 2 3...i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1&lt;=pi&lt;=i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：
A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；
B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；
现在路人甲想知道移动到房间n+1一共需要多少次移动；</p><h3>输入描述:</h3><pre><code>第一行包括一个数字n(30%数据1&lt;=n&lt;=100，100%数据 1&lt;=n&lt;=1000)，表示房间的数量，接下来一行存在n个数字 pi(1&lt;=pi&lt;=i), pi表示从房间i可以传送到房间pi。
</code></pre><h3>输出描述:</h3><pre><code>输出一行数字，表示最终移动的次数，最终结果需要对1000000007 (10e9 + 7) 取模。
</code></pre><h2>递推公式</h2><ul><li><p>第一次到达房间$i$时, 需要在第二次到达房间$i-1$的基础上$+1$</p></li><li><p>第一次到达房间$i$后, 下一步会到达房间$p<!-- -->[i]<!-- -->$, 之后再第二次走到房间$i$</p></li><li><p>到达$p<!-- -->[i]<!-- -->$时, 从$p<!-- -->[i]<!-- -->+1$到$i-1$的房间均被访问偶数次, 与未访问过的情况(访问0次)一致</p></li><li><p>所以我们可以认为, 从$p<!-- -->[i]<!-- -->$到$i$所需步数, 为$(dp<!-- -->[i]<!-- -->-dp[p<!-- -->[i]<!-- -->])$</p></li></ul><p>综上所述, 得到状态转移方程:
$$
DP<!-- -->[i]<!-- --> = 2 * DP<!-- -->[i-1]<!-- --> + DP[P<!-- -->[i-1]<!-- -->] + 2
$$</p><h2>代码实现</h2><pre><code class="language-java">import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] p = new int[n + 1];
        for(int i = 1; i &lt;= n; i++){
            p[i] = scanner.nextInt();
        }
        System.out.println(moveTime(n, p));
    }
    
    private static int moveTime(int n, int[] p){
        int[] dp = new int[n+2];
        dp[1] = 0;
        for(int i = 2; i &lt;= n+1; i++){
            dp[i] = (2 * dp[i-1] - dp[p[i-1]] + 2) % (1000000007);
        }
        return dp[n+1] &lt; 0 ? dp[n+1] + (1000000007) : dp[n+1];
    }
}
</code></pre><p>注意要对结果取模, 存在负数的情况, 也就是因为取模导致$2 * dp<!-- -->[i-1]<!-- --> - dp[p<!-- -->[i-1]<!-- -->]$为负数, 因此最后的结果需要补正, 否则只能通过$80\%$的测试点.</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节跳动 客户端研发实习生 二面面经]]></title>
        <id>字节跳动 客户端研发实习生 二面面经</id>
        <link href="https://mondaycha.github.io/blog/2021/01/12/字节跳动-客户端研发实习生-二面面经"/>
        <updated>2021-01-12T01:15:39.000Z</updated>
        <summary type="html"><![CDATA[我逐渐明白, 没学计算机网络, 是我最大的幸运.]]></summary>
        <content type="html"><![CDATA[<p>我逐渐明白, 没学计算机网络, 是我最大的幸运.</p><h2>二面面试碎碎念</h2><p>这波感觉和网上的面经更接近了. 面试前20分钟我非常紧张, 于是打开了雀魂, 莫得想到我先连庄3次, 然后三位又连庄3次...... 最后一把直接进行一个理和鸣切, 之后发现从60000放铳到了48000, 幸好还是1位orz.</p><p>一开始问的一堆操作系统......虽然之前姑且还考了个理论课85分, 但是现在半年没碰已经忘得差不多了......下次面试时一定要复习.</p><p>gtc说当听到开始问编译原理时, 我的声音变得喜悦万分, 身体不自觉前倾——小丑就是我自己!</p><h2>Part 0: 先摸摸底</h2><ul><li>学习情况? 操作系统啥的都学了, 就是网络还没学.</li><li>常用的语言是? Java, 我们这里主要考察你的基础知识, 语言的话看时间, 有时间就问问. </li><li>代码能力需要测试.</li></ul><h2>Part 1: 知识点问答(20min左右)</h2><h3>1.1 谈谈你对进程和线程的理解? 比如说区别和联系</h3><h4><a href="https://www.cnblogs.com/coder-programming/p/10595804.html">1.1.1 一篇让你明白进程与线程之间的区别与联系</a></h4><ul><li><p>进程是操作系统进行<strong>资源分配</strong>和调度的基本单位. 进程是线程的容器. 是程序的实体. 指在系统中正在运行的一个应用程序. </p></li><li><p>线程是操作系统能够进行运算调度(<strong>程序执行</strong>)的最小单位. 是进程中的实际运作单位. 进程之内独立执行的一个单元执行流. </p></li></ul><h4>1.1.2 进程的组成</h4><p>进程包括</p><ul><li>线程</li><li>内存(逻辑内存, 每个进程的内存都是相互独立的, 有利于安全性)</li><li>文件/网络句柄: 所有进程共有的资源</li></ul><h4>1.1.3 线程的组成</h4><ul><li>栈: 每次进行函数调用时, 会将参数和返回地址压入栈中</li><li>PC(程序计数器): 指向当前的指令, 指令放在内存中, PC指针指向内存, 有数据和程序(因此存在缓冲区溢出, 可以通过写数据干涉程序内存, 进而运行代码)</li><li>TLS(线程本地存储): 线程独立的内存</li></ul><h4>1.1.4 进程与线程的通信</h4><ul><li>进程之间通过TCP/IP端口进行交互</li><li>线程之间有共享内存</li></ul><h4>1.1.5 进程与线程的特点</h4><ul><li>进程需要分配内存, 线程需要分配栈空间</li><li>一个程序至少有一个进程, 一个进程至少有一个线程</li><li>进程是资源分配的最小单位, 线程是程序执行的最小单位</li><li>一个线程可以创建和撤销另一个线程, 多线程可以并发执行</li></ul><h3>1.2 我们通常讲到一些资源的分配, 比如说内存资源的分配, 这些内存是按照进程分配的还是按照线程分配的?</h3><h3>1.3 谈谈你对虚拟地址空间的理解</h3><h3>1.4 虚拟地址空间和物理地址空间是怎么映射的?</h3><h3>1.5 (回答的不是想要的) 比如说段表, 页表?</h3><h3>1.6 页表和段表是怎么管理的?</h3><h3>1.7 虚拟地址空间, 相比于物理地址空间有什么优势?</h3><h3>1.8 32位的CPU, 它的内存地址空间是多大?</h3><h3>1.9 在这4G空间内, 分成哪些区段?</h3><h3>1.10 (答得不好, 换了方向) 堆区和栈区的理解?</h3><h3>1.11 你说堆是进程间共享的?</h3><h3>1.12 栈的作用是什么?</h3><h3>1.13 如果一个函数调用另一个函数, 那么栈会发挥什么作用呢?</h3><h3>1.14 函数调用的过程你了解吗? 比如要存什么东西, 什么时候恢复?</h3><h3>1.15 内核态和用户态了解吗?</h3><h3>1.16 多线程问题, 对于一个数组, 可以多线程访问(读写删除修改), 有可能出现哪些问题?</h3><h3>1.17 刚刚说的这个数组, 能不能给我一个崩溃的情况?</h3><h3>1.18 为什么迭代器迭代过程删除会出现异常?</h3><h3>1.19 你可以详细说说是怎么崩溃的吗? 为什么会抛异常?</h3><h3>1.20 网络方面还没学是吧? 编译原理里面, 编译原理的步骤有哪些?</h3><h3>1.21 每一步在做什么处理?</h3><h3>1.22 (关于项目) 那你在做C0文法编译器的时候, 你做了这些哪些步骤?</h3><hr/><p>对于面试官来说, 可能是我太菜了, 他一般是从我的回答中选取知识点进行下一步提问, 这也提醒我, 不要随便提到自己不是很熟悉的知识点......</p><h2>Part 2: 链表的归并排序</h2><h3>2.1 归并排序还记得吗? 算法是什么样子的?口述.</h3><h3>2.2 如果我给的是一个单链表, 要怎么做?</h3><h3>2.3 你觉得用快慢指针的时候, 这两个链表要拆开吗?</h3><h3>2.4 算法实现</h3><p>出现了问题, 面试官表提示要取回slow的前一个, 然而之后自测时发现还是错了. (但面试官貌似没发现?心虚)</p><pre><code class="language-java">import java.util.*;

class ListNode{
    int val;
    ListNode next;
    ListNode(int val){
        this.val = val;
    }
}

public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        ListNode a = new ListNode(4);
        ListNode b = new ListNode(4);
        a.next = b;
        ListNode h = mergeSort(a);
    }
    
    private static ListNode mergeSort(ListNode head) {
        if(head == null){
            return null;
        }else if(head.next == null){
            return head;
        }
        ListNode fast = head;
        ListNode slow = head;
        ListNode slowBefore = head;
        while(fast != null &amp;&amp; fast.next != null){   // 出现问题的地方
            fast = fast.next.next;
            slowBefore = slow;
            slow = slow.next;
        }
        ListNode rightHead = slow;
        slowBefore.next = null;
        ListNode lh = mergeSort(head);
        ListNode rh = mergeSort(rightHead);
        //////////////////////////
        ListNode preHead = new ListNode(-1);
        ListNode currentNode = preHead;
        while(lh != null &amp;&amp; rh != null){
            if(lh.val &lt; rh.val){
                currentNode.next = lh;
                lh = lh.next;
            }else{
                currentNode.next = rh;
                rh = rh.next;
            }
            currentNode = currentNode.next;
        }
        if(lh != null){
            currentNode.next = lh;
        }
        if(rh != null){
            currentNode.next = rh;
        }
        return preHead.next;
    }
}
</code></pre><p>主要问题是, 快慢指针的判断条件有误.</p><p>快指针的每一次跳跃, 应该确保存在下一个跳跃的值(而不是null).</p><p>否则, 对于2个元素的情况, 快指针跳到了null, 慢指针跳到了第2个元素, 这个时候将慢指针的下一个元素为链表头的链表(长度为0)和原链表(长度为2)继续归并排序, 就会出现死循环.</p><p>主要还是和我昨天刚做的&quot;判断链表中是否存在环&quot;的题目混淆了, 附上那道题的代码:</p><h4><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></h4><pre><code class="language-java">public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode quick = head;
        ListNode slow = head;
        while(quick != null &amp;&amp; quick.next != null){ // 区别之处
            quick = quick.next.next;
            slow = slow.next;
            if(quick == slow){
                return true;
            }
        }
        return false;
    }
}
</code></pre><p>附上链表排序的正确答案:</p><h4><a href="https://leetcode-cn.com/problems/sort-list/">排序链表</a></h4><pre><code class="language-java">class Solution {
  public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode half = head;
    ListNode total = head;
    while (total.next != null &amp;&amp; total.next.next != null) { // 这里是关键
      half = half.next;
      total = total.next.next;
    }
    ListNode leftList = head;
    ListNode rightList = half.next;
    half.next = null;
    // left.size &gt; right.size
    leftList = sortList(leftList);
    rightList = sortList(rightList);
    return mergeSort(leftList, rightList);
  }

  private ListNode mergeSort(ListNode leftList, ListNode rightList) {
    ListNode preHead = new ListNode(0, leftList);
    ListNode p1 = preHead;
    ListNode p2 = rightList;
    while (p1.next != null &amp;&amp; p2 != null) {
      if (p1.next.val &gt;= p2.val) {
        rightList = p2.next;
        p2.next = p1.next;
        p1.next = p2;
        p1 = p2;
        p2 = rightList;
      } else {
        p1 = p1.next;
      }
    }
    if (p1.next == null) {
      p1.next = p2;
    }
    return preHead.next;
  }
}

</code></pre><h2>Part  3: 动态规划问题</h2><blockquote><p> 一个二维数组，找出其中的最长路径，每次只能向值比自己小的方向走，且每次只能向下或者向右走</p></blockquote><p>这道题一开始我直接说DFS+记忆路径, 然后面试官提示和之前的解有什么联系, 我恍然大悟, 是DP呀.</p><p>然后说了一堆都不对, 最后得知是我的理解有误, 我以为是从第一个点出发的最长路径, 但是其实是能联通的最长路径(也就是不限制起点)</p><p>那么这样的话就可以写出转移方程:
$$
D<!-- -->[i][j]<!-- -->=\max(canMove?D<!-- -->[i][j-1]<!-- -->:0,canMove?D<!-- -->[i-1][j]<!-- -->:0)+1
$$
于是有如下代码:</p><pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        System.out.println(&quot;Hello World!&quot;);
        int[][] map = new int[10][10];
        int[][] dp = new int[10][10];
        int n = 10;
        //////////////////////
        // init
        dp[0][0] = 1;
        for(int i = 1; i &lt; n; i++){
            if(map[0][i] &lt; map[0][i-1]){
                dp[0][i] = dp[0][i-1] + 1;
            }else{
                dp[0][i] = 1;
            }
        }
        for(int j = 1; j &lt; n; j++){
            if(map[j][0] &lt; map[j-1][0]){
                dp[j][0] = dp[j-1][0] + 1;
            }else{
                dp[j][0] = 1;
            }
        }
        // dp
        int max = 0;
        for(int i = 1; i &lt; n; i++){
            for(int j = 1; j &lt; n; j++){
                dp[i][j] = 1;
                if(map[i][j] &lt; map[i][j-1]){
                    dp[i][j] = dp[i][j-1] + 1;
                }
                if (map[i][j] &lt; map[i-1][j]){
                    dp[i][j] = Math.max(dp[i-1][j] + 1, dp[i][j]);
                }
                if(dp[i][j] &gt; max){
                    max = dp[i][j];
                }
            }
        }
        System.out.println(max);
    }
}
</code></pre><p>然后写的时候又出现了一堆问题...... </p><p>&quot;你这写的都是什么......&quot;</p><p>啊啊啊orz......</p><h2>Part 4: 尾声</h2><p>最后差不多写出来了, 面试官问还有啥要问他的, 我说面试的时候总是写不对算法怎么办, 他说这平时就要靠测试, 写的时候要清晰思路. </p><p>三面19号, 那个时候我就可以幸福地坐在家里的升降桌和工学椅的怀抱里了, 希望能好好准备操作系统和算法题, 争取取得实习机会.</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[简陋的Java生产者消费者模型]]></title>
        <id>简陋的Java生产者消费者模型</id>
        <link href="https://mondaycha.github.io/blog/2021/01/11/简陋的Java生产者消费者模型"/>
        <updated>2021-01-11T20:46:58.000Z</updated>
        <summary type="html"><![CDATA[上次面试的时候, 一面面试官问我怎么用多线程写个生产者消费者模型. 在圣杯战争之后, 我就再也没碰过Java多线程了, 上次Vue项目里需要向后台发送多条并列请求时是直接抄的别人写好的轮子......]]></summary>
        <content type="html"><![CDATA[<p>上次面试的时候, 一面面试官问我怎么用多线程写个生产者消费者模型. 在圣杯战争之后, 我就再也没碰过Java多线程了, 上次Vue项目里需要向后台发送多条并列请求时是直接抄的别人写好的轮子......</p><p>在LeetCode上做了几道多线程的题目, 已经封装好了, 只需要写内部实现, 但是面试的时候是全手撸呀...... 于是今天复习了一下怎么写Java的多线程, 用<code>BlockingQueue</code>实现的最简单的一种:</p><pre><code class="language-java">import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

class Producer implements Runnable {
    private final BlockingQueue&lt;Integer&gt; queue;

    Producer(BlockingQueue&lt;Integer&gt; queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) {
                Thread.sleep(1000);
                queue.put(produce());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private int produce() {
        int n = new Random().nextInt(10000);
        System.out.println(&quot;Producer name is &quot; + Thread.currentThread().getName()+ &quot; put &quot; + n);
        return n;
    }
}

class Customer implements Runnable{
    private final BlockingQueue&lt;Integer&gt; queue;

    Customer(BlockingQueue&lt;Integer&gt; queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        try {
            while (true) {
                Thread.sleep(2000);
                consume(queue.take());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void consume(int n){
        System.out.println(&quot;Customer name is &quot; + Thread.currentThread().getName()+ &quot; take &quot; + n);
    }
}

public class main {

    public static void main(String[] args) {
        BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(100);
        Producer p = new Producer(queue);
        Customer c1 = new Customer(queue);
        Customer c2 = new Customer(queue);
        Thread producer = new Thread(p);
        producer.setName(&quot;生产者&quot;);
        Thread cm1 = new Thread(c1);
        Thread cm2 = new Thread(c2);
        cm1.setName(&quot;消费者1&quot;);
        cm2.setName(&quot;消费者2&quot;);
        producer.start();
        cm1.start();
        cm2.start();
    }
}
</code></pre><p>最后总结一下创建线程时的要点:</p><ul><li>继承Thread: 没有共享资源</li><li>实现<code>Runnable</code>接口</li><li>Callable和Future: 不会</li></ul><p>在主线程中, 则是这样初始化的:</p><pre><code class="language-java">Producer p = new Producer(queue);
Thread producer = new Thread(p);
producer.setName(&quot;生产者&quot;);
producer.start();
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法学习笔记]]></title>
        <id>排序算法学习笔记</id>
        <link href="https://mondaycha.github.io/blog/2021/01/10/排序算法学习笔记"/>
        <updated>2021-01-10T07:20:21.000Z</updated>
        <summary type="html"><![CDATA[算法概述]]></summary>
        <content type="html"><![CDATA[<h2>算法概述</h2><p>排序算法可以分类为</p><ul><li><strong>比较排序:</strong> 下限为$O(n\log n)$.</li><li><strong>非比较类排序:</strong> 线性时间(计数排序/桶排序/基数排序)</li></ul><h2>算法复杂度</h2><p><img src="https://pic4.zhimg.com/80/v2-f4b442b09f0983d1821fec88c00f4f4b_720w.jpg"/></p><ul><li><strong>不稳定的排序:</strong> 希尔排序, 选择排序, 堆排序, 快速排序</li><li><strong>稳定的排序:</strong> 插入排序, 冒泡排序, 归并排序, 计数排序, 桶排序, 基数排序</li></ul>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[字节跳动 客户端研发实习生 一面面经]]></title>
        <id>字节跳动 客户端研发实习生 一面面经</id>
        <link href="https://mondaycha.github.io/blog/2021/01/09/字节跳动-客户端研发实习生-一面面经"/>
        <updated>2021-01-09T01:36:30.000Z</updated>
        <summary type="html"><![CDATA[啊, 结束了.]]></summary>
        <content type="html"><![CDATA[<p>啊, 结束了.</p><p>这个网站还没备案, 所以就放在这里自己看看.</p><h2>Q0: 于是并没有做自我介绍</h2><p>先问了是不是在宿舍, 会不会打扰舍友.</p><p>能保研吗?不能.</p><p>那要考研吗? 不考, 我想直接工作.</p><p>我问需要自我介绍吗? 不用了, 唔, 心疼写了一下午的自我介绍......</p><p>然后就开始撸题啦.</p><h2>Q1: 大数加法</h2><blockquote><p>输入</p><p>111111111111111111111111111</p><p>22222222222222222222222</p><p>输出</p><p>33333333333333333333333</p></blockquote><p>这个题很经典, 计组课上也写过硬件实现, 但是......死循环了.</p><p>修改前代码:</p><pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        String a = &quot;1111111&quot;;
        String b = &quot;222222&quot;;
        String c = sum(a,b); 
        System.out.println(c);
    }
    
    public static String sum(String a, String b){
        int aLength = a.length();
        int bLength = b.length();
        if(aLength &gt;= bLength){
            return sum(b,a);
        }
        while(aLength() &lt; bLength){
            a = &quot;0&quot; + a;
        }
        int temp = 0;
        int overFlow = 0;
        StringBuilder c = new StringBuilder();
        for(int i = a.length() - 1; i &gt;= 0; i--){
            char aIndex = a.charAt(i);
            char bIndex = b.charAt(i);
            temp = (aIndex - &#x27;0&#x27;) + (bIndex - &#x27;0&#x27;) + overFlow;
            if(temp &gt; 9){
                overFlow = 1;
                c = c.append(0);
            }else{
                overFlow = 0;
                c = c.append(temp);
            }
        }
        if(overFlow == 1){
            c = c.append(1);
        }
        return c.reverse().toString();
    }
}
</code></pre><p>之后PB帮我复盘, 我就不应该定义两个length变量, 修改后成功输出:</p><pre><code class="language-java">import java.util.*;
public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        String a = &quot;1111111&quot;;
        String b = &quot;222222&quot;;
        String c = sum(a,b); 
        System.out.println(c);
    }
    
    public static String sum(String a, String b){
        int aLength = a.length();
        int bLength = b.length();
        if(aLength &gt;= bLength){
            return sum(b,a);
        }
        while(a.length() &lt; bLength){    // 原来这里死循环了
            a = &quot;0&quot; + a;
        }
        int temp = 0;
        int overFlow = 0;
        StringBuilder c = new StringBuilder();
        for(int i = aLength - 1; i &gt;= 0; i--){  // 原来这里出错了
            char aIndex = a.charAt(i);
            char bIndex = b.charAt(i);
            temp = (aIndex - &#x27;0&#x27;) + (bIndex - &#x27;0&#x27;) + overFlow;
            if(temp &gt; 9){
                overFlow = 1;
                c = c.append(0);
            }else{
                overFlow = 0;
                c = c.append(temp);
            }
        }
        if(overFlow == 1){
            c = c.append(1);
        }
        return c.reverse().toString();
    }
}
</code></pre><p>于是在面试官慈祥的微笑下, 我进入了下一道题.</p><h2>Q2: <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><blockquote><p>输入</p><p>二叉树</p><p>前 </p><p>中</p><p>后</p></blockquote><p>同样输出有问题, 原来的代码如下:</p><pre><code class="language-java">import java.util.*;

class ListNode{
    int val;
    ListNode left;
    ListNode right;
    
    ListNode(int a){
        this.val = a;
    }
}

public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        // Order
        int[] preOrder = new int[]{1,2,4,5,3,5,7};
        int[] midOrder = new int[]{4,2,5,1,3,5,7};
        ListNode root = getTreeRoot(preOrder, 0, preOrder.length - 1, 
                                    midOrder, 0, midOrder.length - 1);
        afterOrder(root);
    }
    
    private static ListNode getTreeRoot(int[] pre, int preLeft, int preRight,
                                 int[] mid, int midLeft, int midRight){
        if(preLeft &gt; preRight){
            return null;
        }
        if(preLeft &gt;= preRight || midLeft &gt;= midRight){
            return new ListNode(pre[preLeft]);
        }
        int headPre = pre[preLeft];
        System.out.println(&quot;now is &quot; + headPre);
        ListNode head = new ListNode(headPre);
        int headMidIndex = 0;
        int leftLength = 0;
        for(int i = midLeft; i &lt;= midRight; i++){
            if(mid[i] == headPre){
                headMidIndex = i;
                leftLength = headMidIndex - midLeft;
                break;
            }
        }
        ListNode leftNode = getTreeRoot(pre,preLeft+1,preLeft+leftLength,
                                       mid,midLeft,headMidIndex-1);
        ListNode rightNode = getTreeRoot(pre,preLeft+leftLength+1,preRight,
                                        mid,headMidIndex+1,midRight);
        head.left = leftNode;
        head.right = rightNode;
        return head;
    }
    
    private static void afterOrder(ListNode h){
        afterOrder(h.left);
        afterOrder(h.right);
        System.out.println(h.val);
    }
}
</code></pre><p>后序遍历写错啦啊啊啊, 修改后如下:</p><pre><code class="language-java">import java.util.*;

class ListNode{
    int val;
    ListNode left;
    ListNode right;
    
    ListNode(int a){
        this.val = a;
    }
}

public class Main {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        // Order
        int[] preOrder = new int[]{1,2,4,5,3,5,7};
        int[] midOrder = new int[]{4,2,5,1,3,5,7};
        ListNode root = getTreeRoot(preOrder, 0, preOrder.length - 1, 
                                    midOrder, 0, midOrder.length - 1);
        afterOrder(root);
    }
    
    private static ListNode getTreeRoot(int[] pre, int preLeft, int preRight,
                                 int[] mid, int midLeft, int midRight){
        if(preLeft &gt; preRight){
            return null;
        }
        if(preLeft &gt;= preRight || midLeft &gt;= midRight){
            return new ListNode(pre[preLeft]);
        }
        int headPre = pre[preLeft];
        System.out.println(&quot;now is &quot; + headPre);
        ListNode head = new ListNode(headPre);
        int headMidIndex = 0;
        int leftLength = 0;
        for(int i = midLeft; i &lt;= midRight; i++){
            if(mid[i] == headPre){
                headMidIndex = i;
                leftLength = headMidIndex - midLeft;
                break;
            }
        }
        ListNode leftNode = getTreeRoot(pre,preLeft+1,preLeft+leftLength,
                                       mid,midLeft,headMidIndex-1);
        ListNode rightNode = getTreeRoot(pre,preLeft+leftLength+1,preRight,
                                        mid,headMidIndex+1,midRight);
        head.left = leftNode;
        head.right = rightNode;
        return head;
    }
    
    private static void afterOrder(ListNode h){
        if(h.left != null){ // 递归缺少终止条件
            afterOrder(h.left);
        }
        if(h.right != null){
            afterOrder(h.right);
        }
        System.out.println(h.val);
    }
}
</code></pre><p>我知道了, 脱离了IDEA我就啥也写不对.</p><p>哎, 接下来在二面之前, 我要直接在LeetCode在线网站上写代码.</p><h2>Q3: 计算机中的十种排序, 哪些是稳定的, 哪些是不稳定的.</h2><p>我只记得几个了.</p><p>我说:</p><ul><li>稳定: 插入/冒泡/归并/选择</li><li>不稳定: 快速排序, 桶排序</li></ul><h2>Q3.1: 给一百万个数, 其中大部分是有序的, 怎么排最快?</h2><p>我的回答:归并+剪枝?</p><p>没有继续提问, 不清楚是啥, 待会找下.</p><p>-------分割线----------</p><p>于是问了问HZM, 这是个基本有序问题.</p><p> 应该用插入排序的.</p><blockquote><p>直接插入排序是数据越有序越快，最快时间复杂度可达到O(n) .</p><p>选择排序无论何时都是O（n^2）</p><p>快速排序越有序越慢，它要从后到前遍历找比基准小的，时间复杂度达到O(n)</p><p>归并排序固定O(n*log n)，有序只是减少了元素交换次数。</p></blockquote><h2>Q4: 操作系统</h2><p>用Java写个生产者消费者模型, 但上次写Java多线程还是去年, 已经忘了怎么继承Thread了......</p><p>于是换了个题.</p><h2>Q5: 一个点从原点出发回到原点的概率</h2><blockquote><p>人 坐标原点</p><p>N</p></blockquote><ul><li>奇数:0</li><li>偶数: 我说的是分母是$4^n$, 关于$\frac{n}{2}$对称, 分子是对所有的$k$求和, 思路大概是对的, 但是没有进一步化简.</li></ul><p>相关解答:<a href="https://www.zhihu.com/question/310998719">一个点用偶数步从原点出发回到原点有几种走法？</a></p><h2>Q6: 你还有什么要问我的吗?</h2><p>时间也差不多了, 今天就到这里.</p><p>貌似是面试必问问题. </p><ul><li>您在部门负责什么? 工程师</li><li>Java是不是写安卓(我想写安卓客户端)</li></ul><p>然后结束了, 感觉面试官还是很和蔼的, 人生第一次面试就这样结束了, 感觉还是比较幸运的. </p><p>自己的不足还是太多了, 二面在11号, 加油.</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode「830」 较大分组的位置]]></title>
        <id>LeetCode「830」 较大分组的位置</id>
        <link href="https://mondaycha.github.io/blog/2021/01/06/LeetCode「830」-较大分组的位置"/>
        <updated>2021-01-06T01:04:50.000Z</updated>
        <summary type="html"><![CDATA[基本思路]]></summary>
        <content type="html"><![CDATA[<h2>基本思路</h2><p>一次遍历.</p><h2>出现问题</h2><p>虽然以为是简单题, 但是提交之后直接报了错......</p><pre><code>17:00   info
            解答失败:
            测试用例:&quot;aaa&quot;
            测试结果:[]
            期望结果:[[0,2]]
            stdout:
</code></pre><p>我一看, ┗|｀O′|┛ 嗷~~, 原来是昨天, 啊不, 原来是没特判最后一个数.</p><h2>Java代码</h2><pre><code class="language-java">//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
  public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) {
    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();
    int currentLength = 1;
    int currentBegin = 0;
    for (int i = 1; i &lt; s.length(); ++i) {
      if (s.charAt(i) == s.charAt(i - 1)) {
        currentLength++;
      } else {
        if (currentLength &gt;= 3) {
          List&lt;Integer&gt; one = new LinkedList&lt;&gt;();
          one.add(currentBegin);
          one.add(i - 1);
          ans.add(one);
        }
        currentLength = 1;
        currentBegin = i;
      }
    }
    if (currentLength &gt;= 3) {
      List&lt;Integer&gt; one = new LinkedList&lt;&gt;();
      one.add(currentBegin);
      one.add(s.length() - 1);
      ans.add(one);
    }
    return ans;
  }
}
</code></pre><h2>复杂度</h2><ul><li><p>时间复杂度为$O(n)$</p><blockquote><p>遍历了数组一次</p></blockquote></li><li><p>空间复杂度为$O(1)$</p></li></ul><h2>解答结果</h2><pre><code>17:02   info
            解答成功:
            执行耗时:1 ms,击败了100.00% 的Java用户
            内存消耗:38.7 MB,击败了50.54% 的Java用户
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode「509」 斐波那契数]]></title>
        <id>LeetCode「509」 斐波那契数</id>
        <link href="https://mondaycha.github.io/blog/2021/01/04/LeetCode「509」-斐波那契数"/>
        <updated>2021-01-04T16:52:42.000Z</updated>
        <summary type="html"><![CDATA[基本思路]]></summary>
        <content type="html"><![CDATA[<h2>基本思路</h2><p>看到是斐波那契数, 默默写了个时间复杂度和空间复杂度都是$O(n)$的解法......</p><pre><code>执行耗时:0 ms,击败了100.00% 的Java用户
内存消耗:35.1 MB,击败了67.02% 的Java用户
</code></pre><p>因为限制了N的大小, 理论上你甚至可以打表:</p><pre><code class="language-java">class Solution {
  public int fib(int n) {
    int[] fibArrays = new int[31];
    fibArrays[0] = 0;
    fibArrays[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
      fibArrays[i] = fibArrays[i - 1] + fibArrays[i - 2];
    }
    return fibArrays[n];
  }
}
</code></pre><p>不过我这种解法在面试官面前显然毫无亮点啊......下面是膜拜官方题解时间.</p><h2>官方题解</h2><h3>法1: 动态规划</h3><p>和我的差不多, 可以进一步优化空间复杂度.</p><h3>法2: 矩阵快速幂</h3><p>$$
\left<!-- -->[\begin{array}{cc}
1 &amp; 1 <!-- -->\<!-- -->
1 &amp; 0
\end{array}\right]<!-- -->\left<!-- -->[\begin{array}{c}
F(n) <!-- -->\<!-- -->
F(n-1)
\end{array}\right]<!-- -->=\left<!-- -->[\begin{array}{c}
F(n)+F(n-1) <!-- -->\<!-- -->
F(n)
\end{array}\right]<!-- -->=\left<!-- -->[\begin{array}{c}
F(n+1) <!-- -->\<!-- -->
F(n)
\end{array}\right]<!-- -->
$$</p><p>因此有:
$$
\left<!-- -->[\begin{array}{c}
F(n+1) <!-- -->\<!-- -->
F(n)
\end{array}\right]<!-- -->=\left<!-- -->[\begin{array}{ll}
1 &amp; 1 <!-- -->\<!-- -->
1 &amp; 0
\end{array}\right]<!-- -->^{n}\left<!-- -->[\begin{array}{l}
F(1) <!-- -->\<!-- -->
F(0)
\end{array}\right]<!-- -->
$$
所以只要计算矩阵$<!-- -->[1,1;1,0]<!-- -->$的$n$次幂就能得到第N项的值.</p><p>(要考试, 先留着, 过两天写)</p><h3>法3: 通项公式</h3><p>$$
F(n)=\frac{1}{\sqrt{5}}\left<!-- -->[\left(\frac{1+\sqrt{5}}{2}\right)^{n}-\left(\frac{1-\sqrt{5}}{2}\right)^{n}\right]<!-- -->
$$</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode「86」 分隔链表]]></title>
        <id>LeetCode「86」 分隔链表</id>
        <link href="https://mondaycha.github.io/blog/2021/01/03/LeetCode「86」-分隔链表"/>
        <updated>2021-01-03T17:35:08.000Z</updated>
        <summary type="html"><![CDATA[基本思路]]></summary>
        <content type="html"><![CDATA[<h2>基本思路</h2><p>感觉和快速排序中的<code>Partition</code>很接近, 相比数组的分割, 链表可以直接分别储存左支和右支, 在思路上会清晰很多.</p><p>而如果依然是采用快排的方式, 那么就需要在交换两个节点时依次替换所有关联节点, 效率不如前者.</p><h2>Java代码</h2><pre><code class="language-java">class Solution {
  public ListNode partition(ListNode head, int x) {
    ListNode smallHead = new ListNode(0);
    ListNode smallEnd = smallHead;
    ListNode largeHead = new ListNode(0);
    ListNode largeEnd = largeHead;
    ListNode currentNode = head;
    while (currentNode != null) {
      if (currentNode.val &lt; x) {
        smallEnd.next = currentNode;
        smallEnd = smallEnd.next;
      } else {
        largeEnd.next = currentNode;
        largeEnd = largeEnd.next;
      }
      currentNode = currentNode.next;
    }
    largeEnd.next = null;
    smallEnd.next = largeHead.next;
    return smallHead.next;
  }
}
</code></pre><p>测试代码:</p><pre><code class="language-java">public static void main(String[] args) {
  Solution solution = new PartitionList().new Solution();
  ListNode n1 = new ListNode(1);
  ListNode n2 = new ListNode(2);
  ListNode n3 = new ListNode(3);
  ListNode n4 = new ListNode(4);
  n4.next = n3;
  n3.next = n1;
  n1.next = n2;
  System.out.println(solution.partition(n4, 2));
}
</code></pre><h2>复杂度</h2><ul><li><p>时间复杂度为$O(n)$</p><blockquote><p>遍历了链表一次</p></blockquote></li><li><p>空间复杂度为$O(1)$</p></li></ul><h2>解答结果</h2><pre><code>执行耗时:0 ms,击败了100.00% 的Java用户
内存消耗:37.9 MB,击败了35.15% 的Java用户
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode「239」 滑动窗口最大值]]></title>
        <id>LeetCode「239」 滑动窗口最大值</id>
        <link href="https://mondaycha.github.io/blog/2021/01/02/LeetCode「239」-滑动窗口最大值"/>
        <updated>2021-01-02T23:37:10.000Z</updated>
        <summary type="html"><![CDATA[前段时间的LeetCode每日打卡也许可以说坚持住了, 接下来朝着每次做完都输出题解的目标努力吧.]]></summary>
        <content type="html"><![CDATA[<p>前段时间的LeetCode每日打卡也许可以说坚持住了, 接下来朝着每次做完都输出题解的目标努力吧.</p><h2>基本思路</h2><p>之前没有做过滑动窗口的题,看到它我的第一反应: DP! 那么就需要维护当前窗口内的index与数字大小次序, 但是要如何把已经位于窗口左侧的数字剔除呢? 我没有很好的思路.</p><p>最后看了题解......原来是这样的啊.队首的元素必然是窗口以及窗口之前元素的最大值, 在取出队首元素时判断是否已经过期, 如果过期则出队, 妙耶.</p><p>index和对应数字都小的必然不会被选择, 所以可以将这个双向队列优化为单调队列.</p><h2>Deque数据结构</h2><p>要达到$O(n)$级别复杂度的关键就在于双向队列这个数据结构, 可以在队列的首尾进行操作(而一般的队列只能从队尾入队, 从队首出队).</p><p>Deque的API如下:</p><blockquote><h3>插入元素</h3><p><code>addFirst()</code>: 向队头插入元素，如果元素为空，则发生NPE(NPE是指编程语言中的空指针异常)
<code>addLast()</code>: 向队尾插入元素，如果为空，则发生NPE
<code>offerFirst()</code>: 向队头插入元素，如果插入成功返回true，否则返回false
<code>offerLast()</code>: 向队尾插入元素，如果插入成功返回true，否则返回false</p><h3>移除元素</h3><p><code>removeFirst()</code>: 返回并移除队头元素，如果该元素是null，则发生NoSuchElementException
<code>removeLast()</code>: 返回并移除队尾元素，如果该元素是null，则发生NoSuchElementException
<code>pollFirst()</code>: 返回并移除队头元素，如果队列无元素，则返回null
<code>pollLast()</code>: 返回并移除队尾元素，如果队列无元素，则返回null</p><h3>获取元素</h3><p><code>getFirst()</code>: 获取队头元素但不移除，如果队列无元素，则发生NoSuchElementException
<code>getLast()</code>: 获取队尾元素但不移除，如果队列无元素，则发生NoSuchElementException
<code>peekFirst()</code>: 获取队头元素但不移除，如果队列无元素，则返回null
<code>peekLast()</code>: 获取队尾元素但不移除，如果队列无元素，则返回null</p></blockquote><p>区别主要在遇到空元素或队列无元素时, 是抛异常还是返回false或者null. 所以最常用的还是<code>offer</code>和<code>poll</code>/<code>peek</code>吧.</p><h2>Java代码</h2><pre><code class="language-java">class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; k; i++) {
            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i &lt; n; i++) {
            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            while (deque.peekFirst() &lt; i - k + 1) {
                deque.pollFirst();
            }
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
</code></pre><h2>复杂度</h2><ul><li><p>时间复杂度为$O(n)$</p><blockquote><p>其中n是数组 nums的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)</p></blockquote></li><li><p>空间复杂度为$O(k)$</p><blockquote><p>队列中最多不会有超过 k+1个元素</p></blockquote></li></ul><h2>解答结果</h2><pre><code>执行用时: 35 ms
内存消耗: 58.2 MB
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Vue的手办百科与交易平台]]></title>
        <id>基于Vue的手办百科与交易平台</id>
        <link href="https://mondaycha.github.io/blog/2020/12/13/基于Vue的手办百科与交易平台"/>
        <updated>2020-12-13T20:23:51.000Z</updated>
        <summary type="html"><![CDATA[项目地址：https://github.com/MondayCha/FigureHub-Frontend]]></summary>
        <content type="html"><![CDATA[<blockquote><p>项目地址：<a href="https://github.com/MondayCha/FigureHub-Frontend">https://github.com/MondayCha/FigureHub-Frontend</a></p></blockquote><h2>网站主页</h2><p>网站名为“Figure Hub”，通过npm run serve指令，将前端部署到本地服务器后，即可进入数据库网站。网站整体采用新拟态风格，效果介于扁平化与投影风之间。</p><p>对于访客用户，可以浏览首页的推荐以及商城卡片，需要注册登录才能浏览百科、商品详情，进行购买、发布商品等操作。</p><p><img src="https://pic2.zhimg.com/v2-f3847ae7927c0b2d46cd72fc9c60a86d_b.png" alt="我的动画啊啊啊啊，全部不能展示"/></p><h2>用户注册与登录</h2><p>通过顶部栏的“登录”按钮可以进入登录以及注册页面。前端实现了简单的数据校验，密码支持英文、数字、下划线，当检验到用户名和密码不为空时，才发送登录请求。</p><p><img src="https://pic3.zhimg.com/v2-e690c85af268ae3384a52ea8056c2886_b.png" alt="pixiv id：81821752"/></p><p>点击注册按钮进入注册页面，输入用户名、密码，上传头像和登记昵称后，在注册页面可以进行用户类型的选择。</p><p>可以注册的用户类型包括管理员、厂商用户、普通用户。通过前端的业务逻辑以及后端的token校验，为不同类型的访问者提供对应的功能。</p><p><img src="https://pic2.zhimg.com/v2-c8b44a1c9ffaeef5af748fdf28566745_b.png" alt="没错，你说得对"/></p><p><img src="https://pic4.zhimg.com/v2-57568fc97a2f00bda6ab9d45204909ef_b.png" alt="感谢PB给我抄登陆界面"/></p><h2>商品与交易</h2><p>登陆后，顶部导航栏显示用户头像，并在最右侧显示“发布”按钮，普通用户可以在这里发布自己的二手或全新手办模型，在一次交易发起后从商城下架，厂商用户则可以发布余量充足的产品。</p><p><img src="https://pic4.zhimg.com/v2-61025aeab91539610d70a3560b07ecb7_b.png" alt="img"/></p><p>在上传商品时，最多可以上传9张详情图片。</p><p><img src="https://pic3.zhimg.com/v2-734a934a7a5ee7156dd015a06da92e3a_b.png" alt="img"/></p><p>发布成功后将弹出成功提示，并在“购物”栏目下显示发布的手办橱窗。与详情页相比，橱窗卡片显示了价格、发布者等简要信息。</p><p><img src="https://pic1.zhimg.com/v2-beac2ab565141fb156faa1fd2ea922d0_b.png" alt="233"/></p><p>橱窗整体采用三栏布局，每次对商品表进行计算后排列。</p><p><img src="https://pic4.zhimg.com/v2-1cbc26ebd28885d610a672ec0833bed7_b.png" alt="img"/></p><p>抄的Pixivic和舍友修改的代码</p><blockquote><p> 源地址：<a href="https://github.com/cheer-fun/pixivic-pcgithub.com">https://github.com/cheer-fun/pixivic-pcgithub.com</a></p></blockquote><p>首页同样可以点击卡片引流，进入详情页面。</p><p><img src="https://pic3.zhimg.com/v2-d3b9e24c4bee0ee00068ca7c1748d1ee_b.png" alt="img"/></p><blockquote><p>首页参考的是Bilibili-Evgithub.com</p></blockquote><p>点击橱窗卡片（或从首页进入）后，会显示动画效果并跳转到详情页面，集成了浏览详情图片（多张，滚动播放）、收藏、购买、百科、发布者主页、相关推荐、评论、点赞、删除评论等功能。用户可在个人中心下架自己发布的商品。</p><p><img src="https://pic1.zhimg.com/v2-7bbdb8a63e0f704d662982869cb69808_b.png" alt="img"/></p><p>点击详情页面的“收藏”按钮，可以将商品加入收藏。</p><p><img src="https://pic1.zhimg.com/v2-25203d045698db58d171cfd7fed98da0_b.png" alt="img"/></p><p>点击“购买”按钮，可以确认当前商品信息，执行假支付后将提交交易订单，交易状态为待确认。</p><p><img src="https://pic3.zhimg.com/v2-9ddc8d930b90994c7e43b30f9d901dae_b.png" alt="感谢GTC给我抄支付页面"/></p><p>通过顶部栏的“订单”可以进入订单页面，显示用户发布、卖出、买入信息，管理员账户则增加“交易管理”页面，可以删除订单。</p><p><img src="https://pic4.zhimg.com/v2-9b0e0899393b4dd23948b48cc729d97b_b.png" alt="img"/></p><p>在订单页面，可以确认收货：</p><p><img src="https://pic3.zhimg.com/v2-feed8280a48aca9fe46d0b3abfee844e_b.png" alt="img"/></p><p>收货后交易状态变更为待评价，按钮变为“我要评价”：</p><p><img src="https://pic2.zhimg.com/v2-570ee8589aff27d27a10595023ef6e75_b.png" alt="img"/></p><p>评价完成后，可以查看自己发布的评论：</p><p><img src="https://pic4.zhimg.com/v2-98ae30b36a14c2c047cc98efc38fd2bb_b.png" alt="img"/></p><p>用户也可以删除自己买入和卖出的订单：</p><p><img src="https://pic3.zhimg.com/v2-ff36aa9eb7798f32835b89e67062e6ca_b.png" alt="img"/></p><h2>百科信息</h2><p>在管理界面，管理员以及厂商用户可以对厂商信息、角色信息、手办模型信息、作品信息以及手办与角色对应关系进行增删查改等操作。对普通用户，“百科管理”并不显示（如上图演示的管理界面中就没有此页面）。</p><p><img src="https://pic4.zhimg.com/v2-761d9a1d7fdede89f857c2b2a2f9f393_b.png" alt="img"/></p><p>通过左侧的侧边栏选择不同的列表。同时页面支持响应式布局，可以针对不同页面宽度，自行适配合适的页面布局。</p><p><img src="https://pic4.zhimg.com/v2-e779dea7a3661f2edc2147afd8799a57_b.png" alt="img"/></p><p>下面进行表格的增加、删除、查找、修改操作的演示。</p><h3>4.1 页面初始化</h3><p>开启页面时，前端通过axios向后端发送请求，如果不能正常加载数据，则显示加载动画和错误提示。</p><p><img src="https://pic1.zhimg.com/v2-18f550c30ad1f41b4dc37cfc6409fa28_b.jpg" alt="img"/></p><p>初始化成功，页面以每页4条的格式渲染数据，并显示当前的总数据量。</p><p><img src="https://pic4.zhimg.com/v2-114c68825c13a0928d8bd9862930ea53_b.png" alt="img"/></p><h3>4.2 添加项目</h3><p>单击左上角的“添加”按钮，即可弹出添加新项目的表单。</p><p><img src="https://pic3.zhimg.com/v2-4beb392f1f2fe052dc8d43b292dc93ee_b.png" alt="img"/></p><p>在表单中会对项目内容做初步验证（如模型名称不能为空、价格须为数字等）。</p><p><img src="https://pic4.zhimg.com/v2-5075585dafe932c01e5ffb09b21c9443_b.png" alt="img"/></p><p>添加成功后，前端向后端发送添加请求，重新获取数据后渲染到页面，同时在数据库可查询到添加的项目。</p><p><img src="https://pic1.zhimg.com/v2-8abf0b54a9ba933968ae892c2f815410_b.jpg" alt="img"/></p><h3>4.3 删除数据</h3><p>需要删除某一条数据时，单击操作中的“删除”按钮，弹出气泡确认框。</p><p><img src="https://pic2.zhimg.com/v2-8984ec85b5cf0ba3f51d2a9896292971_b.jpg" alt="img"/></p><p>确定后，前端向后端发送删除请求，并在重新获取数据后将其渲染到页面，自动进行刷新，原本的条目已被删除。</p><h3>4.4 查找数据</h3><p>在右上角的输入框选择筛选的类型（如：名字、性别等），可以进行关键词搜索。</p><p><img src="https://pic2.zhimg.com/v2-3d27ff9310cd27f9493eae970557a641_b.png" alt="img"/></p><h3>4.5 修改数据</h3><p>对需要修改的数据进行修改操作，会弹出修改项目的表单，该行数据的内容已预填入表单中：</p><p><img src="https://pic2.zhimg.com/v2-339a464a500d7a3281d5036cd843ee69_b.png" alt="img"/></p><p>在这里我们将模型类型修改成“粘土人”，在通过字典转换成int型数据后，向后端发送修改请求并拉取新数据。</p><p><img src="https://pic3.zhimg.com/v2-d9672045e6de627c21e73c79a30fec66_b.jpg" alt="img"/></p><h3>4.6 上传图片</h3><p>角色和手办模型都对应多张图片，每次最多可以上传9张详情图片。         </p><p><img src="https://pic3.zhimg.com/v2-a89f8b330c5d4df910ab2422c0d3c74a_b.png" alt="img"/></p><p>为了方便管理，图片在管理页面中不显示，可以在百科中显示。</p><p><img src="https://pic4.zhimg.com/v2-1c4d2b9359438d8fe29bb7cf5188c43f_b.png" alt="img"/></p><h2>评论管理</h2><p>用户除了发布评价，还可以对手办进行评论。在商品页面，将该商品对应的厂商以及关键词以标签形式展示，点击标签即可跳转到对应的百科页面。</p><p><img src="https://pic1.zhimg.com/v2-b2480c8b1e8a9f81f778997dc75d4d9c_b.png" alt="img"/></p><p>评论有两个入口，一是商品页面直接链接到该商品对应手办的评论区；一是手办的百科详情页。</p><p><img src="https://pic4.zhimg.com/v2-fd8d3268f671bfd444b40f5e7c19e4fb_b.png" alt="img"/></p><p>输入评论后即可发布，将显示时间戳、点赞、删除（管理员或者自己可以删除）按钮。自己无法给自己的评论点赞，通过前端实现此逻辑。</p><p><img src="https://pic1.zhimg.com/v2-feb43028317af0b41dbd2c5e65986a64_b.png" alt="img"/></p><p>时间戳将转换为时间范围，鼠标浮动时显示具体的时间，提升用户体验。</p><p><img src="https://pic2.zhimg.com/v2-f100e44f8b8e019591d40155c019f679_b.png" alt="感谢WPB的评论区！！！"/>点击删除后将删除此评论。</p><p><img src="https://pic4.zhimg.com/v2-141a90143919a368001126b7e9652baf_b.png" alt="img"/></p><p>其他用户可以为该用户点赞，点赞后按钮变为粉色，显示点赞数，无法继续点赞。         </p><p><img src="https://pic2.zhimg.com/v2-48971b33d59e6c2962764f5137663361_b.png" alt="img"/></p><p>在商品详情页面右侧，显示了发布者的信息，可以进入个人主页：</p><p><img src="https://pic1.zhimg.com/v2-bffaa5b58e0fb6e0c6b3e16328601e08_b.png" alt="感谢DBX的详情页！他是仿的Pixiv"/></p><p>在个人主页，可以查看该用户的用户类型、收藏与评论信息：</p><p><img src="https://pic1.zhimg.com/v2-177f9f9c6fd265becfedb1a73eb95118_b.png" alt="感谢WPB！！！"/></p><p>以上，网站源代码见开头，后端不是我写的，所以没给代码。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode「659」 分割数组为连续子序列]]></title>
        <id>LeetCode「659」 分割数组为连续子序列</id>
        <link href="https://mondaycha.github.io/blog/2020/12/04/LeetCode「659」-分割数组为连续子序列"/>
        <updated>2020-12-04T22:22:42.000Z</updated>
        <summary type="html"><![CDATA[在经过一番挣扎之后, 我的Hexo博客终于再次开张了.这几天又没有坚持LeetCode打卡, 算法作业也还没有动笔.]]></summary>
        <content type="html"><![CDATA[<p>在经过一番挣扎之后, 我的Hexo博客终于再次开张了.这几天又没有坚持LeetCode打卡, 算法作业也还没有动笔.</p><p>今天的每日我其实也没有思路, 那就把题解尝试一下吧.</p><h2>方法1: 哈希表+最小堆</h2><h3>基本思路</h3><ul><li>哈希表: 键为子序列的最后一个数字, 值为最小堆</li><li>最小堆: 通过长度+最后一个字符的形式可以表示一个连续子序列, 所以最小堆顶部就是最短的子序列长度.</li></ul><p>遍历结束时, 遍历最小堆的堆顶元素, 是否都不小于3.</p><h3>Java代码</h3><pre><code class="language-java">public class SplitArrayIntoConsecutiveSubsequences {
    public static void main(String[] args) {
        Solution solution = new SplitArrayIntoConsecutiveSubsequences().new Solution();
        System.out.println(solution.isPossible(new int[]{1, 1, 2, 2, 3, 3, 3}));
    }

    class Solution {
        public boolean isPossible(int[] nums) {
            HashMap&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; childMap = new HashMap&lt;&gt;();
            for (int i : nums) {
                if (!childMap.containsKey(i)) {
                    childMap.put(i, new PriorityQueue&lt;&gt;());
                }
                if (childMap.containsKey(i - 1)) {
                    int minLength = childMap.get(i - 1).poll();
                    if (childMap.get(i - 1).isEmpty()) {
                        childMap.remove(i - 1);
                    }
                    childMap.get(i).offer(minLength + 1);
                } else {
                    childMap.get(i).offer(1);
                }
            }
            for (PriorityQueue&lt;Integer&gt; queue : childMap.values()) {
                if (queue.peek() &lt; 3) {
                    return false;
                }
            }
            return true;
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre><h3>复杂度</h3><ul><li><p>时间复杂度为$O(n\log n)$</p><blockquote><p>需要遍历数组，对于数组中的每个数，都要对哈希表和最小堆进行更新。每个数对应的最小堆的长度不超过 n，因此每次对最小堆的操作的时间复杂度是 $O(\log n)$，数组长度为 n，因此时间复杂度是 $O(n \log n)$。
然后需要遍历哈希表中的每一条记录，判断是否满足每个子序列的长度都不小于3，子序列的数量不会超过 n，因此时间复杂度是 $O(n)$。
因此总时间复杂度是 $O(n \log n)$</p></blockquote></li><li><p>空间复杂度为$O(n)$</p><blockquote><p>空间复杂度：<em>O(n)</em>，其中 <em>n</em> 是数组的长度。需要使用哈希表和最小堆存储以每个数结尾的各个子序列的长度，哈希表和最小堆中的元素数量不会超过数组的长度。</p></blockquote></li></ul><h3>解答结果</h3><pre><code>执行耗时:84 ms,击败了12.12% 的Java用户
内存消耗:39.7 MB,击败了58.51% 的Java用户
</code></pre><h2>方法2: 贪心</h2><h3>基本思路</h3><p>将x加入已有的子序列总是比新建一个长度为1 的子序列更优.</p><ul><li>使用两个哈希表, 一个存储每个数字的剩余次数, 一个存储每个数字作为结尾的子序列(长度大于等于3)的数量.</li><li>先初始化剩余次数</li><li>遍历数组, 由于产生新的子序列时会预读, 所以需要判断该数字的剩余次数, 维护这两个哈希表</li></ul><h3>Java代码</h3><pre><code class="language-java">class Solution {
    public boolean isPossible(int[] nums) {
        HashMap&lt;Integer, Integer&gt; leftTimes = new HashMap&lt;&gt;();
        HashMap&lt;Integer, Integer&gt; subsCount = new HashMap&lt;&gt;();
        // 初始化剩余次数
        for (int i : nums) {
            leftTimes.put(i, leftTimes.getOrDefault(i, 0) + 1);
        }
        // 遍历数组, 由于产生新的子序列时会预读, 所以需要判断该数字的剩余次数, 维护这两个哈希表
        int xTime, lastLength;
        for (int x : nums) {
            if ((xTime = leftTimes.getOrDefault(x, 0)) &gt; 0) {
                leftTimes.put(x, xTime - 1);
                if ((lastLength = subsCount.getOrDefault(x - 1, 0)) &gt; 0) {
                    // 取前
                    subsCount.put(x - 1, lastLength - 1);
                    subsCount.put(x, subsCount.getOrDefault(x, 0) + 1);
                } else {
                    // 产生新的子序列
                    int yTime, zTime;
                    if ((yTime = leftTimes.getOrDefault(x + 1, 0)) == 0 ||
                            (zTime = leftTimes.getOrDefault(x + 2, 0)) == 0) {
                        return false;
                    }
                    leftTimes.put(x + 1, yTime - 1);
                    leftTimes.put(x + 2, zTime - 1);
                    subsCount.put(x + 2, subsCount.getOrDefault(x + 2, 0) + 1);
                }
            }
        }
        return true;
    }
}
</code></pre><h3>复杂度分析</h3><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h3>解答结果</h3><pre><code>执行耗时:37 ms,击败了36.70% 的Java用户
内存消耗:39.6 MB,击败了66.67% 的Java用户
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode「767」 重构字符串]]></title>
        <id>LeetCode「767」 重构字符串</id>
        <link href="https://mondaycha.github.io/blog/2020/11/30/LeetCode「767」-重构字符串"/>
        <updated>2020-11-30T19:02:09.000Z</updated>
        <summary type="html"><![CDATA[思路分析]]></summary>
        <content type="html"><![CDATA[<h2>思路分析</h2><h2>代码实现</h2><pre><code class="language-java">//给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。 
//
// 若可行，输出任意可行的结果。若不可行，返回空字符串。 
//
// 示例 1: 
//
// 
//输入: S = &quot;aab&quot;
//输出: &quot;aba&quot;
// 
//
// 示例 2: 
//
// 
//输入: S = &quot;aaab&quot;
//输出: &quot;&quot;
// 
//
// 注意: 
//
// 
// S 只包含小写字母并且长度在[1, 500]区间内。 
// 
// Related Topics 堆 贪心算法 排序 字符串 
// 👍 167 👎 0


package leetcode.editor.cn;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

public class ReorganizeString {
    public static void main(String[] args) {
        Solution solution = new ReorganizeString().new Solution();
        System.out.println(solution.reorganizeString(&quot;zqugrfbsznyiwbokwkpvpmeyvaosdkedbgjogzdpwawwl&quot;));
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public String reorganizeString(String S) {
            int sLength = S.length();
            if (sLength &lt; 2) {
                return S;
            }
            int[] bucket = new int[26];

            for (int i = 0; i &lt; sLength; i++) {
                int index = S.charAt(i) - &#x27;a&#x27;;
                bucket[index]++;
            }
            int maxIndex = 0;
            for (int i = 1; i &lt; 26; i++) {
                if (bucket[i] &gt; bucket[maxIndex]) {
                    maxIndex = i;
                }
            }
            if (bucket[maxIndex] &gt; (sLength + 1) / 2) {
                return &quot;&quot;;
            }
            char[] answer = new char[sLength];
            int i = 0;
            while (bucket[maxIndex] &gt; 0) {
                answer[i] = (char) (maxIndex + &#x27;a&#x27;);
                i += 2;
                bucket[maxIndex]--;
            }
            for (int j = 0; j &lt; 26; j++) {
                while(bucket[j] &gt; 0){
                    if(i &gt;= sLength){
                        i = 1;
                    }
                    answer[i] = (char) (j + &#x27;a&#x27;);
                    i += 2;
                    bucket[j]--;
                }
            }
            return String.valueOf(answer);
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的 第一个 Vue练手项目]]></title>
        <id>我的 第一个 Vue练手项目</id>
        <link href="https://mondaycha.github.io/blog/2020/11/01/我的-第一个-Vue练手项目"/>
        <updated>2020-11-01T03:56:57.000Z</updated>
        <summary type="html"><![CDATA[My first Vue project，为网易有道词典笔百日阅读打卡活动写的格式规范工具]]></summary>
        <content type="html"><![CDATA[<blockquote><p>My first Vue project，为网易有道词典笔百日阅读打卡活动写的格式规范工具</p></blockquote><h2>起因</h2><p>哎，参加了一个打卡活动，有个大佬本来写了个小程序，很方便，不过后来又是广告又是视频的，所以我自己试着写了一个。</p><h2>项目地址</h2><p><a href="https://github.com/MondayCha/Youdao-Dictionary-Pen-Assistant">https://github.com/MondayCha/Youdao-Dictionary-Pen-Assistant</a></p><p>がんばれ!</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 OO 第四单元总结]]></title>
        <id>2020 OO 第四单元总结</id>
        <link href="https://mondaycha.github.io/blog/2020/06/15/2020-OO-第四单元总结"/>
        <updated>2020-06-15T03:10:06.000Z</updated>
        <summary type="html"><![CDATA[针对第四单元和本学期所学的内容，在独立思考的前提下在博客园完成技术博客的撰写：]]></summary>
        <content type="html"><![CDATA[<p>针对<strong>第四单元和本学期所学的内容</strong>，在独立思考的前提下在博客园完成技术博客的撰写：</p><ul><li>（1）总结<strong>本单元</strong>三次作业的<strong>架构设计</strong></li><li>（2）总结自己在<strong>四个单元中架构设计</strong>及<strong>OO方法理解的演进</strong></li><li>（3）总结自己在<strong>四个单元中测试理解与实践的演进</strong></li><li>（4）总结自己的<strong>课程收获</strong></li><li>（5）立足于自己的体会给课程提<strong>三个具体改进建议</strong></li><li>（6）谈一谈线上学习oo课程的体会</li></ul><h2>1. 本单元三次作业的架构设计</h2><p>本单元的代码编写与第三单元有相似之处，课程组已经提供了相应的接口，我们只需要满足具体的实现。在架构设计上我选择了建立MyUmlClass等类，采用适配器模式以管理UML对象，并配置相应的方法的方式，更加符合面向对象的设计思维。</p><h3>1.1 第一次作业</h3><p>在第一次作业其实还没有考虑好迭代开发，在UML对象的存储方式上比较混乱，有的采用Arraylist、有的建立了从id到元素的映射map、有的建立了从name到元素的映射map，导致之后第三次作业处理异常输入时花了很多时间重构。做的还可以的是设置了类图单独的管理器，核心类直接调用管理器的相关方法，便于之后两次作业的迭代。</p><p>第一次作业没有遇到Bug，感动。</p><h3>1.2 第二次作业</h3><p>第二次作业增加了UML状态图和时序图，我分别建立了管理对应图像的管理器类，核心类调用管理器的相关方法。</p><p>第二次作业没有遇到Bug，很感动。</p><h3>1.3 第三次作业</h3><p>第三次作业增加了多种模型有效性检查，现在想来我对异常输入的处理还不到位，进行了很多重构。</p><p>第三次作业没有遇到Bug，感动到差点忍不住流泪。</p><p>第三次作业类图如下所示：</p><h2>2. 四个单元中架构设计及OO方法理解的演进</h2><h3>2.1 第一单元</h3><p>在第一单元，我通过预习对于Java的基本语法和继承关系有了一定的了解，不过每次写代码时并没有考虑到下一次的迭代，算是次次重构。第三次作业设计的结构有着比较好的扩展性，将因子和因子运算方式抽象为对象，实现了求导接口。如果之后还要增加新需求，对于每一种新函数只要在内部配置求导方法，对于每一种新的运算方式只需要在内部配置运算规则，层次化的表达式存储方式可以通过统一的接口进行因子类型的转换。</p><p><img src="https://img2020.cnblogs.com/blog/1930974/202003/1930974-20200320121107739-638875440.png" alt="img"/></p><p>在这一单元，我进一步实践了继承、接口等Java的特性，不过代码还是以面向过程为主。</p><h3>2.2 第二单元</h3><p>第二单元从第二次作业开始增加了多电梯和对多线程的考察。这一次一开始就希望能为后续的扩展留好迭代空间，电梯设计为有限状态机，三次作业都是采用生产者/消费者模式。其中“生产者”为输入线程，将读取到的请求放到“货架”上；“消费者”则是每个电梯线程，以一种类似观察者模式的方式追踪“货架”的变化。之所以说是类似，是因为我每次都是在电梯自身状态发生改变后获取当前的“货架”内容，而不是“货架”一有更新就通知电梯，我只有“货架”类的方法是上锁的，其他类调用时不需要考虑是否会引发线程不安全问题，写起来很方便。</p><p><img src="https://img2020.cnblogs.com/blog/1930974/202004/1930974-20200418110404792-247921281.png" alt="img"/></p><p>这一单元的面向对象意识有所提升，不同类协同合作，实现高速载人。</p><h3>2.3 第三单元</h3><p>第三单元我觉得在架构设计上课程组给的规格已经给了很多提示，自己也没有太多发挥空间。主要的难点是几个算法的实现。实验课倒是学习了垃圾回收机制，结合讨论区查看了HashMap相关的底层实现，在作业中则表现为进而选择为其设置初始容量。<img src="https://img2020.cnblogs.com/blog/1930974/202005/1930974-20200523193410957-125912094.png" alt="img"/></p><h3>2.4 第四单元</h3><p>建立MyUmlClass等类，采用适配器模式以管理UML对象，并配置相应的方法。</p><h2>3. 四个单元中测试理解与实践的演进</h2><p>第一单元是随机数据+讨论区数据对拍，第二单元多线程耗时长，所以用了Pb的多线程评测机；第三单元发生失误，在第二次作业漏测了一条指令，结果正好出错，强测爆炸，之后第三次就老老实实Junit单元测试了；第四次作业以手动构造样例为主。</p><p>那么当我们在测试的时候，我们在做什么？最简单来说就是考虑所有输入的结果，并且保证每种都会有正确的交互，结果。但是在实际过程中要完全覆盖所有的可能性显然是做不到的，所以说在测试的时候我们应该尽可能地取出典型样例，而这就是两种方法——随机生成数据或者手动构造针对性数据。</p><p>而对于互测来说，要同时检查7个人的错误，单单靠在控制台输入输出显然是低效的，因此也需要结合脚本统一测试。在四次作业我都是使用手动构造数据+评测机对拍测试的方式（嫖来的东西真香），我自己也学习了Python语法，写了对拍程序，接下来打算学习下某位大佬的可视化评测机是咋写的。</p><h2>4. 课程收获</h2><ol><li>一定一定要做好测试！写完代码不测试就像晚上开车不开灯</li><li>学习了Git的使用、Java/Python的基本语法、多线程、契约式编程、UML等知识</li><li>算法无论何时都非常关键，接下来可以继续加强这方面的练习</li></ol><h2>5. 改进建议</h2><ol><li>首先是关于实验课，和每次作业都会有非常快速且积极的反馈相比，实验课不公布成绩，只通过后一次课件的ppt展示整体的完成情况，让人不知道自己做的到底对不对，训练效果有所折扣。另外某几次实验课的难度确实有些大，虽然也让我对GC垃圾回收机制等有了一定了解，但那次找Bug真的是灾难……改进上我觉得可以降低实验课所占分数比（虽然我很希望被捞），增加讨论占比，每次结束后与作业一样公布结果。</li><li>然后是关于研讨课，看了我好几个同学的博客都在批评研讨课后期太水，我其实觉得R老师的研讨课还是安排得比较好的。其实我感觉按照当前研讨课报名方式，后期研讨课存在灌水现象是非常正常的。OO给我的感觉是一门下线很高,上限无穷无尽的课程，你永远不知道隔壁的大佬为了写评测机和优化算法都用了什么高深的技巧。然而大佬的数量是有极限的，按照两周一次每次3-4个人的频次，自然不可能所有人都拿出“干货”。这一点我觉得R老师后期研讨课会安排同学做作业总结就非常好，说的也是我们我觉得如果把这个当作每次研讨课的保留项目，让所有同学讨论不同架构和各自的优势，也比较方便大家优化自己的代码，避免大佬很快讲完无话可讲的情况。</li><li>最后关于作业，我觉得JML可以放在第一章（Pre之后），前两单元对JML工程体系的帮助可能并不大，短期内JML工具链应该还是不完备的，（当然不排除大佬暑假致力于为下一届带来船新的JML体验的可能），所以下一届应该也和我们的体验差不多，将JML可以放在第一章，可以一开始就给大家一个关于契约式编程的粗浅理解，更早地感受到规格化描述和迭代开发的重要性，在多项式和多线程电梯也能少吃一点苦头。</li></ol><h2>线上学习OO课程的体会</h2><p>与OS、航概等相比，我觉得本学期OO是收到疫情影响最小的一门课程，本身也没有考试（而是愉快的周周乐），期末受到的影响也不大。而且慕课可以随时回放，研讨课虽然有点冷清但线下也未必更好，所以线上学习OO我感觉很是很愉悦的一门课程。</p><p>记得在上OO这门课之前我还上X乎看了往届学长们对课程的评价，看到曾经的吐槽，看到X乎上学长关于OO课程改革的回答，这一学期我也亲身体验了OO，还是不知多少年一遇的线上特供版（笑哭），OO让我有了获得知识的充实感，一次次的训练作业也是循序渐进，助教也很认真负责。感谢orz</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[马原探讨：垄断产生消除了竞争？]]></title>
        <id>马原探讨：垄断产生消除了竞争？</id>
        <link href="https://mondaycha.github.io/blog/2020/06/03/马原探讨：垄断产生消除了竞争？"/>
        <updated>2020-06-03T22:37:06.000Z</updated>
        <summary type="html"><![CDATA[请判断正误并说明原因。]]></summary>
        <content type="html"><![CDATA[<p>请判断正误并说明原因。</p><p>1、作为自由竞争的对立面，垄断产生消除了竞争</p><p>2、垄断利润归根到底来源于垄断资本家制定的垄断价格。</p><p>1）错误。</p><p>竞争是商品经济固有的规律，商品经济产生和存在的决定性条件是生产资料私有制，而垄断没有改变生产资料私有制，因此无法消除竞争。现实世界也不可能出现垄断全部社会生产的组织，垄断组织内部、垄断组织之间等都会存在竞争。</p><p>2）错误。</p><p>垄断利润归根到底来源于无产阶级及其他劳动人民创造的剩余价值。垄断利润有以下四种来源：①通过加强对国内无产阶级和其他劳动人民的剥削获得的利润。②通过控制市场占有非垄断企业的利润。③通过加强对其他国家劳动人民的剥削和掠夺获取的国外利润。④利用所控制的国家机器，通过财政补贴、减免税收等再分配手段，把劳动人民创造的国民收入的一部分转化为高额垄断利润。因此，垄断利润归根到底来源于无产阶级及其他劳动人民创造的剩余价值。</p><p>在制定垄断价格时，垄断价格不可能完全脱离商品的价值，垄断组织也不可能任意提高或降低商品的价格，它的变化仍然在不同程度上受竞争和供求关系的制约，所以垄断价格并非垄断利润的根源。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《共产党宣言》带给我的两点疑惑]]></title>
        <id>《共产党宣言》带给我的两点疑惑</id>
        <link href="https://mondaycha.github.io/blog/2020/05/30/《共产党宣言》带给我的两点疑惑"/>
        <updated>2020-05-30T22:37:06.000Z</updated>
        <summary type="html"><![CDATA[在阅读《关于费尔巴哈的提纲》和《共产党宣言》时，关于费尔巴哈的提高是马克思的手稿内容，也比较晦涩，哲学书需，让人虽然难看的都买个字的意思却不清楚具体的内涵，而共产党宣言则申东贤相的是托。]]></summary>
        <content type="html"><![CDATA[<p>在阅读《关于费尔巴哈的提纲》和《共产党宣言》时，关于费尔巴哈的提高是马克思的手稿内容，也比较晦涩，哲学书需，让人虽然难看的都买个字的意思却不清楚具体的内涵，而共产党宣言则申东贤相的是托。</p><p>而阅读完《共产党宣言》，我最大的疑惑就是，为什么在一百多年后的今天，资本主义依然没有灭亡，</p><p>现实的社会主义国家在建设之初通常面临着要在短时间内完成社会改造的自我要求，往往导致传统社会主义建设模式忽视生产力实际水平和人的现实需求，认为只要在社会中消灭了不分什么样的私有制，建立起纯而又纯的公有制。</p><p>《共产党宣言》有一个楔子、四章正文、一句结语,因为不断再版和翻译成其它语言,增加了七个序言,这些序言也已成为其不可分割的一部分。宣言对资本主义进行了深刻的分析,揭示了资本主义的内在矛盾,论证了资本主义。</p><p>1833年，巴黎的德国流亡者成立了一个秘密组织———“人民同盟”，1834年改组为“流亡者同盟”，大约有几百名成员。1836年，“流亡者同盟”中较为激进的成员独立出来成立了“正义者同盟”，他们密谋建立</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab5 实验笔记]]></title>
        <id>操作系统 OS Lab5 实验笔记</id>
        <link href="https://mondaycha.github.io/blog/2020/05/24/操作系统-OS-Lab5-实验笔记"/>
        <updated>2020-05-24T23:16:36.000Z</updated>
        <summary type="html"><![CDATA[文件系统概述]]></summary>
        <content type="html"><![CDATA[<h1>OS Lab5 实验笔记</h1><h2>文件系统概述</h2><h3>Thinking 5.1</h3><p>查阅资料，了解 Linux/Unix 的 /proc 文件系统是什么？有什么作用？ Windows 操作系统又是如何实现这些功能的？proc 文件系统这样的设计有什么好处和可以改进的地方？</p><p>答：</p><p><strong>/proc 文件系统是什么？</strong></p><p>proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口，一般挂载在“/proc”目录，其中的大部分内容是只读的。</p><p><strong>有什么作用？</strong></p><p>proc文件系统提供了从用户空间通往内核空间的一个入口，通过读取其中的文件来动态地获得内核的状态。很多Linux系统命令，比如lsmod、ps，都是通过直接访问proc文件系统来获得数据。此外还可以通过修改某些文件的内容来改变内核参数。</p><p><strong>Windows如何实现这些功能？</strong></p><p>在windows平台下，微软为了保护操作系统的安全性和稳定性，把系统分为内核层和用户层，需要借助native API 和win32 API访问系统内核数据。</p><p><strong>/proc文件系统这样的设计有什么好处和可以改进的地方？</strong></p><ul><li>好处：可以将对虚拟文件的读写作为与内核中实体进行通信</li><li>改进：sysfs比/proc有着更好的组织；对文件的修改在重启后会失效</li></ul><p>在本次实验中，我们将要实现一个简单但结构完整的文件系统。整个文件系统包括以下几个部分：</p><ol><li><strong>外部储存设备驱动</strong> 通常，外部设备的操作需要通过按照一定操作序列读写特定的寄存器来实现。为了将这种操作转化为具有通用、明确语义的接口，我们必须实现相应的驱动程序。在本部分，我们实现了IDE磁盘的用户态驱动程序。</li><li><strong>文件系统结构</strong> 在本部分，我们实现磁盘上和操作系统中的文件系统结构，并通过驱动程序实现文件系统操作相关函数。</li><li><strong>文件系统的用户接口</strong> 在本部分，我们提供接口和机制使得用户程序能够使用文件系统，这主要通过一个用户态的文件系统服务来实现。同时，我们引入了文件描述符等结构使操作系统和用户程序可以抽象地操作文件而忽略其实际的物理表示。</li></ol><p>接下来我们一一详细解读这些部分的实现。</p><h2>IDE磁盘驱动</h2><h3>Thinking 5.2</h3><p>如果我们通过 kseg0 读写设备，我们对于设备的写入会缓存到 Cache 中。通过 kseg0 访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如 我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。</p><p>答：</p><p>如果通过kseg0 访问设备，在写入时会缓存到Cache中，当数据块要被替换时才写回到空间中。</p><ul><li>对于如Console的串口设备，进行通信时是实时的，而借助Cache数据何时被写入外设并不确定，因此无法预测通信的结果</li><li>对于IDE磁盘等，访问磁盘与访问内存的机制相似，可以使用Cache机制提高访问速度。</li></ul><h3>Exercise5.1</h3><p>请根据lib/syscall_all.c中的说明，完成sys_write_dev函数和sys_read_dev 函数，并且在 user/lib.h,user/syscall_lib.c 中完成用户态的相应系统调用的接口。</p><p>编写这两个系统调用时需要注意物理地址、用户进程虚拟地址同内核虚拟地址 之间的转换。 同时还要检查物理地址的有效性，在实验中允许访问的地址范围为: console: [0x10000000, 0x10000020), disk: [0x13000000, 0x13004200), rtc: [0x15000000, 0x15000200)，当出现越界时，应返回指定的错误码。</p><h3>Exercise 5.2</h3><p>参考内核态驱动，完成 fs/ide.c 中的 ide_write 函数，以及 ide_read 函数，实现对磁盘的读写操作。</p><h3>Text Input with Hints and Feedback</h3><p>详细阅读实验指导书, 回答以下问题：往磁盘写入数据, 写入内存的首地址为:</p><p>答：</p><blockquote><p>Gxemul 提供的Simulated IDE disk 的地址是0x13000000。</p><p>注意，所有的地址操作都需要将物理地址转换成虚拟地址。此处设备基地址对应的kseg1 的内核虚拟地址是0xB3000000。</p></blockquote><p>0x13000000加上0xA0000000，答案就是0xB3000000。</p><h2>文件系统结构</h2><h3>Exercise 5.3</h3><p>文件系统需要负责维护磁盘块的申请和释放，在回收一个磁盘块时，需 要更改位图中的标志位。如果要将一个磁盘块设置为 free，只需要将位图中对应的 位的值设置为 1 即可。请完成 fs/fs.c 中的 free_block 函数，实现这一功能。同时 思考为什么参数 blockno 的值不能为 0 ？</p><h3>Thinking 5.3</h3><p>一个磁盘块最多存储 1024 个指向其他磁盘块的指针，试计算，我们 的文件系统支持的单个文件的最大大小为多大？</p><p>答：</p><p>每个磁盘块的大小为4KB，一个磁盘块最多存储 1024 个指向其他磁盘块的指针，因此单个文件的最大大小为：
$$
1024×4KB=4MB
$$</p><h3>Thinking 5.4</h3><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？</p><p>答：</p><p>一个磁盘块中最多能存储FILE2BLK个文件控制块，即16个文件控制块。
$$
FILE2BLK = \frac{BY2BLK}{BY2FILE}=16
$$</p><h3>Exercise 5.4</h3><p>请参照文件系统的设计，完成 fsformat.c 中的 create_file函数，并按 照个人兴趣完成 write_directory 函数（不作为考察点），实现将一个文件或指定 目录下的文件按照目录结构写入到 fs/fs.img 的根目录下的功能。关于如何创建二 进制文件的镜像，请参考 fs/Makefile。 在实现的过程中，你可以将你的实现同我们给出的参考可执行文件tools/fsformat 进行对比。具体来讲，你可以通过 Linux 提供的 xxd 命令将两个 fsformat 产生的二 进制镜像转化为可阅读的文本文件，手工进行查看或使用 diff 等工具进行对比。</p><h3>Thinking 5.5</h3><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p><p>答：</p><pre><code class="language-c">/* Maximum disk size we can handle (1GB) */
#define DISKMAX     0x40000000
</code></pre><p>我们实验使用的内核支持的最大磁盘大小是DISKMAX，大小为1G。</p><h3>Thinking 5.6</h3><p>如果将 DISKMAX 改成 0xC0000000, 超过用户空间，我们的文件系统还能正常工作吗？为什么？</p><p>答：</p><p>不能。我们的文件系统将DISKMAP到DISKMAP+DISKMAX 这一段虚存地址空间作为缓冲区，如果DISKMAX 改成 0xC0000000，那么缓冲区就包括了内核空间。用户态进程若是直接读写内核虚拟地址将会由处理器引发一个地址错误，因此不能正常工作。</p><h3>Exercise 5.5</h3><p>fs/fs.c 中的 diskaddr 函数用来计算指定磁盘块对应的虚存地址。完成 diskaddr 函数，根据一个块的序号 (block number)，计算这一磁盘块对应的 512 bytes 虚存的起始地址。（提示：fs/fs.h 中的宏 DISKMAP 和 DISKMAX 定义了磁盘映射虚存的地址空间）。</p><h3>Exercise 5.6</h3><p>实现 map_block 函数，检查指定的磁盘块是否已经映射到内存，如果没有，分配一页内存来保存磁盘上的数据。对应地，完成 unmap_block 函数，用于解除磁盘块和物理内存之间的映射关系，回收内存。（提示：注意磁盘虚拟内存地址 空间和磁盘块之间的对应关系）。</p><h3>Exercise 5.7</h3><p>补全 dir_lookup 函数，查找某个目录下是否存在指定的文件。（提示： 使用file_get_block可以将某个指定文件指向的磁盘块读入内存）。</p><h3>Thinking 5.7</h3><p>阅读 user/file.c ，你会发现很多函数中都会将一个 struct Fd <em> 型的 指针转换为 struct Filefd </em> 型的指针，请解释为什么这样的转换可行。</p><p>答：</p><p>在user/fd.h中可以找到Fd和Filefd的定义：</p><pre><code class="language-c">// file descriptor
struct Fd {
    u_int fd_dev_id;
    u_int fd_offset;
    u_int fd_omode;
};

// file descriptor + file
struct Filefd {
    struct Fd f_fd;
    u_int f_fileid;
    struct File f_file;
};
</code></pre><p>可以看到Filefd结构体的第一个成员就是Fd结构体，从指针角度， struct Fd <em> 型的指针与struct Filefd </em> 型的指针所指向的数据的起始部分是相同的，转换后可以增加Filefd中的新属性。</p><h3>Thinking 5.8</h3><p>请解释 Fd, Filefd, Open 结构体及其各个域的作用。比如各个结构体 会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系 与设计框架。</p><p>答：</p><p>Fd结构体：</p><pre><code class="language-c">// file descriptor
struct Fd {
    u_int fd_dev_id;    // 设备id：用于校验等操作
    u_int fd_offset;    // 文件指针偏移：在write/read时标记当前读写位置
    u_int fd_omode;     // 文件权限：在进行文件的write操作时需要校验是否可写
                        // 低两位00表示只读，01表示只写，10表示读写均可
};
</code></pre><p>Filefd结构体：</p><pre><code class="language-c">// file descriptor + file
struct Filefd {
    struct Fd f_fd;     // 文件描述符：同上
    u_int f_fileid;     // 文件id：用于fsipc_close等根据id修改文件的操作
    struct File f_file; // 文件控制块：对应磁盘上的物理实体
};
</code></pre><p>Open结构体：</p><pre><code class="language-c">struct Open {
    struct File *o_file; // 映射文件控制块的指针：对应磁盘上的物理实体
    u_int o_fileid;      // 文件id：同上
    int o_mode;          // 文件读写权限：同上
    struct Filefd *o_ff; // 文件描述符：同上
};
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 OO JML语言理论基础与工具链总结]]></title>
        <id>2020 OO JML语言理论基础与工具链总结</id>
        <link href="https://mondaycha.github.io/blog/2020/05/21/2020-OO-JML语言理论基础与工具链总结"/>
        <updated>2020-05-21T18:10:06.000Z</updated>
        <summary type="html"><![CDATA[第三单元终于结束了，这是我目前为止最惨的一单元，第十次作业强测20分，互测杀成狗……虽然都知道只关注分数没有什么意义，我更应该去体会的是通过JML学习对于程序设计理念的认知，但是……心真的很痛。]]></summary>
        <content type="html"><![CDATA[<p>第三单元终于结束了，这是我目前为止最惨的一单元，第十次作业强测20分，互测杀成狗……虽然都知道只关注分数没有什么意义，我更应该去体会的是通过JML学习对于程序设计理念的认知，但是……心真的很痛。</p><p>下面就进入单元总结：</p><h2>1. JML语言理论基础与工具链</h2><h3>1.1 JML语言是什么</h3><p>参考课程组下发的《JML(Level 0)使用手册》，JML语言的定义如下：</p><blockquote><p>JML(Java Modeling Language)是用于对Java程序进行规格化设计的一种表示语言。JML是一种行为接口规格语言（Behavior Interface Specification Language，BISL），基于Larch方法构建。</p></blockquote><p>也就是说，JML是一种对代码语言的抽象——不同的语言有着不同的语法，而JML通过自己的规则对代码进行了形式化的表述，一旦规格确定，除非涉及复杂的算法要求，实现代码就变成了一个相对简单的事情。</p><h3>1.2 JML语言基本语法</h3><p>JML的核心在于用表达式对规格进行描述，首先从常见的表达式说起，给人的感觉类似离散数学：</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>\result</td><td>方法的返回值（非void类型）</td></tr><tr><td>\old(expr)</td><td>表达式expr在方法执行前的取值</td></tr><tr><td>\not_assigned(x, y, ...)</td><td>括号中的变量是否在方法执行过程中未被赋值</td></tr><tr><td>\not_modified(x, y, ...)</td><td>限制括号中的变量在方法执行期间的取值未发生变化</td></tr><tr><td>\forall</td><td>全称量词</td></tr><tr><td>\exists</td><td>存在量词</td></tr><tr><td>\sum</td><td>返回给定范围内的表达式的和</td></tr><tr><td>\product</td><td>返回给定范围内的表达式的连乘结果</td></tr><tr><td>\max</td><td>返回给定范围内的表达式的最大值</td></tr><tr><td>\min</td><td>返回给定范围内的表达式的最小值</td></tr><tr><td>\num_of</td><td>返回指定变量中满足相应条件的取值个数</td></tr><tr><td>&lt;:</td><td>子类型关系操作符</td></tr><tr><td>&lt;==&gt;</td><td>等价关系操作符</td></tr><tr><td>==&gt;</td><td>推理操作符</td></tr><tr><td>\everything</td><td>全集</td></tr><tr><td>\nothing</td><td>空集</td></tr></tbody></table><p>表达式中容易错的地方在于\old(<code>expr</code>)表达式，作为一般规则，任何情况下，都应该使用\old把关心的表达式取值整体括起来。</p><table><thead><tr><th>方法规格</th><th>含义</th></tr></thead><tbody><tr><td>requires</td><td>表达的意思是“要求调用者确保P为真”</td></tr><tr><td>ensures</td><td>表达的意思是“方法实现者确保方法执行返回结果一定满足谓词P的要求，即确保P为真”</td></tr><tr><td>assignable/modifiable</td><td>副作用范围限定，副作用指方法在执行过程中会修改对象的属性数据或者类的静态成员数据，从而给后续方法的执行带来影响。<code>assignble</code>表示可赋值，而<code>modifiable</code>则表示可修改</td></tr><tr><td>pure</td><td>纯粹访问性的方法，不会对对象的状态进行任何改变，也不需要提供输入参数</td></tr><tr><td>public normal_behavior</td><td>正常功能，一般指输入或方法关联this对象的状态在正常范围内时所指向的功能。</td></tr><tr><td>public exceptional_behavior</td><td>与正常功能相对</td></tr><tr><td>signals</td><td>结构为<code>signals (***Exception e) b_expr;</code>，意思是当<code>b_expr</code>为<code>true</code>时，方法会抛出括号中给出的相应异常<code>e</code></td></tr></tbody></table><p>最后是类型规格，指针对类或接口所设计的约束规则。</p><table><thead><tr><th>类型规格</th><th>含义</th></tr></thead><tbody><tr><td>invariant</td><td>不变式，只针对可见状态(即当下可见状态)的取值进行约束</td></tr><tr><td>constraint</td><td>状态变化约束，对前序可见状态和当前可见状态的关系进行约束</td></tr></tbody></table><h3>1.3 应用工具链情况</h3><p>在网络上查找JML工具链，搜索到的大多是OO博客的内容。工具主要包括OpenJML、JMLUnitNG等。</p><ul><li>OpenJML: <a href="http://www.openjml.org/">http://www.openjml.org/</a></li><li>JMLUnitNG: <a href="http://insttech.secretninjaformalmethods.org/software/jmlunitng/">http://insttech.secretninjaformalmethods.org/software/jmlunitng/</a></li></ul><p>在编写三次作业时，我用的java版本是JDK13，无法使用相关工具链，于是也在作业中并没有使用；撰写本次博客时重新安装了JRE1.8，具体使用在下面的部分描述。</p><h2>2. SMT Solver验证</h2><p>参考了J哥的教程（<a href="https://www.cnblogs.com/pekopekopeko/p/12920417.html#4581709%EF%BC%89%EF%BC%8C%E8%BF%9B%E8%A1%8COpenJML%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6SMT">https://www.cnblogs.com/pekopekopeko/p/12920417.html#4581709），进行OpenJML的基础组件SMT</a> Solver验证，文件树如下：</p><pre><code>PS G:\STUDY\BUAA-2020-OO\Week12&gt; tree /F
卷 办公 的文件夹 PATH 列表
卷序列号为 AA85-2D30
G:.
│  Group.java
│  Person.java
│
└─openjml-0.8.44-20200413
    │  epl-v10.html
    │  jml-reference-manual.pdf
    │  jmlruntime.jar
    │  jmlspecs.jar
    │  LICENSE.rtf
    │  openjml-template.properties
    │  openjml.jar
    │  OpenJMLUserGuide.pdf
    │  VERSION_INFO
    │
    ├─Solvers-linux
    │      cvc4-1.6
    │      z3-4.3.0
    │      z3-4.3.1
    │      z3-4.7.1
    │
    ├─Solvers-macos
    │      cvc4-1.6
    │      z3-4.3.1
    │      z3-4.5.0
    │      z3-4.6.0
    │      z3-4.7.1
    │
    └─Solvers-windows
            cvc4-1.6.exe
            z3-4.3.2.exe
            z3-4.7.1.exe
</code></pre><p>先运行静态验证指令：<code>java -jar .\openjml.jar -exec .\Solvers-windows\z3-4.7.1.exe -esc ..\Group.java</code>，得到初步结果：</p><pre><code>public class Person {
       ^
..\Group.java:34: 警告: A non-pure method is being called where it is not permitted: Person.isLinked(Person)
      @          (\sum int j; 0 &lt;= j &amp;&amp; j &lt; people.length &amp;&amp; people[i].isLinked(people[j]); 1));
                                                                               ^
..\Group.java:40: 警告: A non-pure method is being called where it is not permitted: Person.isLinked(Person)
      @           people[i].isLinked(people[j]); people[i].queryValue(people[j])));
                                    ^
..\Group.java:40: 警告: A non-pure method is being called where it is not permitted: Person.queryValue(Person)
..\Group.java:47: 警告: A non-pure method is being called where it is not permitted: Person.getCharacter()
      @          temp.length == people.length &amp;&amp; temp[0] == people[0].getCharacter();
                                                                                  ^
..\Group.java:49: 警告: A non-pure method is being called where it is not permitted: Person.getCharacter()
      @            temp[i] == temp[i-1].xor(people[i].getCharacter())) &amp;&amp;
                                                                  ^
..\Group.java:59: 警告: A non-pure method is being called where it is not permitted: Person.getAge()
                                                                            ^
..\Group.java:58: 错误: 不可比较的类型: int和INT#1
    /*@ ensures \result == (people.length == 0? 0 :
                        ^
  其中, INT#1是交叉类型:
    INT#1扩展Number,Comparable
      @          (people[i].getAge() - getAgeMean()) * (people[i].getAge() - getAgeMean())) /
                                  ^
..\Group.java:64: 警告: A non-pure method is being called where it is not permitted: Person.getAge()
      @          (people[i].getAge() - getAgeMean()) * (people[i].getAge() - getAgeMean())) /
                                                                        ^
..\Group.java:63: 错误: 不可比较的类型: int和INT#1
                        ^
  其中, INT#1是交叉类型:
    INT#1扩展Number,Comparable
3 个错误
8 个警告
</code></pre><p>报错和警告主要有两种，在不允许的地方调用非纯方法，以及不可比较的类型（貌似是不能识别三目运算符？），动态验证的信息就更多了。</p><p>总之我感觉看着结果云里雾里的，SMT Solver目前好像也无法对exist等进行验证，不过作者一直在更新，相信下一届的同学们可以享受到更加舒适的SMT Solver的！</p><h2>3. JMLUnitNG/JMLUnit自动生成测试用例</h2><p>辛辛苦苦以10KB/S的速度下载下来，一运行傻了——</p><p>到百度求助，表示版本太低，然而我已经下载了官网最新的1.8版本……另外发现这中间似乎插了句人话：<code>错误: 非法的类型开始 value = new ArrayList&lt;&gt;();</code>，感情必须要写成<code>value = new ArrayList&lt;Integer&gt;();</code>的形式？这也太OUT了吧……</p><p>之后又出现了群里提到的神秘的++，触发了<code>JmlInternalError</code>,更加迷惑了。</p><pre><code>org.jmlspecs.openjml.JmlInternalError: The operation symbol ++ for type java.lang.Object could not be resolved
</code></pre><h4>简要分析</h4><p>最后我折腾了很久还是不行……运行完什么结果也没有……我也很疑惑为什么运行SMT Solver时就相对顺风顺水但JMLUnitNG怎么整都不行（对帮我找问题的PB同学深表歉意）。因为我的电脑不能生成，所以就看了很多同学的博客，这里借用@VOIDMalkuth的测试结果：</p><p>从同学们的结果来看，JMLUnitNG自动生成的样例可以检测到一定的错误，对于INT数据测试了极端情况等与实际应用不符合的数据输入，要成为真正有用的工具，还有很长的路要走……</p><h2>4. 架构设计梳理与模型构建策略分析</h2><h3>4.1 第九次作业</h3><p>UML类图如下：</p><p>本次作业只要对着规格就能完成大部分任务，架构上使用的MyPerson、MyNetwork均继承课程组所给的接口。</p><p>需要考虑算法实现的是isCircle，我采用了BFS广度优先搜索，从每个Person内调出邻接表搜索，复杂度为O(N+E)。</p><h3>4.2 第十次作业</h3><p>UML类图如下：</p><p>第十次作业与第九次作业相比新增了Group，在MyNetwork中调用MyGroup。我直到周四才开始动笔，此时同学们已经把雷区排得差不多了……于是在Group的方法上我采用了缓存法的形式。需要特别注意的是缓存法在addRelation时也要更新缓存，我采用的方式为为Group增加更新的检索方法：</p><pre><code class="language-java">    public void addRelation(int id1, int id2, int value) {
        if (people.containsKey(id1) &amp;&amp; people.containsKey(id2)) {
            relationSum += 2;
            valueSum += (2 * value);
        }
    }
</code></pre><p>而在计算方差时，则出现了过度化简导致误差的问题，同样需要注意。</p><p>另外需要注意的是初始化问题，HashMap默认容量为16，当当前的size超过容量×常数时就会进行扩容，而扩容操作需要耗费的时间较多，因此我直接将关系表初始化为8192容量。</p><h3>4.3 第十一次作业</h3><p>UML类图如下：</p><p>第十一次作业对算法的考察增加了：</p><ul><li>在queryBlockSum我采用了并查集，进而isCircle的复杂度降至O(1)；</li><li>queryMinPath则采用了堆优化的Dijkstra，没有手写堆，而是采用自带的PriorityQueue进行维护；</li><li>queryStrongLink原本在想要不要学tarjan，但发现助教给的标程复杂度很宽容，所以就用了两步BFS，特判第一次BFS找到的为直连路径的情况，我写了一个忽略某点的BFS函数：</li></ul><pre><code class="language-java">private boolean searchIgnore(int id1, int id2, int ignore) {
    if (id1 == ignore || id2 == ignore || id1 == id2) {
        // err(&quot;meet id1 == ignore || id2 == ignore || id1 == id2&quot;);
        return false;
    }
    HashSet&lt;Integer&gt; visited = new HashSet&lt;&gt;(1024);
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    queue.add(id1);
    while (!queue.isEmpty()) {
        int currentId = queue.poll();
        if (visited.contains(currentId)) {
            continue;
        }
        ArrayList&lt;Integer&gt; points = ((MyPerson) getPerson(currentId)).getAcquaintance();
        for (Integer i : points) {
            if (i == id2) {
                // err(&quot;Succeed! searchIgnore&quot;);
                return true;
            } else if (!visited.contains(i) &amp;&amp; i != ignore) {
                queue.offer(i);
                // err(&quot;queue update to &quot; + queue);
            }
        }
        visited.add(currentId);
        // err(&quot;point &quot; + currentId + &quot; has been searched&quot;);
    }
    return false;
}
</code></pre><p>如果第一次找到的路径长度为2，那么就遍历起点的邻接表，找到一条不经过起点就能到终点的路径就返回成功；否则依次忽略第一次路径中的点，如果每次都能找到路径就返回成功。最后在研讨课也学了tarjan，在求割点的过程中求出所有双连通分量，进而判断点双。</p><p>这样的结构导致MyNetwork非常臃肿，我因此将并查集、堆优化的Dijkstra单独抽象为一个类。</p><h2>5. 代码bug和修复情况</h2><p>第九次、第十一次作业均未出现Bug。</p><h3>第十次作业</h3><p>第九次作业整体相对简单，也就让我放松了警惕，在第十次作业时，我最后改了一行代码，却忘了测试：</p><pre><code class="language-java">return (HashSet&lt;Integer&gt;) acquaintance.keySet();
</code></pre><p>就是这行代码，让我直接RE了大部分测试点……在编写时想当然地以为HashMap的KeySet可以用强制类型转换为HashSet，之后又没有做哪怕一次对isCircle的测试，于是强测直接爆炸……在互测屋里，看到了没有除零直接RE的同学；看到了缓存更新不及时的同学，看到了好多Bug一起犯的同学……是一次难忘的体验。</p><p><img src="https://pic.downk.cc/item/5ec73f83c2a9a83be528b8bc.png"/></p><h3>第十一次作业</h3><p>在第十一次作业，吸取了第十次作业的惨痛教训，用Junit对新加入的函数进行单元测试，优化算法，没有出现Bug。</p><h2>对规格的心得体会</h2><p>JML作为一种统一的规格化语言，在对代码进行了形式化的表述的同时，也给机器理解程序提供了一种可能性。</p><p>虽然从目前来看，JML相关的工具或是陈旧不堪，或是Bug满天飞，而撰写规格甚至比写程序还要复杂得多，比如对于一些Contains方法，JML的表述虽然严谨，但为人的阅读与理解提供了更大的负担。</p><p>而在未来的工作中，不单要知道如何写好程序，也需要写出好的文档，我想本单元的学习就是一次预习，虽然中间由于我的懈怠造成了大翻车，但这一单元只要认真阅读代码并不难。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[对马克思《哲学的贫困》的理解]]></title>
        <id>对马克思《哲学的贫困》的理解</id>
        <link href="https://mondaycha.github.io/blog/2020/05/20/对马克思《哲学的贫困》的理解"/>
        <updated>2020-05-20T22:37:06.000Z</updated>
        <summary type="html"><![CDATA[马克思在《哲学的贫困》中讲到：“每个历史阶段和历史事变中的主要人物，既是历史剧的‘剧作者’，又是历史剧的‘剧中人’”。结合本讲内容，谈谈你对这句话的理解。]]></summary>
        <content type="html"><![CDATA[<h1>第十三周作业</h1><p>马克思在《哲学的贫困》中讲到：“每个历史阶段和历史事变中的主要人物，既是历史剧的‘剧作者’，又是历史剧的‘剧中人’”。结合本讲内容，谈谈你对这句话的理解。</p><p>答：</p><p>看到这句话，我最先想到的是在之前的课程与这次课程都曾提到的英雄史观：主观唯心主义历史观把英雄人物的意志和力量看作历史的决定力量。按照这种观点，英雄人物们或许正是“剧作者”。</p><p>而在马克思的眼中，“剧作者”与“剧中人”的隐喻争揭示了每个历史阶段和历史事变中的主要人物与历史的关系。一方面，主要人物们凭借着自己的意志从事活动，进而影响历史的发展进程，是历史的作者；另一方面，如恩格斯所持有的“历史事件似乎总的说来同样是由偶然性支配着的。但这种偶然性始终是受内部的隐蔽的规律支配着”的观点，不管什么样的人物，也会受到社会发展客观规律的制约，也就是“剧中人”。</p><p>这也证明了主观唯心主义历史观的错误：即使没有张三的揭竿而起，也会有李四的奋勇抗争。由此可见，时势造英雄，每个历史阶段和历史事变中的主要人物，正是必然性与偶然性的统一。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab4 实验报告]]></title>
        <id>操作系统 OS Lab4 实验报告</id>
        <link href="https://mondaycha.github.io/blog/2020/05/11/操作系统-OS-Lab4-实验报告"/>
        <updated>2020-05-11T00:43:36.000Z</updated>
        <summary type="html"><![CDATA[一、实验思考题]]></summary>
        <content type="html"><![CDATA[<h1>OS Lab4 实验报告</h1><h2>一、实验思考题</h2><h3>Thinking 4.1</h3><p>思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>系统陷入内核调用后可以直接从当时的$a0-$a3 参数寄存器中得到用户调用msyscall 留下的信息吗？</li><li>我们是怎么做到让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数的？</li><li>内核处理系统调用的过程对Trapframe 做了哪些更改？这种修改对应的用户态的变化是？</li></ul><p>答：</p><p>1）内核会通过宏SAVE_ALL以与struct Trapframe等同的结构将运行现场保存到内核空间中，Trapframe包括32个通用寄存器、部分CP0寄存器、HI/LO乘除法寄存器和PC指令计数器的值。</p><p>2）不可以，系统陷入内核调用后可能会破坏$a0-$a3 参数寄存器的值（虽然本次实验好像没有破坏）</p><p>3）在MIPS 的调用规范中，如果函数参数个数≤4，则将参数依次存入a0-a3寄存器中，并在栈帧底部保留16字节的空间（即sp的值减去16），但并不一定使用这些空间。如果函数参数个数&gt;4，则前4个参数依次存入a0-a3寄存器中，从第5个参数开始，依次在前4个参数预留空间之外的空间内存储，即没有寄存器去保存这些值。在handle_sys中，我们从sp中取出a0-a3的值，从用户态栈指针取出其他参数，让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数。</p><p>4）将Trapframe中EPC的值+4后存回，当程序返回用户态时从导致陷入内核态的下一条指令开始执行；将系统调用的返回值存入v0寄存器中，由用户态函数调用。</p><h3>Thinking 4.2</h3><p>思考下面的问题，并对这两个问题谈谈你的理解：</p><ol><li>子进程完全按照fork() 之后父进程的代码执行，说明了什么？</li><li>但是子进程却没有执行fork() 之前父进程的代码，又说明了什么？</li></ol><p>答：</p><p>1）说明子进程和父进程有相同的代码段。</p><p>2）说明fork()后子进程的PC值与父进程执行fork()后的PC值相同。</p><h3>Thinking 4.3</h3><p>关于fork 函数的两个返回值，下面说法正确的是（C）</p><p>​	A. fork 在父进程中被调用两次，产生两个返回值</p><p>​	B. fork 在两个进程中分别被调用一次，产生两个不同的返回值</p><p>​	C. fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</p><p>​	D. fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p><h3>Thinking 4.4</h3><p>如果仔细阅读上述这一段话, 你应该可以发现, 我们并不是对所有的用户空间页都使用duppage 进行了保护。那么究竟哪些用户空间页可以保护，哪些不可以呢，请结合include/mmu.h 里的内存布局图谈谈你的看法。</p><p>答：</p><pre><code class="language-c"> /*
 o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |
 o  UXSTACKTOP -/       |     user exception stack   |     BY2PG                 |
 o                      +----------------------------+------------0x7f3f f000    |
 o                      |       Invalid memory       |     BY2PG                 |
 o      USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    |
 o                      |     normal user stack      |     BY2PG                 |
 o                      +----------------------------+------------0x7f3f d000    |
 */
</code></pre><p>在[0,UTOP)的用户空间中，[USTACKTOP,USTACKTOP+BY2PG)是无效内存，子进程缺页中断时作为临时空间，不需要保护；[USTACKTOP+BY2PG,UXSTACKTOP)是错误栈，不需要保护，否则父子进程错误栈相同，会陷入死循环中。</p><p>另外在duppage函数内部，对不同权限的页有着不同的处理方式。对于只读、共享、写时复制保持其原有的权限即可，对于可写页面则需要对父子进程的页表项加上PTE_COW 标记。</p><h3>Thinking 4.5</h3><p>在遍历地址空间存取页表项时你需要使用到vpd 和vpt 这两个“指针的指针”，请思考并回答这几个问题：</p><ul><li>vpt 和vpd 的作用是什么？怎样使用它们？</li><li>从实现的角度谈一下为什么能够通过这种方式来存取进程自身页表？</li><li>它们是如何体现自映射设计的？</li><li>进程能够通过这种存取的方式来修改自己的页表项吗？</li></ul><p>答：</p><p>1）在user/entry.S中可以看到定义：</p><pre><code class="language-c">    .globl vpt
vpt:
    .word UVPT

    .globl vpd
vpd:
    .word (UVPT+(UVPT&gt;&gt;12)*4)
</code></pre><p>因此<code>*vpt</code>是指向用户页表的指针，而根据页表的自映射机制，<code>*vpd</code>是指向用户页目录的指针。</p><p>使用方式：可以将其作为数组使用，获得虚拟地址va对应的页表项和页目录项。</p><pre><code class="language-c">(*vpt)[va &gt;&gt; PGSHIFT]       // 获得对应的页表项
(*vpd)[va &gt;&gt; PDSHIFT]       // 获得对应的页目录项
</code></pre><p>2）在fork函数中，我们需要检查页表项是否有效，进而进行duppage的操作。通过vpt 和vpd访问的方式，为用户态提供了访问页表的途径。</p><p>3）vpd的地址为(UVPT+(UVPT&gt;&gt;12)*4)，是页表项，也是页目录项，体现了自映射设计。</p><p>4）不能，这里只能通过这种方式读取页表信息，进而判断是否有效，不可以修改页表。</p><h3>Thinking 4.6</h3><p>page_fault_handler 函数中，你可能注意到了一个向异常处理栈复制Trapframe 运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？</li><li>内核为什么需要将异常的现场Trapframe 复制到用户空间？</li></ul><p>答：</p><p>1）在处理缺页中断时接受了时钟中断，就会出现这种“中断重入”。</p><p>2）将异常的现场Trapframe 复制到用户空间，之后可以在用户态的pgfault函数进行缺页处理，恢复事先保存好的现场与sp寄存器的值，使得子进程恢复执行。</p><h3>Thinking 4.7</h3><p>到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：</p><ul><li>用户处理相比于在内核处理写时复制的缺页中断有什么优势？</li><li>从通用寄存器的用途角度讨论用户空间下进行现场的恢复是如何做到不破坏通用寄存器的？</li></ul><p>答：</p><p>1）减少了陷入内核态后的工作量，体现了微内核的思想，将通常与内核集成在一起的系统服务层被分离出来，变成可以根据需求加入的选件，提供更好的可扩展性和更加有效的应用环境。</p><p>2）恢复现场时，栈指针是由内核设置的在异常处理栈的栈指针，而且指向一个由内核复制好的Trapframe 结构体的底部，从栈中取出除了sp以外的通用寄存器的值，最后利用了MIPS 的延时槽特性跳转的同时恢复了栈指针。</p><h3>Thinking 4.8</h3><p>请思考并回答以下几个问题：</p><ul><li>为什么需要将set_pgfault_handler 的调用放置在syscall_env_alloc 之前？</li><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li><li>子进程需不需要对在entry.S 定义的字__pgfault_handler 赋值？</li></ul><p>答：</p><p>1）在syscall_env_alloc时会产生缺页中断，需要先设置好处理函数。</p><p>2）写时复制保护设置中syscall_mem_map也要用到缺页中断，会导致duppage无法正常执行。</p><p>3）不需要，父进程设置的set_pgfault_handler改变的__pgfault_handler与子进程共享。</p><h2>二、实验难点图示</h2><p>在这次实验，需要实现系统调用机制，并在此基础上实现进程间通信（IPC）机制和一个重要的系统调用fork。</p><p>首先的难点在于MIPS传参机制（在Extra，我由于没有深入理解这一点而吃了很大的苦头），而fork函数同样是一大难点，在什么时候要为父子进程设置什么、返回什么，课程组很贴心的给了一张流程图：</p><p><img src="http://cscore.net.cn/assets/courseware/v1/ec04bb966e3083678fe5dcabe84273ee/asset-v1:Internal+B3I062140+2019_T2+type@asset+block/4_fork_process.png"/></p><p>而我自己的难点树如下：</p><p>![](G:\OneDrive\OneDrive - buaa.edu.cn\MWD\学习\操作系统\作业\Refer\Lab4 个人难点.png)</p><h2>三、体会与感想</h2><p><strong>Lab4难度评价：</strong>★★★★☆</p><p><strong>Lab4-extra难度评价：</strong>★★★★★</p><p><strong>花费时间：</strong>Lab4 10h，Lab4-extra 10h</p><p><strong>体会和感想：</strong></p><p>Lab4-extra基础也太难了……好久没有写汇编，我de了五个小时的Bug，听同学说这是去年的Exam-1，我感觉是不是应该庆幸今年是网课……</p><p>在这过程中，我发现一些之前实现过的函数还存在着一些Bug，之后可以的话希望重新过一遍之前的Lab，顺便打上中文注释……</p><p>最后感谢好多学长的博客（是的我就是灌水群里分享了一堆博客的那位），在一步步理解的时候，指导书和注释还是比较抽象的，感谢学长们的博客（不过大家想的都不一样hhh）</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week10]]></title>
        <id>《航空航天概论》Week10</id>
        <link href="https://mondaycha.github.io/blog/2020/05/08/《航空航天概论》Week10"/>
        <updated>2020-05-08T23:48:43.000Z</updated>
        <summary type="html"><![CDATA[学堂在线 11]]></summary>
        <content type="html"><![CDATA[<h2>学堂在线 11</h2><p>在这一章我学习了空间站与航天飞机的相关知识。空间站一般由工作舱、生活舱、过渡舱组成，工作舱是空间站的中心。截至到目前为止，世界上一共发射了10个空间站。航天飞机由火箭助推器、外挂储箱、轨道器组成。</p><h2>学堂在线 9</h2><p>在这一单元我学习了隐身飞机的相关知识。对于飞机来说，雷达信号、红外信号、声音信号、辐射信号等都可能使飞机被对方探测到，通过有源对消技术、外形隐身、采用隐身材料、等离子体技术等，可以减缩目标RCS。</p><h2>空间站有什么作用？</h2><p>空间站是一个大型的、载人的、在太空能长期运行的人造卫星，是环绕地球运动的半永久性空间基地。空间站的作用有：</p><ol><li>空间站是整个航天体系中的重要组成部分。可以接送来往的人员和物资，并担负通信任务；</li><li>空间站可以对其他航天器进行后勤保障、维修与保养；</li><li>空间站可以作为发射平台，把新的人造天体送入太空；</li><li>空间站可以利用太空的特殊环境从事科学研究，进行材料加工，完成对地监回测、资源勘查、天气预报以及天文观测等任务；</li><li>空间站可以与其他航天器在太空对接，组合成更大的轨道联合体，为宇航员在太空长期工作和生活创造良好的条件。</li></ol><p>（参考资料：百度知道）</p><h2>飞行器隐身的意义是什么？</h2><p>从广义上讲，可以把各种反探测的技术统称为隐身技术，在英文中称之为Stealth Technology。当然，也有人称之为低可见度技术，源于英文Low Observable Technology。</p><p>由此可见，飞行器隐身事实上就是在增加飞行器被探测的难度。在当下，隐身技术作为一项重要的突防技术手段，可以大大缩短防御系统的预警时间，提升其拦截难度，降低其拦截概率，从而保持飞行器突防能力优势；另一方面，也使得防御方的探测、拦截成本大大增加，具有很高的军事应用价值。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[谈谈对《关于费尔巴哈的提纲》第三条的理解]]></title>
        <id>谈谈对《关于费尔巴哈的提纲》第三条的理解</id>
        <link href="https://mondaycha.github.io/blog/2020/05/06/谈谈对《关于费尔巴哈的提纲》第三条的理解"/>
        <updated>2020-05-06T22:37:06.000Z</updated>
        <summary type="html"><![CDATA[一、辨析对错，并说明原因。]]></summary>
        <content type="html"><![CDATA[<h1>第十一周作业</h1><p>一、辨析对错，并说明原因。</p><p>一切历史都是思想史。</p><p>答：</p><p>这种观点是错误的。认为”一切历史都是思想史“，本质上是一种主观唯心主义，把人的意志、思想、观念说成是历史的决定因素。</p><p>固然，社会历史现象是人的活动的过程和产物，而人的活动都是受着一定的意识和思想支配的，人类历史中也包含着思想史。但唯物史观认为，物质生产及生产方式决定着社会的结构、性质和面貌，制约着人们的经济生活、政治生活和精神生活等全部社会生活。有什么样的生产方式便有什么样的社会形态。 </p><p>因此认为”一切历史都是思想史“的观点本质上是一种唯心史观，是错误的。</p><p>二、请结合马克思主义实践观及今天相关内容，谈谈对《关于费尔巴哈的提纲》第三条的理解。</p><blockquote><p>第三条</p><p>关于环境和教育起改变作用的唯物主义学说忘记了∶环境是由人来改变的，而教育者本人一定是受教育的。因此，这种学说必然把社会分成两部份，其中一部分凌驾于社会之上。</p><p>环境的改变和人的活动或自我改变人的活动的一致，只能被看做是并合理地理解为革命的实践。</p></blockquote><p>答：</p><p>在《关于费尔巴哈的提纲》第三条，马克思所阐述的是人与环境的关系，批判了旧空想社会主义者和唯物主义者的环境决定论以及唯心主义的英雄史观的观点。</p><p>在这一节课的内容里，我们学到了十八世纪法国的旧唯物主义者曾持有这样的观点：人是环境的产物，意见支配世界，进而将希望寄托在天才上；也学到了唯心主义者把英雄人物的意志和力量看作历史的决定力量的英雄史观。这两种观点都是片面的，而马克思《关于费尔巴哈的提纲》第三条就是对这些错误观点的批判，并阐述了马克思主义关于这一关系的思想。</p><p>首先，旧唯物主义过分强调环境的作用，但人与环境的关系也是主体和客体的关系，环境影响了人，人也影响了环境，人与环境之间是相互影响、相互协调的关系；其次，从马克思主义实践观的角度，实践活动正是协调人和环境关系的基础，正是通过人的实践活动改造了环境，又在人实践的过程中，环境塑造了人。</p><p>因此，我们要辩证地看待人与环境的关系，充分认识社会实践在人的发展中的重要作用。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab4-extra 学习笔记]]></title>
        <id>操作系统 OS Lab4-extra 学习笔记</id>
        <link href="https://mondaycha.github.io/blog/2020/05/06/操作系统-OS-Lab4-extra-学习笔记"/>
        <updated>2020-05-06T18:22:36.000Z</updated>
        <summary type="html"><![CDATA[Extra，干巴爹。]]></summary>
        <content type="html"><![CDATA[<h1>Lab4-extra 学习笔记</h1><p>Extra，干巴爹。</p><p>（5/9，刚刚才知道今年的Extra基础是去年的Exam1，我biss……）</p><h2>基础测试1</h2><h3>题目要求</h3><p>实现可变参数的系统调用参数传递。</p><h3>题目解析</h3><p>之前提到过，syscall 开头的函数与内核中的系统调用函数（sys 开头的函数）是一一对应的。调用过程如下：</p><pre><code class="language-c">int
syscall_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)
{
    return msyscall(SYS_mem_map, srcid, srcva, dstid, dstva, perm);
}
</code></pre><p>所以现在就要指定参数数目，在原有lib/syscall_all.c中代码不更改的情况下可以使系统调用机制正常运行。</p><p>指导书提示我们学习printf的实现方式，下面就来看看。</p><h3>Printf</h3><p>首先是lib/printf.c中的实现：</p><pre><code class="language-c">void printf(char *fmt, ...)             // printf有一个固定参数fmt
{
        va_list ap;                     // 定义了一个指针ap, 用于指示可选的参数
        va_start(ap, fmt);              // 以固定参数的地址为起点，确定变参的内存起始地址
        lp_Print(myoutput, 0, fmt, ap); // 将printf的va_list传递给lp_Print
        va_end(ap);                     // 清空参数列表, 并置参数指针ap无效
}
</code></pre><p>除了有一个参数fmt固定以外，后面跟的参数的个数和类型是可变的（用三个点“…”做参数占位符）。这里我们实际上是将printf的可变长参数直接传递给lp_Print，后者在在Lab1实现过，也比较复杂。关于那几个宏定义的作用，参考这里的解释：</p><blockquote><p>（1）va_list
　　定义了一个指针arg_ptr, 用于指示可选的参数.</p><p>（2）va_start(arg_ptr, argN)
　使参数列表指针arg_ptr指向函数参数列表中的第一个可选参数，argN是位于第一个可选参数之前的固定参数, 或者说最后一个固定参数.如有一va函数的声明是void va_test(char a, char b, char c, ...), 则它的固定参数依次是a,b,c, 最后一个固定参数argN为c, 因此就是va_start(arg_ptr, c).</p><p>（3）va_arg(arg_ptr, type)
返回参数列表中指针arg_ptr所指的参数, 返回类型为type. 并使指针arg_ptr指向参数列表中下一个参数.返回的是可选参数, 不包括固定参数.</p><p>（4）va_end(arg_ptr)
清空参数列表, 并置参数指针arg_ptr无效.</p><p>  （注：va在这里是variable-argument(可变参数)的意思.  这些宏定义在stdarg.h中,所以用到可变参数的程序应该包含这个头文件）</p></blockquote><p>以上知识均在基础中没有用。</p><h3>具体实现</h3><p>首先修改user/lib.h中的msyscall函数声明：</p><pre><code class="language-c">//////////////////////////////////////////////////syscall_lib
extern int msyscall(int, int, ...);
</code></pre><p>C语言调用汇编函数，用extern关键字定义。在syscall_* 系列函数中，我们将参数传递给了msyscall 函数。</p><p>在MIPS 的调用规范中，进入函数体时会通过对栈指针做减法的方式为自身的局部变量、返回地址、调用函数的参数分配存储空间（叶函数没有后两者），在函数调用结束之后会对栈指针做加法来释放这部分空间，我们把这部分空间称为栈帧（Stack Frame）。非叶函数是在调用方的栈帧的底部预留被调用函数的参数存储空间（被调用方从调用方函数的栈帧中取得参数）。</p><p>msyscall叶函数没有局部变量，不需要分配栈帧，我们只需要执行特权指令（syscall）来陷入内核态以及函数调用返回即可。在通过特权指令syscall 陷入内核态后，处理器将PC 寄存器指向一个相同的内核异常入口。在trap_init 函数中将系统调用类型的异常的入口设置为了handle_sys 函数，这就是我们要修改的第二个地方：修改lib/syscall.S，增加拷贝多个参数的循环。</p><blockquote><p>TIPS：汇编内的跳转注意延迟槽，内核态参数拷贝时注意使用s0-s7保存栈空间</p></blockquote><pre><code class="language-c">NESTED(handle_sys,TF_SIZE, sp)
    SAVE_ALL                            // 用于保存所有寄存器的汇编宏
    CLI                                 // 用于屏蔽中断位的设置的汇编宏
    nop
    .set at                             // 恢复$at寄存器的使用

    lw      t0, TF_EPC(sp)              // 将Trapframe的EPC寄存器取出
    addu    t0, 4                       // 计算一个合理的值
    sw      t0, TF_EPC(sp)              // 存回Trapframe中

    lw      a0, TF_REG4(sp)             // 将系统调用号“复制”入寄存器$a0

    addiu   a0, a0, -__SYSCALL_BASE     // a0 &lt;- “相对”系统调用号
    sll     t0, a0, 2                   // t0 &lt;- 相对系统调用号* 4
    la      t1, sys_call_table          // t1 &lt;- 系统调用函数的入口表基地址
    addu    t1, t1, t0                  // t1 &lt;- 特定系统调用函数入口表项地址
    lw      t2, 0(t1)                   // t2 &lt;- 特定系统调用函数入口函数地址

    lw      t0, TF_REG29(sp)            // t0 &lt;- 用户态的栈指针

    /* lw      t3, 16(t0)                  // t3 &lt;- msyscall的第5个参数 */
    /* lw      t4, 20(t0)                  // t4 &lt;- msyscall的第6个参数 */

    // TODO: Allocate a space of six arguments on current kernel stack and copy the six arguments to proper location
    lw      a0, TF_REG4(sp)
    lw      a1, TF_REG5(sp)

    li      s0, 0                       // 当前参数个数

    beq     s0, a1, labelend            // if s0 == a1 then target
    nop
    lw      a2, TF_REG6(sp)
    addiu   s0, s0, 1                   // s0 = 1

    beq     s0, a1, labelend            // if s0 == a1 then target
    nop
    lw      a3, TF_REG7(sp)
    addiu   s0, s0, 1                   // s0 = 2

    li      s1, 16                      // 当前栈高度

fori:
    beq     s0, a1, beforej             // if s0 == a1 then target
    nop
    addiu   s0, s0, 1                   // s0 = s0 + 1
    addiu   s1, s1, 4                   // s1 = s1 + 4
    j       fori
    nop

beforej:
    subu    sp, sp, s1                  // sp = sp - s1
    li      s0, 2                       // 当前已保存的参数个数
    addiu   s2, t0, 16                  // tf寄存器偏移量，每次步进4
    addiu   s3, sp, 16                  // sp寄存器偏移量，每次步进4

forj:
    beq     s0, a1, labelend            // if s0 == a1 then target
    nop
    
    lw      t3, 0(s2)                   // t3 &lt;- msyscall的第((s2 - t0) / 4 + 1)个参数
    sw      t3, 0(s3)
    addiu   s0, s0, 1                   // s0 = s0 + 1
    addiu   s2, s2, 4
    addiu   s3, s3, 4
    j       forj
    nop
    
labelend:

    jalr    t2                          // Invoke sys_* function
    nop
    
    // TODO: Resume current kernel stack
    addiu   sp, sp, s1

    sw      v0, TF_REG2(sp)             // Store return value of function sys_* (in $v0) into trapframe

    j       ret_from_exception          // Return from exeception
    nop
END(handle_sys)
</code></pre><h1>PB,YYDS</h1>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab4 学习笔记]]></title>
        <id>操作系统 OS Lab4 学习笔记</id>
        <link href="https://mondaycha.github.io/blog/2020/05/05/操作系统-OS-Lab4-学习笔记"/>
        <updated>2020-05-05T18:22:36.000Z</updated>
        <summary type="html"><![CDATA[今天的内容是OS Lab4的学习复习笔记……这周的OO强测只拿了20分，之前的所有优化努力直接白给……蓝瘦。]]></summary>
        <content type="html"><![CDATA[<p>今天的内容是OS Lab4的学习复习笔记……这周的OO强测只拿了20分，之前的所有优化努力直接白给……蓝瘦。</p><p>所以OS不能再一知半解了，在一开始同样放下学长博客与课程指导中心的视频——</p><blockquote><p><a href="https://www.cnblogs.com/SivilTaram/p/os_lab4.html">https://www.cnblogs.com/SivilTaram/p/os_lab4.html</a></p><p><a href="https://www.cnblogs.com/sharinka0715/p/10776860.html">https://www.cnblogs.com/sharinka0715/p/10776860.html</a></p><p><a href="https://ausar.xyz/index.php/archives/77/">https://ausar.xyz/index.php/archives/77/</a></p><p><a href="https://www.cnblogs.com/Yzx835/p/10775984.html">https://www.cnblogs.com/Yzx835/p/10775984.html</a></p><p><a href="https://blog.csdn.net/qq_36740940/article/details/89523911">https://blog.csdn.net/qq_36740940/article/details/89523911</a></p><p><a href="https://blog.csdn.net/weixin_44689094/article/details/105893744">https://blog.csdn.net/weixin_44689094/article/details/105893744</a></p><p><a href="https://blog.csdn.net/weixin_41412192/article/details/89522232">https://blog.csdn.net/weixin_41412192/article/details/89522232</a></p><p><a href="https://www.yizhibo.com/l/z3OzSureOCT8QEQT.html">https://www.yizhibo.com/l/z3OzSureOCT8QEQT.html</a></p></blockquote><p>在这一节的实验中，我们需要实现系统调用机制，并在此基础上实现进程间通信（IPC）机制和一个重要的系统调用fork。在梳理博客的时候，有的学长是根据运行顺序来总结的，我目前还是先跟着题目走。</p><h2>系统调用</h2><p>系统调用的流程：</p><ol><li>调用一个封装好的用户空间的库函数（如writef）</li><li>调用用户空间的syscall_* 函数</li><li>调用msyscall，用于陷入内核态</li><li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（sys_*）</li><li>执行系统调用，并返回用户态，同时将返回值“传递”回用户态</li><li>从库函数返回，回到用户程序调用处</li></ol><h3>Exercise 4.1</h3><p>填写user/syscall_wrap.S 中的msyscall 函数，使得用户部分的系统调用机制可以正常工作。</p><pre><code class="language-c">LEAF(msyscall)
    // TODO: you JUST need to execute a `syscall` instruction and return from msyscall
    syscall
    jr ra
    nop
END(msyscall)
</code></pre><p>执行syscall指令，然后从函数返回。</p><h3>Thinking 4.1</h3><p>思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>系统陷入内核调用后可以直接从当时的$a0-$a3 参数寄存器中得到用户调用msyscall 留下的信息吗？</li><li>我们是怎么做到让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数的？</li><li>内核处理系统调用的过程对Trapframe 做了哪些更改？这种修改对应的用户态的变化是？</li></ul><h3>Exercise 4.2</h3><p>按照lib/syscall.S 中的提示，完成handle_sys 函数，使得内核部分的系统调用机制可以正常工作。</p><p>在通过特权指令syscall 陷入内核态后，处理器将PC 寄存器指向一个相同的内核异常入口。在trap_init 函数中将系统调用类型的异常的入口设置为了handle_sys 函数。</p><p>第一个TODO，MIPS有异常程序计数器（exception program counter,EPC)，属于CP0寄存器，用于保存造成异常的那条指令的地址。让EPC值+4到下一条指令，这样就不会陷入反复中断的死循环之中。</p><pre><code class="language-c">/*** exercise 4.2 ***/
NESTED(handle_sys,TF_SIZE, sp)          // 把用户态的所有寄存器存进栈帧，sp相当于栈顶
    SAVE_ALL                            // 用于保存所有寄存器的汇编宏
    CLI                                 // 用于屏蔽中断位的设置的汇编宏
    nop
    .set at                             // 恢复$at寄存器的使用

    // TODO: Fetch EPC from Trapframe, calculate a proper value and store it back to trapframe.
    lw      t0, TF_EPC(sp)              // 将Trapframe的EPC寄存器取出
    addu    t0, 4                       // 计算一个合理的值
    sw      t0, TF_EPC(sp)              // 存回Trapframe中
</code></pre><p>第二个TODO，这里其实是多余的，因为a0的值没有改变过。</p><pre><code class="language-c">    // TODO: Copy the syscall number into $a0.
    lw      a0, TF_REG4(sp)             // 将系统调用号“复制”入寄存器$a0，a0是4号寄存器
</code></pre><p>之后是保存其他的值啦。</p><pre><code class="language-c">    addiu   a0, a0, -__SYSCALL_BASE     // a0 &lt;- “相对”系统调用号
    sll     t0, a0, 2                   // t0 &lt;- 相对系统调用号* 4
    la      t1, sys_call_table          // t1 &lt;- 系统调用函数的入口表基地址
    addu    t1, t1, t0                  // t1 &lt;- 特定系统调用函数入口表项地址
    lw      t2, 0(t1)                   // t2 &lt;- 特定系统调用函数入口函数地址

    lw      t0, TF_REG29(sp)            // t0 &lt;- 用户态的栈指针
    lw      t3, 16(t0)                  // t3 &lt;- msyscall的第5个参数
    lw      t4, 20(t0)                  // t4 &lt;- msyscall的第6个参数
</code></pre><p>这里有一步还原偏移的操作，__SYSCALL_BASE的定义在unistd.h里可以看到：</p><pre><code class="language-c">#ifndef UNISTD_H
#define UNISTD_H

#define __SYSCALL_BASE 9527
#define __NR_SYSCALLS 20


#define SYS_putchar         ((__SYSCALL_BASE ) + (0 ) )
#define SYS_getenvid        ((__SYSCALL_BASE ) + (1 ) )
#define SYS_yield           ((__SYSCALL_BASE ) + (2 ) )
#define SYS_env_destroy     ((__SYSCALL_BASE ) + (3 ) )
#define SYS_set_pgfault_handler ((__SYSCALL_BASE ) + (4 ) )
#define SYS_mem_alloc       ((__SYSCALL_BASE ) + (5 ) )
#define SYS_mem_map         ((__SYSCALL_BASE ) + (6 ) )
#define SYS_mem_unmap       ((__SYSCALL_BASE ) + (7 ) )
#define SYS_env_alloc       ((__SYSCALL_BASE ) + (8 ) )
#define SYS_set_env_status  ((__SYSCALL_BASE ) + (9 ) )
#define SYS_set_trapframe       ((__SYSCALL_BASE ) + (10 ) )
#define SYS_panic           ((__SYSCALL_BASE ) + (11 ) )
#define SYS_ipc_can_send        ((__SYSCALL_BASE ) + (12 ) )
#define SYS_ipc_recv        ((__SYSCALL_BASE ) + (13 ) )
#define SYS_cgetc           ((__SYSCALL_BASE ) + (14 ) )
#endif
</code></pre><p>第三个TODO，和MIPS的传参有关，前4 个参数会被syscall 开头的函数分别存入a0−a3（$4~$7） 寄存器的空间内，同时栈帧底部保留16 字节的空间；后2个参数只会被存入在前4的参数的预留空间之上的8字节空间内。</p><pre><code class="language-c">    // TODO: Allocate a space of six arguments on current kernel stack and copy the six arguments to proper location
    lw      a0, TF_REG4(sp)             // 这一步也是多余的
    lw      a1, TF_REG5(sp)
    lw      a2, TF_REG6(sp)
    lw      a3, TF_REG7(sp)
    subu    sp, sp, 24
    sw      t3, 16(sp)                  // 0-16：栈帧底部保留的16字节空间
    sw      t4, 20(sp)
    
    jalr    t2                          // 调用sys_*函数
    nop
</code></pre><p>第四个TODO，恢复sp指针的值。</p><pre><code class="language-c">    // TODO: Resume current kernel stack
    addiu   sp, sp, 24                  // 恢复栈指针到分配前的状态
    

    sw      v0, TF_REG2(sp)             // 此时已经从系统调用中返回，将返回值存入Trapframe

    j       ret_from_exception          // 从异常中返回（恢复现场）
    nop
END(handle_sys)
</code></pre><p>最后就将返回值保存到v0，同时从系统调用中返回了。</p><h3>Exercise 4.3</h3><p>实现lib/syscall_all.c 中的int sys_mem_alloc(int sysno,u_int envid,u_int va, u_int perm) 函数。</p><pre><code class="language-c">/* 概述:
 * 分配一页内存，并映射到&#x27;va&#x27;的权限
 * &#x27;envid&#x27;的地址空间中的&#x27;perm&#x27;。
 * 如果一个页面已经在&#x27;va&#x27;被映射，那么该页面将被取消映射。
 * 前提:
 * perm：需要PTE_V，不允许使用PTE_COW(返回-E_INVAL)，
 * 其他位是可选的。
 *
 * 后置条件:
 * 成功返回0，错误&lt; 0
 * va必须 &lt; UTOP
 * env可以修改自己的地址空间或其子节点的地址空间
 * /
/*** exercise 4.3 ***/
int sys_mem_alloc(int sysno, u_int envid, u_int va, u_int perm)
{
    // Your code here.
    struct Env *env;
    struct Page *ppage;
    int ret;
    ret = 0;

    // 2020-04-28
    if (va &gt;= UTOP || (perm &amp; PTE_COW) || !(perm &amp; PTE_V))  // PTE_V may?
        return -E_INVAL;

    ret = envid2env(envid, &amp;env, 0);
    if (ret &lt; 0)
        return ret;

    ret = page_alloc(&amp;ppage);
    if (ret &lt; 0)
        return ret;

    ret = page_insert(env-&gt;env_pgdir, ppage, va, perm);
    if (ret &lt; 0)
        return ret;

    return 0;
}
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week9]]></title>
        <id>《航空航天概论》Week9</id>
        <link href="https://mondaycha.github.io/blog/2020/05/01/《航空航天概论》Week9"/>
        <updated>2020-05-01T03:48:43.000Z</updated>
        <summary type="html"><![CDATA[爱课程 8.1 飞机机体构造]]></summary>
        <content type="html"><![CDATA[<h2>爱课程 8.1 飞机机体构造</h2><p>不同飞行器的飞机机体的构造也不一样。A-380是当时最大的客机，结构设计复杂，对于客运飞机，机体要设计得很宽敞。设计飞机机体时要从多个方面综合考虑。机翼有三大功能：产生升力、承担载荷、配合尾翼等。</p><h2>爱课程 8.2 飞机起落架</h2><p>起落架的布置有后三点式、前三点式、多轮多支柱式，前三点式起落架是现在飞机的常见类型，对于大型飞机，多轮多支柱式更加适合。其中安-225采用的是多轮多支柱起落架，。起落架有轮式、滑橇式、浮筒式、滑车式。</p><h2>学堂在线 8</h2><p>在这一章我学习到，遥控制导的导弹设备简单、机动性强、可以根据指令随时改变飞行轨迹；中国的红旗-2防空导弹属于非瞄准线指令制导；主动雷达寻的制导的特点是具有发射后不管的能力、自带雷达和天线、受天气和时间影响小、抗干扰能力强。</p><h2>学堂在线 11</h2><p>在这一章我学习到，嫦娥一号的有效载荷是成像光谱仪，空间探测器对星球的探测方式包括环绕探测、取样返回、近旁掠过、实地探测。宇宙飞船一般由返回舱、轨道舱、服务舱等几大部分组成，载人飞船的核心舱是返回舱。</p><h2>导航和制导之间的区别是什么？</h2><p>制导是导引和控制飞行器按一定规律飞向目标或预定轨道的技术和方法，主要运用于军事，分有线制导、无线电制导、雷达制导、红外制导、激光制导、音响制导、地磁制导、惯性制导和天文制导等多种方式；导航是一个研究领域，重点是监测和控制工艺或车辆从一个地方移动到另一个地方的过程。 包括四个一般类别：陆地导航，海洋导航，航空导航和空间导航。</p><h2>气球和飞艇在构造上有什么不同？</h2><p>飞艇是一种轻于空气的航空器，它与热气球最大的区别在于具有推进和控制飞行状态的装置，可以自行飞行。气球中的热气球唯一飞行动力是风，必须选择速度和方向都合适的高空气流，并随之运动，才能高效地完成飞行。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab3 实验报告]]></title>
        <id>操作系统 OS Lab3 实验报告</id>
        <link href="https://mondaycha.github.io/blog/2020/04/24/操作系统-OS-Lab3-实验报告"/>
        <updated>2020-04-24T18:43:36.000Z</updated>
        <summary type="html"><![CDATA[一、实验思考题]]></summary>
        <content type="html"><![CDATA[<h1>OS Lab3 实验报告</h1><h2>一、实验思考题</h2><h3>Thinking 3.1</h3><p>为什么我们在构造空闲进程链表时必须使用特定的插入的顺序？(顺序或者逆序)</p><p>答：</p><p>因为注释要求“确保在插入之后，env在列表中的顺序应该与envs数组中的相同”，这样就会使第一次调用env_alloc()时返回envs<!-- -->[0]<!-- -->。</p><h3>Thinking 3.2</h3><p>思考env.c/mkenvid 函数和envid2env 函数:</p><ul><li>请你谈谈对mkenvid 函数中生成id 的运算的理解，为什么这么做？</li><li>为什么envid2env 中需要判断e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？</li></ul><p>答：</p><p>(1) 生成ID的式子为<code>return (++next_env_id &lt;&lt; (1 + LOG2NENV)) | idx;</code>，其中1-10位是对应进程在envs数组中的下标；12位起是由mkenvid被调用次数形成的唯一ID，这样做可以确保生成新进程id都是唯一的。</p><p>(2) 因为envid2env 中e是通过宏<code>ENVX()</code>获取envid的低10位，从而获得进程在envs数组中的下标，而不同进程可能在envs数组中有相同的下标，如果没有这步判断可能导致返回错误进程，因此需要用e-&gt;env_id != envid验证从envs数组中获取的进程是否为所需进程。</p><h3>Thinking 3.3</h3><p>结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数：</p><ul><li>我们在初始化新进程的地址空间时为什么不把整个地址空间的pgdir 都清零，而是复制内核的boot_pgdir作为一部分模板？(提示:mips 虚拟空间布局)</li><li>UTOP 和ULIM 的含义分别是什么，在UTOP 到ULIM 的区域与其他用户区相比有什么最大的区别？</li><li>在env_setup_vm 函数的最后，我们为什么要让pgdir<!-- -->[PDX(UVPT)]<!-- -->=env_cr3?(提示: 结合系统自映射机制)</li><li>谈谈自己对进程中物理地址和虚拟地址的理解</li></ul><p>答：</p><p>(1) 根据mmu.h里面的布局，我们的操作系统是2G/2G 模式，在本实验中，UTOP以上的虚拟地址空间到物理地址的映射关系都是一样的。因此复制内核的boot_pgdir中UTOP以上的内容到pgdir中，在进入内核态时不需要切换CR3寄存器。</p><p>(2) ULIM划分了用户空间与内核空间，UTOP属于用户空间，但UTOP至ULIM的区域与其他用户区相比，用户只能读不能写，其由三个4M大小的空间组成，分别存放进程envs数组、pages数组、进程页表。</p><p>(3) UVPT(0x7fc00000) 到 ULIM(0x80000000) 之间的空间为4MB ，这一区域就是进程的页表的位置，而PDX(UVPT)就是页目录自映射所对应的页目录在页表中的位置，因此要让pgdir<!-- -->[PDX(UVPT)]<!-- -->=env_cr3。</p><p>(4) 不同进程有各自的虚拟空间，访问相同虚拟地址时得到的结果可能是不同的；对于不同的进程而言，虚拟地址ULIM 以上的地方虚拟地址到物理地址的映射关系都是一样的，方便内核对进程进行管理。</p><h3>Thinking 3.4</h3><p>思考user_data 这个参数的作用。没有这个参数可不可以？为什么？（如果你能说明哪些应用场景中可能会应用这种设计就更好了。可以举一个实际的库中的例子）</p><p>答：</p><p>不可以。在我们的实验中，与user_data有关的函数是load_icode、load_elf、load_icode_mapper，其中的user_data就是进程e的指针，是不可或缺的。</p><p>应用场景：load_icode_mapper是一个回调函数，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。C语言标准库<code>&lt;stdlib.h&gt;</code>中的排序qsort就用到了这种设计：</p><pre><code class="language-c">void qsort(void*base,size_t num,size_t width,int(__cdecl*compare)(const void*,const void*));
</code></pre><p>这之中的compare就是回调函数，两个形参是const void *型，有着很高的泛用性，与user_data的设计类似。</p><h3>Thinking 3.5</h3><p>结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？ （提示：1、页面大小是多少；2、回顾lab1中的ELF文件解析，什么时候需要自动填充.bss段）</p><p>答：</p><ol><li>若va不对齐，拷贝长度要选择BY2PG - offset和bin_size中的最小值，复制第一页。</li><li>i &lt; bin_size时，如果i &lt; bin_size - BY2PG，那么就以BY2PG步进，复制每一页；如果出现了BY2PG &gt; bin_size - i的情况，那么依然要分配一页的空间。</li><li>如果i仍然小于sgsize，需要继续申请页面并置0。</li></ol><p>.bss 段是全部要置零，也就包含在置零的空间中。</p><h3>Thinking 3.6</h3><p>思考上面这一段话，并根据自己在lab2 中的理解，回答：</p><ul><li>我们这里出现的” 指令位置” 的概念，你认为该概念是针对虚拟空间，还是物理内存所定义的呢？</li><li>你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？</li></ul><p>答：</p><p>(1) 虚拟空间。当我们运行进程时，CPU 将自动从pc所指的位置开始执行二进制码，此时的空间是连续的，而虚拟空间对应的物理内存可能是不连续的，因此是虚拟空间。</p><p>(2) 一样。每个进程都有独立的虚拟空间，因此entry_point其值对于每个进程一样，是程序入口；但entry_point实际映射的物理地址不同。</p><h3>Thinking 3.7</h3><p>思考一下，要保存的进程上下文中的env_tf.pc的值应该设置为多少？为什么要这样设置？</p><p>答：</p><p>要保存的进程上下文中的env_tf.pc的值应该设置为cp0_epc，从而从被中断的指令继续运行。</p><h3>Thinking 3.8</h3><p>思考TIMESTACK 的含义，并找出相关语句与证明来回答以下关于TIMESTACK 的问题：</p><ul><li>请给出一个你认为合适的TIMESTACK 的定义</li><li>请为你的定义在实验中找出合适的代码段作为证据(请对代码段进行分析)</li><li>思考TIMESTACK 和第18 行的KERNEL_SP 的含义有何不同</li></ul><p>答：</p><p>(1) TIMESTACK以下<code>[TIMESTACK - sizeof(struct Trapframe), TIMESTACK)</code>的空间存储着异常发生时的寄存器信息，是时钟中断的存储区。</p><p>(2) 在include/stackframe.h中可以找到：</p><pre><code class="language-c">.macro get_sp
    mfc0    k1, CP0_CAUSE
    andi    k1, 0x107C
    xori    k1, 0x1000
    bnez    k1, 1f
    nop
    li  sp, 0x82000000
    j   2f
    nop
1:
    bltz    sp, 2f
    nop
    lw  sp, KERNEL_SP
    nop

2:  nop


.endm
</code></pre><p>其中的0x82000000即TIMESTACK的值。本次实验产生的都是时钟中断（4号异常），进行的是<code>li	sp, 0x82000000</code>的操作，因此是时钟中断的存储区。</p><p>(3) TIMESTACK是时钟中断的存储区，而KERNEL_SP应当是系统调用的存储区。</p><h3>Thinking 3.9</h3><p>阅读 kclock_asm.S  文件并说出每行汇编代码的作用。</p><p>答：</p><pre><code class="language-c">.macro  setup_c0_status set clr // 定义宏setup_c0_status，传入set置位和clr清零形参
    .set    push                // 保存现场
    mfc0    t0, CP0_STATUS      // 读CP0_STATUS的值到t0寄存器      
    or  t0, \set|\clr           // t0=(t0|set|clr)，将set为1的置1
    xor t0, \clr                // t0= xor(t0,clr)，将clr为1的置0
    mtc0    t0, CP0_STATUS      // 将t0寄存器写回CP0_STATUS
    .set    pop                 // 恢复现场
.endm                           // 结束宏语句            

    .text                       // 代码段
LEAF(set_timer)                 // LEAF定义不调用其他函数的叶子函数set_timer

    li t0, 0x01                 // t0设为1
    sb t0, 0xb5000100           // 设置实时钟中断的频率为1秒1次
    sw  sp, KERNEL_SP           // 保存堆栈现场到KERNEL_SP
setup_c0_status STATUS_CU0|0x1001 0 // 设置CP0_STATUS，set为0x10001001
    jr ra                       // 函数返回

    nop                         // 延迟槽
END(set_timer)                  // 结束函数
</code></pre><h3>Thinking 3.10</h3><p>阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</p><p>答：</p><ol><li>首先在set_timer设置实时钟中断的频率，实验中为1秒1次。</li><li>一旦实时钟中断产生，就会触发MIPS 4号中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。</li><li>通过text.exc<em>vec3代码段的分发，调用handle</em> int 函数来处理实时钟中断。</li><li>在handle<em> int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer</em> irq。</li><li>在timer<em> irq里跳转到sched</em> yield，如果当前进程的时间片用完了，则切换到下一个进程。</li></ol>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab3 学习笔记]]></title>
        <id>操作系统 OS Lab3 学习笔记</id>
        <link href="https://mondaycha.github.io/blog/2020/04/24/操作系统-OS-Lab3-学习笔记"/>
        <updated>2020-04-24T18:22:36.000Z</updated>
        <summary type="html"><![CDATA[今天的内容是OS Lab3的学习复习笔记，然后下午去写理论课第八次作业。]]></summary>
        <content type="html"><![CDATA[<p>今天的内容是OS Lab3的学习复习笔记，然后下午去写理论课第八次作业。</p><p>在一开始同样放下优秀学长博客——</p><blockquote><p><a href="https://www.cnblogs.com/SivilTaram/p/oslab3.html">https://www.cnblogs.com/SivilTaram/p/oslab3.html</a></p><p><a href="https://ausar.xyz/index.php/archives/75/">https://ausar.xyz/index.php/archives/75/</a></p></blockquote><p>Lab3的内容是进程与异常，将运行一个用户模式的进程。需要使用数据结构进程控制块 Env 来跟踪用户进程。通过建立一个简单的用户进程，加载一个程序镜像到进程控制块中，并让它运行起来。</p><h2>进程控制块</h2><p>进程控制块(PCB) 是系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程。</p><h3>Exercise 3.2</h3><p>需要补充env_init 函数。</p><pre><code class="language-c">/*** exercise 3.2 ***/
void env_init(void)
{
    int i;
    /*Step 1: Initial env_free_list. */
    LIST_INIT(&amp;env_free_list);      
    // 初始化env_free_list
    LIST_INIT(&amp;env_sched_list[0]);
    LIST_INIT(&amp;env_sched_list[1]);
    // 根据调度方法进行初始化，我把这步放在了env_init(void)函数里

    /*Step 2: Traverse the elements of &#x27;envs&#x27; array,
     * set their status as free and insert them into the env_free_list.
     * Choose the correct loop order to finish the insertion.
     * Make sure, after the insertion, the order of envs in the list
     * should be the same as it in the envs array. */
    for (i = NENV - 1; i &gt;= 0; i--) // 倒序插入，总共是1024个进程
    {
        envs[i].env_status = ENV_FREE;
        /* 初始化进程状态
         * 有ENV_FREE，ENV_NOT_RUNNABLE，ENV_RUNNABLE三种
         * ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。
         * ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态
         * 处于该状态的进程往往在等待一定的条件才可以变为就绪状态从而被CPU 调度。
         * ENV_RUNNABLE : 表明该进程处于就绪状态，正在等待被调度
         * 但处于RUNNABLE 状态的进程可以是正在运行的，也可能不在运行中 */
        LIST_INSERT_HEAD(&amp;env_free_list, &amp;envs[i], env_link);
    }
}
</code></pre><p>LIST_INSERT_HEAD效率高，采用逆序插入，确保在插入之后，env在列表中的顺序应该与envs数组中的相同，这样就会使第一次调用env_alloc()时返回envs<!-- -->[0]<!-- -->。</p><p>复习一下LIST_INSERT_HEAD，传入的三个参数分别为链表头、插入元素、链表指针。</p><pre><code class="language-c">#define LIST_INSERT_HEAD(head, elm, field) do {                         \
                if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)     \
                        LIST_FIRST((head))-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);\
                LIST_FIRST((head)) = (elm);                                     \
                (elm)-&gt;field.le_prev = &amp;LIST_FIRST((head));                     \
        } while (0)
</code></pre><p>在Lab3要区分清楚env_link和env_sched_link。</p><h3>Thinking 3.1</h3><p>为什么我们在构造空闲进程链表时必须使用特定的插入的顺序？(顺序或者逆序)</p><p>答：</p><p>因为注释要求“确保在插入之后，env在列表中的顺序应该与envs数组中的相同”，这样就会使第一次调用env_alloc()时返回envs<!-- -->[0]<!-- -->。</p><p>（是为了Lab 4 Extra 进阶 Part 2，Pb在5月5日如是说）</p><h2>进程的标识</h2><p>每个进程都有独一无二的标识符，在创建每个新的进程的时候必须为它赋予一个与众不同的id来作为它的标识符，mkenvid的作用就是生成一个新的进程id。</p><pre><code class="language-c">u_int mkenvid(struct Env *e)
{
    static u_long next_env_id = 0;

    /*Hint: lower bits of envid hold e&#x27;s position in the envs array. */
    u_int idx = e - envs;

    /*Hint:  high bits of envid hold an increasing number. */
    return (++next_env_id &lt;&lt; (1 + LOG2NENV)) | idx;
}
</code></pre><p>extra就涉及对这个的修改。在这里我其实是比较疑惑的，我们的操作系统设置的最大进程数目为1024，也就是idx的取值范围，按理说next_env_id只需要左移10位就可以满足需求，PB在群里问了操作系统的WL老师，表示和GET_ENV_ASID这个宏有关：</p><pre><code class="language-c">#define GET_ENV_ASID(envid) (((envid)&gt;&gt; 11)&lt;&lt;6)
</code></pre><p>想了想可能和操作系统改成大猩猩也能看懂的实验课（此处为青猪梗，我完全看不懂）之前是支持理论最多2048个进程有关，比如Windows 32位系统中就是这样（不过一个进程能使用的最大虚拟内存为2G，而一个线程的默认线程栈为1M，一般在线程数接近2000时就异常退出了）。</p><h3>Exercise 3.3</h3><p>需要补充envid2env函数，将一个envid转换为一个env指针，按照注释做就行。</p><p>用宏ENVX()从envid获取对应结构体在envs中的下标：</p><pre><code class="language-c">#define ENVX(envid) ((envid) &amp; (NENV - 1))
</code></pre><h3>Thinking 3.2</h3><p>思考env.c/mkenvid 函数和envid2env 函数:</p><ul><li>请你谈谈对mkenvid 函数中生成id 的运算的理解，为什么这么做？</li><li>为什么envid2env 中需要判断e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？</li></ul><p>答：</p><p>(1) 生成ID的式子为<code>return (++next_env_id &lt;&lt; (1 + LOG2NENV)) | idx;</code>，其中1-10位是对应进程在envs数组中的下标；12位起是由mkenvid被调用次数形成的唯一ID，这样做可以确保生成新进程id都是唯一的。</p><p>(2) 因为envid2env 中e是通过宏<code>ENVX()</code>获取envid的低10位，从而获得进程在envs数组中的下标，而不同进程可能在envs数组中有相同的下标，如果没有这步判断可能导致返回错误进程，因此需要用e-&gt;env_id != envid验证从envs数组中获取的进程是否为所需进程。</p><h2>设置进程控制块</h2><p>创建进程需要手动初始化进程控制块。</p><h3>Exercise 3.4</h3><p>需要填写env_setup_vm函数，为env_alloc做准备。</p><p>先看看这不说人话的注释——</p><pre><code class="language-c">/*Step 2: Call certain function(has been implemented) to init kernel memory
* layout for this new Env.
*The function mainly maps the kernel address to this new Env address. */
</code></pre><p>这个函数env_setup_vm将内核地址映射到新的Env地址，也就是初始化新进程的地址空间。</p><p>在env_setup_vm代码中预设置了int型变量i和r，i大概是用在循环体上，r则是用于错误返回值（0是无事发生），这些在其他模块中也常常见到。</p><pre><code class="language-c">    if (r = page_alloc(&amp;p))
    {
        panic(&quot;env_setup_vm - page alloc error\n&quot;);
        return r;
    }
    p-&gt;pp_ref++;
    pgdir = page2kva(p);
</code></pre><p>第一步先从页表中申请一页p，作为页目录使用，这样这个进程也具有成为临时内核的资格。为其设置pp_ref，并把这一页的内核虚拟地址保存到pgdir。</p><p>对于不同的进程而言，虚拟地址ULIM(<code>0x80000000</code>)以上的地方，虚拟地址到物理地址的映射关系都是一样的。而这里我们是从UTOP开始拷贝的，这里就有一个疑问——<strong>UTOP不是在ULIM下面吗，属于用户地址，为什么是从这里拷贝的呢？</strong></p><p>这里再搬出mmu的图：</p><pre><code class="language-c">/*
 o      ULIM     -----&gt; +----------------------------+------------0x8000 0000-------    
 o                      |         User VPT           |     PDMAP                /|\ 
 o      UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    |
 o                      |         PAGES              |     PDMAP                 |
 o      UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    |
 o                      |         ENVS               |     PDMAP                 |
 o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |
 o  UXSTACKTOP -/       |     user exception stack   |     BY2PG                 |
*/
</code></pre><p>UTOP同样也是UENVS，而在3.1的mips_vm_init()，我们有这样一条操作：</p><pre><code class="language-c">/* Step 3, Allocate proper size of physical memory for global array `envs`,
 * for process management. Then map the physical address to `UENVS`. */
envs = (struct Env *)alloc(NENV * sizeof(struct Env), BY2PG, 1);
n = ROUND(NENV * sizeof(struct Env), BY2PG);
boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R);
</code></pre><p>在这里创建一个struct Env数组，大小为NENV个元素，而这也是全局的进程数组。通过boot_map_segment将envs对应的物理地址映射到虚拟地址UENVS，也就是说，这一块区域存储着所有的进程（mmu图中的ENVS）。</p><p>引用SivilTaram学长的解释——</p><blockquote><p>其实足以看出来，内核在映射的时候已经为用户留下了一条路径！一条获取其他进程信息的路途！而且我们其实可以知道，这一部分对于进程而言应当是只能读不可以写的。开启中断后我们在进程中再访问内核就会产生异常来陷入内核了，所以应该是为了方便读一些进程信息，内核专门开辟了这4M的用户进程虚拟区。用户读这4M空间的内容是不需要产生异常的。</p></blockquote><p>嗯……果然我还是不大懂，然后就跟着注释把[0，UTOP)的进程页目录清零。</p><pre><code class="language-c">    /*Step 2: Zero pgdir&#x27;s field before UTOP. */
    for (i = 0; i &lt; PDX(UTOP); i++)
    {
        pgdir[i] = 0;
    }
</code></pre><p>拷贝内核虚拟页目录的[UTOP,0xffffffff)区间的内容到进程页目录。</p><pre><code class="language-c">    /*Step 3: Copy kernel&#x27;s boot_pgdir to pgdir. */
    for (i = PDX(UTOP); i &lt; PDX(0xffffffff); i++)
    {
        pgdir[i] = boot_pgdir[i];
    }
</code></pre><p>之后将pgdir保存在e-&gt;pgdir，将pgdir的物理地址保存到e-&gt;env_cr3中，并将其映射到进程页表中——</p><pre><code class="language-c">    // UVPT maps the env&#x27;s own page table, with read-only permission.
    e-&gt;env_pgdir[PDX(UVPT)] = e-&gt;env_cr3 | PTE_V;   // read-only
</code></pre><h3>Thinking 3.3</h3><p>结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数：</p><ul><li>我们在初始化新进程的地址空间时为什么不把整个地址空间的pgdir 都清零，而是复制内核的boot_pgdir作为一部分模板？(提示:mips 虚拟空间布局)</li><li>UTOP 和ULIM 的含义分别是什么，在UTOP 到ULIM 的区域与其他用户区相比有什么最大的区别？</li><li>在env_setup_vm 函数的最后，我们为什么要让pgdir<!-- -->[PDX(UVPT)]<!-- -->=env_cr3?(提示: 结合系统自映射机制)</li><li>谈谈自己对进程中物理地址和虚拟地址的理解</li></ul><p>答：</p><p>(1) 根据mmu.h里面的布局，我们的操作系统是2G/2G 模式，在本实验中，UTOP以上的虚拟地址空间到物理地址的映射关系都是一样的。因此复制内核的boot_pgdir中UTOP以上的内容到pgdir中，在进入内核态时不需要切换CR3寄存器。</p><p>(2) ULIM划分了用户空间与内核空间，UTOP属于用户空间，但UTOP至ULIM的区域与其他用户区相比，用户只能读不能写，其由三个4M大小的空间组成，分别存放进程envs数组、pages数组、进程页表。</p><p>(3) UVPT(0x7fc00000) 到 ULIM(0x80000000) 之间的空间为4MB ，这一区域就是进程的页表的位置，而PDX(UVPT)就是页目录自映射所对应的页目录在页表中的位置，因此要让pgdir<!-- -->[PDX(UVPT)]<!-- -->=env_cr3。</p><p>(4) 不同进程有各自的虚拟空间，访问相同虚拟地址时得到的结果可能是不同的；对于不同的进程而言，虚拟地址ULIM 以上的地方虚拟地址到物理地址的映射关系都是一样的，方便内核对进程进行管理。</p><h3>Exercise 3.5</h3><p>补充env_alloc，根据父进程生成子进程到new指针中，首先从env_free_list获取第一个空闲进程。</p><pre><code class="language-c">/*Step 1: Get a new Env from env_free_list*/
if (LIST_EMPTY(&amp;env_free_list))
{
    return -E_NO_FREE_ENV;
}
e = LIST_FIRST(&amp;env_free_list);
</code></pre><p>接下来就要为这个纯洁的e进程分配地址空间，用之前写过的env_setup_vm实现映射。</p><pre><code class="language-c">r = env_setup_vm(e);
if (r != 0)
{
    panic(&quot;env_setup_vm failed!&quot;);
}
</code></pre><p>然后创建独一无二的ID，设置进程状态。ENV_RUNNABLE表明该进程处于就绪状态，正在等待被调度。</p><pre><code class="language-c">/*Step 3: Initialize every field of new Env with appropriate values.*/
e-&gt;env_id = mkenvid(e);
e-&gt;env_parent_id = parent_id;
e-&gt;env_status = ENV_RUNNABLE;
</code></pre><p>接下来就是设置29号寄存器（SP寄存器，堆栈指针寄存器）和cp0寄存器（协处理器）的值，把e的值交给new，并从空闲进程链表中删去e。</p><pre><code class="language-c">/*Step 4: Focus on initializing the sp register and cp0_status of env_tf field, located at this new Env. */
e-&gt;env_tf.regs[29] = USTACKTOP;
e-&gt;env_tf.cp0_status = 0x10001004;
*new = e;

/*Step 5: Remove the new Env from env_free_list. */
LIST_REMOVE(e, env_link);
</code></pre><p>世界是多么的美好啊！接下来就是本次实验的坑点了，虽然我Debug3天的原因是Lab2写错……</p><h2>加载二进制镜像</h2><p>我们需要为新进程的程序分配空间来容纳程序代码，这也是本次实验的大难点了。</p><h3>Thinking 3.4</h3><p>思考user_data 这个参数的作用。没有这个参数可不可以？为什么？（如果你能说明哪些应用场景中可能会应用这种设计就更好了。可以举一个实际的库中的例子）</p><p>答：</p><p>不可以。在我们的实验中，与user_data有关的函数是load_icode、load_elf、load_icode_mapper，其中的user_data就是进程e的指针，是不可或缺的。</p><p>应用场景：load_icode_mapper是一个回调函数，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。C语言标准库<code>&lt;stdlib.h&gt;</code>中的排序qsort就用到了这种设计：</p><pre><code class="language-c">void qsort(void*base,size_t num,size_t width,int(__cdecl*compare)(const void*,const void*));
</code></pre><p>这之中的compare就是回调函数，两个形参是const void *型，有着很高的泛用性，与user_data的设计类似。</p><h3>Exercise 3.6</h3><p>填充load_icode_mapper 函数。复制下助教的Lab3释疑解惑的内容，这样下次就不需要找PDF了。</p><pre><code class="language-c">struct Env *env = (struct Env *)user_data;
struct Page *p = NULL;
u_long i = 0;
int r;
u_long offset = va - ROUNDDOWN(va, BY2PG);
</code></pre><blockquote><p>这个函数集前三个lab 知识之大成，一定要熟悉lab1 中的ELF 结构和lab2 中内存分配的方法！在填写这个函数之前，要先知道它是干什么的。我们现在已经完成实验的第三步--- 创建进程中的第一小步，现在已经有了空进程，但只有骨架没有灵魂怎么行？一个进程是一个程序的一次运行，所以现在就要把程序装进给进程分配的内存空间中。</p><p>这一任务由load_icode 函数来完成，它的步骤就是分配内存，并将二进制代码装入分配好的内存中。但它一个函数要承担这么大的任务，有点吃不消啊。所以它就把装入内存的任务交给了load_elf 函数。但装入内存的任务还是有点艰巨，不仅要解析ELF 结构，还要把ELF 的内容复制到分配好的内存中。这函数比较懒，就又把内容复制的任务交给了load_icode_mapper。这下终于不再嵌套了，好像身体被掏空是不是？别急，先来看看这个函数。这个函数如果完成了，lab3 也就没啥难的了。</p><p>这个函数大体上也是两步走，第一步，复制ELF 的内容（当然，必须是代码段和全局数据段）。第二步就是难中之难，给ELF 的内容分配页面。</p><p>现在二进制码长度已经由它的参数bin_size 传入了。那又跑出一个段长度sgsize 是什么鬼？还记得lab1 的readelf 吧，二进制码长度bin_size 等于代码段.text 和全局数据段.data 长度之和，但不一定等于ELF 要占用的内存大小。回顾lab1 中的ELF 结构，代码段是通过program header 定位的，每个头部都有一个filesize 和memsize，就分别对应bin_size 和sgsize。别忘了ELF 中还有一个.bss 段哦，这.bss 段是全部要置零的，所以无需在ELF 中体现，但并不代表它就不占内存。那么请你想一下，bin_size 和sgsize 满足什么样的不等式？.bss 段的起始地址和bin_size 是什么关系？这是该函数的第一个难点。</p><p>前门狼刚走，后门虎又来。看看函数前面的说明，pre_condition 中有一条提示：va may NOT aligned 4KB。这提示了什么？lab2 中我们实现的是页式内存管理，一页的大小是4KB（BY2PG），也就是说，一个页的首地址的十六进制表示的后三位都是0。如果va 不是一个页的首地址，比如0x0003f2d4，该如何处理呢？那么同样的问题，如果.bss 段的首地址不是页对齐的，又该如何处理呢？提示：善于利用offset 变量。再给一个提示，在一段内存不满一个页（4KB）的情况下，仍然要分配一整个页来存储，就像出租车计费，就算你多走了100 米也会按1 公里算。</p></blockquote><p>函数大致的作用是把大小为bin_size的*bin文件，拷贝到<!-- -->[va，va+sgsize]<!-- -->这个区间中，不足地方补零，在一段内存不满一个页（4KB）的情况下，仍然要分配一整个页来存储。由于va不一定对齐，拷贝分为三个步骤：</p><ol><li><strong>不对齐时，载入第一页：</strong></li></ol><pre><code class="language-c">/*Step 1: load all content of bin into memory. */
/*First, bin-&gt;[0,BY2PG-offset] to [offset,BY2PG]*/
if (offset)
{
    u_int32_t size = MIN(BY2PG - offset, bin_size);
    r = page_alloc(&amp;p);
    if (r)
        return r;
    bcopy(&amp;bin[i], page2kva(p) + offset, size);
    r = page_insert(env-&gt;env_pgdir, p, va, PTE_R);
    if (r)
        return r;
    i += size;
}
</code></pre><ol start="2"><li><strong>载入第二页直到拷贝完整个文件，此时i始终与BY2PG对齐：</strong></li></ol><pre><code class="language-c">while (i &lt; bin_size)
{
    u_int32_t size = MIN(BY2PG, bin_size - i);
    r = page_alloc(&amp;p);
    if (r)
        return r;
    bcopy(&amp;bin[i], page2kva(p), size);
    r = page_insert(env-&gt;env_pgdir, p, va + i, PTE_R);
    if (r)
        return r;
    i += MIN(BY2PG, sgsize - i);
}

// i = MIN(ROUND(bin_size, BY2PG),sgsize)
</code></pre><ol start="3"><li><strong>填充后面的0：</strong></li></ol><pre><code class="language-c">/*Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`.
    * hint: variable `i` has the value of `bin_size` now! */
while (i &lt; sgsize)
{
    u_int32_t size = MIN(BY2PG, sgsize - i);
    r = page_alloc(&amp;p);
    if (r)
        return r;
    r = page_insert(env-&gt;env_pgdir, p, va + i, PTE_R);
    if (r)
        return r;
    // bzero(page2kva(p), size); // already bzero in page_alloc
    i += size;
}
return 0;
</code></pre><p>需要注意的就是填充0吧，i在最开始对齐之后就保持BY2PG步进，直到sgsize加载完毕。</p><p>这个在补充指导书里讲的还蛮详细的。在每一阶段，要做的都是申请页面、复制/填0、插入页表，而因为page_alloc就包含了bzero操作，实际补0只要申请页面然后加入页表就可以了。</p><h3>Thinking 3.5</h3><p>结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？ （提示：1、页面大小是多少；2、回顾lab1中的ELF文件解析，什么时候需要自动填充.bss段）</p><p>答：</p><ol><li>若va不对齐，拷贝长度要选择BY2PG - offset和bin_size中的最小值，复制第一页。</li><li>i &lt; bin_size时，如果i &lt; bin_size - BY2PG，那么就以BY2PG步进，复制每一页；如果出现了BY2PG &gt; bin_size - i的情况，那么依然要分配一页的空间。</li><li>如果i仍然小于sgsize，需要继续申请页面并置0。</li></ol><p>.bss 段是全部要置零，也就包含在置零的空间中。</p><h3>Exercise 3.7</h3><p>通过补充的ELF 知识与注释，填充load_elf 函数和load_icode函数。</p><p>load_elf只要填map就好了——</p><pre><code class="language-c">r = map(phdr-&gt;p_vaddr, phdr-&gt;p_memsz, phdr-&gt;p_offset + binary, phdr-&gt;p_filesz, user_data);
</code></pre><p>这里的bin为什么是phdr-&gt;p_offset + binary呢？</p><pre><code class="language-c">typedef struct {
    Elf32_Word p_type; /* Segment type */
    Elf32_Off p_offset; /* Segment file offset */
    Elf32_Addr p_vaddr; /* Segment virtual address，
    这就是需要映射的虚拟地址*/
    Elf32_Addr p_paddr; /* Segment physical address */
    Elf32_Word p_filesz; /* Segment size in file */
    Elf32_Word p_memsz; /* Segment size in memory */
    Elf32_Word p_flags; /* Segment flags */
    Elf32_Word p_align; /* Segment alignment */
} Elf32_Phdr;
</code></pre><p>参考ELF手册，此数据成员给出本段内容在文件中的位置，即段内容的开始位置相对于文件开头的偏移量。</p><p>load_icode首先设置用户用户栈，分配一页的空间在<!-- -->[UTOP，UTOP-BY2PG]<!-- -->区间。而我的问题就在于page_insert写错……啊啊啊啊啊理解不深入真的太惨了。</p><pre><code class="language-c">/*Step 1: alloc a page. */
r = page_alloc(&amp;p);
if (r)
    panic(&quot;page_alloc in load_icode failed&quot;);

/*Step 2: Use appropriate perm to set initial stack for new Env. */
/*Hint: Should the user-stack be writable? */
r = page_insert(e-&gt;env_pgdir, p, USTACKTOP - BY2PG, perm);
if (r)
    panic(&quot;page_insert in load_icode failed&quot;);
</code></pre><p>然后调用load_elf，套娃~</p><pre><code class="language-c">/*Step 3:load the binary using elf loader. */
r = load_elf(binary, size, &amp;entry_point, (void *)e, load_icode_mapper);
if (r)
    panic(&quot;load_elf in load_icode failed&quot;);

/*Step 4:Set CPU&#x27;s PC register as appropriate value. */
e-&gt;env_tf.pc = entry_point;
</code></pre><p>最后记得设置PC寄存器到程序入口。关于这里引用学长的分析——</p><blockquote><p>那么下面来解释一下为什么这里用的是page2kva(page)，而不是用与UTEXT有关的数值？</p><p>首先我们解释过了，UTEXT+0xb0是程序的入口，何谓入口？比如我们现在启动了一个进程，我们如何能从哪里开始，该怎样跑呢？这取决于我们run一个进程前的准备工作，当然这个工作在进程切换时也需要做，其中很重要的一点就是保存pc。这一点很重要，极其重要。如果是第一次run一个进程的时候，我们的pc是务必要被设置为UTEXT+0xb0的，这也是在env_alloc里面所做的工作。之后有一些我们没有关注过的汇编程序就会默默地根据我们设置的pc去找我们的程序入口，默默地执行，遇到中断默默地保存，切换。于是就这样完成了进程的运行与切换大计。</p><p>那么我们这里bcopy不能用UTEXT来copy是因为，我们这里还没开始一个进程，没有其页目录来作为基址，所以你现在copy到的地方也只是内核的UTEXT处。我们都知道在env_run时要切换页目录，切换为进程的页目录后，我们就再也找不到这部分copy的东西了（因为env_setup_vm只复制内核页目录ULIM以上的部分）。所以我们要copy到的地方一定是要内核和每个进程均可以访问的，显而易见要copy到ULIM以上的部分。即page2kva(page)这个地方。当然，你可以选择先切换到进程的页目录，然后copy，然后在结束的时候切换回内核的页目录，再次强调一点，bcopy也好，bzero也好，在我们编写的程序中，只要是作为访问地址来使用的（什么叫作为地址来使用，就是可以取其内容的 *address)，全部都使用的是虚拟地址！</p></blockquote><h3>Thinking 3.6</h3><p>思考上面这一段话，并根据自己在lab2 中的理解，回答：</p><ul><li>我们这里出现的” 指令位置” 的概念，你认为该概念是针对虚拟空间，还是物理内存所定义的呢？</li><li>你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？</li></ul><p>答：</p><p>(1) 虚拟空间。当我们运行进程时，CPU 将自动从pc所指的位置开始执行二进制码，此时的空间是连续的，而虚拟空间对应的物理内存可能是不连续的，因此是虚拟空间。</p><p>(2) 一样。每个进程都有独立的虚拟空间，因此entry_point其值对于每个进程一样，是程序入口；但entry_point实际映射的物理地址不同。</p><h2>创建进程</h2><p>终于结束了最难的部分……下面来看看进程的创建吧！</p><h3>Exercise 3.8</h3><p>完成env_create 函数与env_create_priority 的填写。</p><pre><code class="language-c">void env_create_priority(u_char *binary, int size, int priority)
{
    struct Env *e;
    /*Step 1: Use env_alloc to alloc a new env. */
    int r;
    r = env_alloc(&amp;e, 0);
    if (r)
        panic(&quot;env_alloc in env_create_priority failed&quot;);
    /*Step 2: assign priority to the new env. */
    e-&gt;env_pri = priority;

    /*Step 3: Use load_icode() to load the named elf binary,
      and insert it into env_sched_list using LIST_INSERT_HEAD. */
    load_icode(e, binary, size);
    
    LIST_INSERT_HEAD(&amp;env_sched_list[0], e, env_sched_link);
}
</code></pre><p>先用env_alloc创建一个新进程，由于没有父进程，所以就把父进程id设置为0；然后设置进程优先级；最后调用load_icode载入二进制程序文件。为了调度，将进程插入到env_sched_list<!-- -->[0]<!-- -->中。</p><pre><code class="language-c">void env_create(u_char *binary, int size)
{
    /*Step 1: Use env_create_priority to alloc a new env with priority 1 */
    env_create_priority(binary, size, 1);
}
</code></pre><p>env_create只要调用env_create_priority就好了。</p><h3>Exercise 3.9</h3><p>在这次实验中我们没有用到env_create，而是用了一个宏——</p><pre><code class="language-c">#define ENV_CREATE_PRIORITY(x, y) \
{\
        extern u_char binary_##x##_start[]; \
        extern u_int binary_##x##_size;\
        env_create_priority(binary_##x##_start, \
                (u_int)binary_##x##_size, y);\
}
</code></pre><p><code>ENV_CREATE_PRIORITY(x,y)</code>等价于<code>env_create_priority(binary_x_start,binary_x_size,y)</code>。</p><h2>进程运行与切换</h2><p>env_run是进程运行使用的基本函数，它包括两部分：</p><ul><li>保存当前进程上下文(如果当前没有运行的进程就跳过这一步)</li><li>恢复要启动的进程的上下文，然后运行该进程。</li></ul><h3>Thinking 3.7</h3><p>思考一下，要保存的进程上下文中的env_tf.pc的值应该设置为多少？为什么要这样设置？</p><p>答：</p><p>要保存的进程上下文中的env_tf.pc的值应该设置为cp0_epc，从而从被中断的指令继续运行。</p><h3>Thinking 3.8</h3><p>思考TIMESTACK 的含义，并找出相关语句与证明来回答以下关于TIMESTACK 的问题：</p><ul><li>请给出一个你认为合适的TIMESTACK 的定义</li><li>请为你的定义在实验中找出合适的代码段作为证据(请对代码段进行分析)</li><li>思考TIMESTACK 和第18 行的KERNEL_SP 的含义有何不同</li></ul><p>答：</p><p>(1) TIMESTACK以下<code>[TIMESTACK - sizeof(struct Trapframe), TIMESTACK)</code>的空间存储着异常发生时的寄存器信息，是时钟中断后的存储区。</p><p>(2) 在include/stackframe.h中可以找到：</p><pre><code class="language-c">.macro get_sp
    mfc0    k1, CP0_CAUSE
    andi    k1, 0x107C
    xori    k1, 0x1000
    bnez    k1, 1f
    nop
    li  sp, 0x82000000
    j   2f
    nop
1:
    bltz    sp, 2f
    nop
    lw  sp, KERNEL_SP
    nop

2:  nop


.endm
</code></pre><p>其中的0x82000000即TIMESTACK的值。本次实验产生的都是时钟中断，进行的是<code>li	sp, 0x82000000</code>的操作，因此是时钟中断后的存储区。</p><p>(3) TIMESTACK是时钟中断后的存储区，而KERNEL_SP应当是系统调用后的存储区。</p><h3>Exercise 3.10</h3><p>根据补充说明，填充完成env_run 函数。</p><pre><code class="language-c">void env_run(struct Env *e)
{
    /*Step 1: save register state of curenv. */
    /* Hint: if there is an environment running, you should do
    *  switch the context and save the registers. You can imitate env_destroy() &#x27;s behaviors.*/
    if (curenv)
    {
        struct Trapframe *old;
        old = (struct Trapframe *)(TIMESTACK - sizeof(struct Trapframe));
        bcopy(old, &amp;(curenv-&gt;env_tf), sizeof(struct Trapframe));
        curenv-&gt;env_tf.pc = curenv-&gt;env_tf.cp0_epc;
    }
    // 保存当前进程的上下文信息，设置当前进程上下文中的 pc 为合适的值。

    /*Step 2: Set &#x27;curenv&#x27; to the new environment. */
    curenv = e;
    // 把当前进程 curenv 切换为需要运行的进程。

    /*Step 3: Use lcontext() to switch to its address space. */
    lcontext(e-&gt;env_pgdir);
    // 调用 lcontext 函数，设置进程的地址空间。

    /*Step 4: Use env_pop_tf() to restore the environment&#x27;s
     * environment   registers and return to user mode.
     *
     * Hint: You should use GET_ENV_ASID there. Think why?
     * (read &lt;see mips run linux&gt;, page 135-144)
     */
    env_pop_tf(&amp;(curenv-&gt;env_tf), GET_ENV_ASID(curenv-&gt;env_id));
    // 调用 env_pop_tf 函数，恢复现场、异常返回。
}
</code></pre><p>env_pop_tf把env里的tf压到寄存器中，进行返回，需要先设置lcontext切换进程页目录。</p><h2>异常的分发</h2><p>这一部分表面要做复读机，但代码理解起来好痛苦……啊啊啊我已经写了两天这个博客啦，这也太难过了为什么这么多不会根本理解不完啊……</p><h3>Exercise 3.11</h3><p>将异常分发代码填入boot/start.S 合适的部分，</p><pre><code class="language-c">.section .text.exc_vec3
NESTED(except_vec3, 0, sp)
    .set noat 
    .set noreorder
1:
    mfc0 k1,CP0_CAUSE
    la k0,exception_handlers
    andi k1,0x7c
    addu k0,k1
    lw k0,(k0)
    nop
    jr k0
    nop
END(except_vec3)
.set at
</code></pre><p>这段异常分发代码的作用流程简述如下：</p><ol><li>取得异常码，这是区别不同异常的重要标志。</li><li>以得到的异常码作为索引去exception_handlers 数组中找到对应的中断处理函数，后文中会有涉及。</li><li>跳转到对应的中断处理函数中，从而响应了异常，并将异常交给了对应的异常处理函数去处理</li></ol><h3>Exercise 3.12</h3><p>将lds 代码补全使得异常后可以跳到异常分发代码，0x80000080地址存放的是异常处理程序的入口地址。</p><pre><code class="language-c">. = 0x80000080;
.except_vec3 : {
    *(.text.exc_vec3)
}
</code></pre><p>这里将.text.exec_vec3 放到0x80000080，一旦异常发生，就会引起该段代码的执行。</p><h2>异常向量组</h2><p>填空题：阅读see-mips-run-linux中的关于异常码与异常类型的对应关系部分。</p><p>算数异常(OV)如加法溢出、减法溢出等异常，其对应的异常码为12。（来源：P78）</p><h2>时钟中断</h2><p>初始化时钟主要是在kclock_init 函数中，该函数主要调用set_timer函数。</p><h3>Exercise 3.13</h3><p>补充kclock_init 函数。</p><pre><code class="language-c">/*** exercise 3.13 ***/
void
kclock_init(void)
{
    // hint: use set_timer()
    set_timer();
}
</code></pre><p>虽然不是很理解但只要填就对了呢……</p><h3>Thinking 3.9</h3><p>阅读 kclock_asm.S  文件并说出每行汇编代码的作用。</p><p>答：</p><pre><code class="language-c">.macro  setup_c0_status set clr // 定义宏setup_c0_status，传入set置位和clr清零形参
    .set    push                // 保存现场
    mfc0    t0, CP0_STATUS      // 读CP0_STATUS的值到t0寄存器      
    or  t0, \set|\clr           // t0=(t0|set|clr)，将set为1的置1
    xor t0, \clr                // t0= xor(t0,clr)，将clr为1的置0
    mtc0    t0, CP0_STATUS      // 将t0寄存器写回CP0_STATUS
    .set    pop                 // 恢复现场
.endm                           // 结束宏语句            

    .text                       // 代码段
LEAF(set_timer)                 // LEAF定义不调用其他函数的叶子函数set_timer

    li t0, 0x01                 // t0设为1
    sb t0, 0xb5000100           // 设置实时钟中断的频率为1秒1次
    sw  sp, KERNEL_SP           // 保存栈的值到KERNEL_SP
setup_c0_status STATUS_CU0|0x1001 0 // 设置CP0_STATUS
    jr ra                       // 函数返回

    nop                         // 延迟槽
END(set_timer)                  // 结束函数
</code></pre><h2>进程调度</h2><p>最后一章了！</p><h3>Exercise 3.14</h3><p>根据注释，完成sched_yield 函数的补充，并根据调度方法对 env.c 中的部分函数进行修改，使得进程能够被正确调度。</p><pre><code class="language-c">void sched_yield(void)
{
    static int count = 0; // remaining time slices of current env
    static int point = 0; // current env_sched_list index
    static struct Env *e;

    while (count == 0)
    {
        if (LIST_EMPTY(&amp;env_sched_list[point]))
        {
            point = 1 - point;
        }
        e = LIST_FIRST(&amp;env_sched_list[point]);
        count = curenv-&gt;env_pri;
        LIST_REMOVE(e, env_sched_link);
        LIST_INSERT_HEAD(&amp;env_sched_list[1 - point], e, env_sched_link);
    }
    count--;
    env_run(e);
}
</code></pre><p>参考Ausar的写法写的，马上的Thinking 3.10就要让我重新思考一遍。</p><h3>Thinking 3.10</h3><p>阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</p><p>答：</p><ol><li>首先在set_timer设置实时钟中断的频率，实验中为1秒1次。</li><li>一旦实时钟中断产生，就会触发MIPS 4号中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。</li><li>通过text.exc<em>vec3代码段的分发，调用handle</em> int 函数来处理实时钟中断。</li><li>在handle<em> int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer</em> irq。</li><li>在timer<em> irq里跳转到sched</em> yield，如果当前进程的时间片用完了，则切换到下一个进程。</li></ol><h2>总结</h2><p>啊，抄完了，虚脱的感觉，我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>我就是啥也不会的FW。</p><p>认真你就输了。</p><p>工作你就输了。</p><p>我输了。</p><p align="right">2020/4/25 21:02</p><p align="right">无可救药的码呆茶</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week8]]></title>
        <id>《航空航天概论》Week8</id>
        <link href="https://mondaycha.github.io/blog/2020/04/23/《航空航天概论》Week8"/>
        <updated>2020-04-23T20:48:43.000Z</updated>
        <summary type="html"><![CDATA[爱课程 6.1 液体火箭发动机]]></summary>
        <content type="html"><![CDATA[<h2>爱课程 6.1 液体火箭发动机</h2><p>今天课堂的内容是航天器发展的基础——火箭发动机，首先是液体火箭发动机，有挤压式和泵式的推进剂输送系统，推力室是火箭发动机的关键部件，液体火箭发动机的两种推进剂是放在储箱里面的。</p><h2>爱课程 6.2 固体火箭发动机</h2><p>在这节课我了解到，固体火箭发动机的结构更加简单。固体火箭发动机的推力矢量控制是很重要的一个因素：有燃气舵、二次喷射技术、双向摆动喷管、全轴摆动喷管等技术。发动机还需要推力终止装置，进行释压。推力大小上，有一维药柱、二维药柱、三维药柱等以进行控制。</p><h2>爱课程 6.3 非常规火箭发动机</h2><p>液体火箭发动机和固体火箭发动机都属于化学推进系统，效率低、比冲低，因此各国也在大力发展非化学推进系统的非常规火箭发动机。如核推进、太阳能推进、电推进（静电推进、电磁推进等）等。</p><h2>学堂在线 8 导航、制导和测控技术</h2><p>在这节课我了解到，导航自古存在，远古时代就有恒星导航，指南针的发明也是早期的导航手段。导航可以提供的信息包括位置信息、方位信息、速度信息等。卫星导航系统一般包括卫星系统、地面站组、用户设备等组成部分，北斗导航是世界四大卫星导航系统中唯一具有短报文通信功能的导航系统。</p><h2>火箭发动机的排放是否存在污染问题？为什么？</h2><p>存在。固体火箭发动机在燃烧的时候，会产生氧化铝固体颗粒粉尘以及盐酸雨雾。火箭烟尘积聚在平流层上部，粒子吸收太阳光。他补充说，这种积聚会加热平流层上层，改变化学反应速率，并可能导致臭氧损失。在燃烧不完全下，也完全可能产生一些其他对环境有污染的燃烧副产物。</p><p>当航天行业成为更加平民化、更加普及的产业时，相信这些问题也将得以克服。</p><h2>为什么说景象匹配的导航精度优于地形匹配？</h2><p>地形匹配制导技术的工作原理是在导弹发射区与目标区之间选择几个特征明显的标志区，通过遥测、遥感手段，按其地面坐标点标高数据绘制成数字地图；景象匹配导航技术利用弹载“景象匹配区域相关器”获取目标区域景物图像数字地图，将其与预存的参考图像进行相关处理，从而确定导弹相对于目标的位置。从数字地图构建上景象匹配优于地形匹配，因此景象匹配的导航精度优于地形匹配。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week7]]></title>
        <id>《航空航天概论》Week7</id>
        <link href="https://mondaycha.github.io/blog/2020/04/16/《航空航天概论》Week7"/>
        <updated>2020-04-16T20:48:43.000Z</updated>
        <summary type="html"><![CDATA[爱课程 4.3 航天器的飞行原理]]></summary>
        <content type="html"><![CDATA[<h2>爱课程 4.3 航天器的飞行原理</h2><p>航天器遵循天体力学（主要是轨道动力学的支配），与航空不一样，航天器的出现使人类的活动范围从地球大气层扩大到广阔无垠的宇宙空间，。人造天体与自然天体的最大区别是轨道机动。</p><h2>爱课程 5.1 活塞式发动机</h2><p>活塞式发动机目前主要用于小型低速飞机。活塞式发动机主要由气缸、活塞、连杆、曲轴、气门机构、螺旋桨减速器、机匣等组成。除了这些主要部件外，还需要若干辅助系统。除此以外，另外一类就是空气喷气发动机。</p><h2>爱课程 5.2 涡轮喷气发动机</h2><p>超音速进气道中调节锥的作用是产生斜激波，降低气流速度。现在用的最多的是轴流式发动机，逐级使压力增大，在燃烧室，为了使空气与燃料稳定接触，通过喷嘴雾化和涡轮将高温等转变为机械能。用在歼击机上的涡轮风扇发动机的涵道比与民用飞机上的相比一般要小。</p><h2>爱课程 5.3 其他发动机</h2><p>在这一节我学习到，对于一些速度并不快或高速的情况，除了活塞式发动机、涡轮喷气发动机，可以使用其他类型的航空发动机，来平摊经济成本。冲压喷气发动机由进气道、燃烧室、尾喷管组成。</p><h2>学堂在线 7 发射与回收技术</h2><p>航天器发射中，需要发射窗口，发射窗口需要满足很多条件。航天器的再入方式也有多种，纯弹道式在技术上容易实现，采用半弹道式再入方式再入的航天器包括神舟系列飞船和联盟号飞船，另外还有滑翔式。</p><h2>为什么航天器要在发射窗口发射？</h2><p>发射窗口是指运载火箭发射比较合适的一个时间范围，由于每个航天器承担的任务不同，航天器上安装的仪器，设备使用要求不同，它们对发射窗口提出了种种要求和限制条件，而这些要求有时又互相矛盾，因此选择什么时间发射就必须考虑各方面的要求，经综合平衡后选择一个比较合适的发射窗口。</p><h2>喷气式发动机产生推力是否符合牛顿第三定律？</h2><p>当然符合。牛顿第三定律揭示，作用在一物体上的每一个力都有一方向相反大小相等的反作用力。喷气发动机用类似于发动机/螺旋桨组合的方式产生推力。二者均靠将大量气体向后推来推进飞机。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[冯如杯创业大赛-风险投资部分]]></title>
        <id>冯如杯创业大赛-风险投资部分</id>
        <link href="https://mondaycha.github.io/blog/2020/04/16/冯如杯创业大赛-风险投资部分"/>
        <updated>2020-04-16T20:48:43.000Z</updated>
        <summary type="html"><![CDATA[风险因素]]></summary>
        <content type="html"><![CDATA[<h2>风险因素</h2><p>技术风险</p><p>市场风险</p><p>管理风险</p><p>财务风险</p><p>其他不可预见的风险</p><h2>风险投资的退出方式</h2><p>股票上市：依照商业计划的分析，公司上市的可能性做出分析，对上市的前提条件做出说明</p><p>股权转让：投资商可以通过股权转让的方式收回投资</p><p>股权回购：依照事业商业计划的分析，公司对实施股权回购计划应向投资者说明</p><p>利润分红：投资商可以通过公司利润分红达到。收回投资的目的，按照本商业计划的分析，公司对实施股权利润分红计划应向投资者说明</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[冯如杯创业大赛第一次修改意见]]></title>
        <id>冯如杯创业大赛第一次修改意见</id>
        <link href="https://mondaycha.github.io/blog/2020/04/16/冯如杯创业大赛第一次修改意见"/>
        <updated>2020-04-16T20:48:43.000Z</updated>
        <summary type="html"><![CDATA[1、文中列举的数据和插图最好都说明来源]]></summary>
        <content type="html"><![CDATA[<p>1、文中列举的数据和插图最好都说明来源 </p><hr/><p>2、专有名词在策划书中第一次出现时需要用全称非缩写，增强整体可读性 </p><hr/><p>3、竞争产品分析中，需要对产品进一步剖析，通过现有产品的局限突出自己产品的优势 </p><hr/><p>4、市场分析角度不够广，还可以加入对目标顾客群体的分析、营销策略的选择等等 </p><hr/><p>5、前一半是科技论文的写法，需要进行修改，目前在策划书里显得生硬</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 OO 第二单元总结]]></title>
        <id>2020 OO 第二单元总结</id>
        <link href="https://mondaycha.github.io/blog/2020/04/09/2020-OO-第二单元总结"/>
        <updated>2020-04-09T17:20:43.000Z</updated>
        <summary type="html"><![CDATA[一、设计策略]]></summary>
        <content type="html"><![CDATA[<h1>只要跑得够快即使从头关到尾你也喜欢吗</h1><h2>一、设计策略</h2><h3>1.1 总体策略概述</h3><p>在多线程的协同和同步控制方面，我三次作业都是采用生产者/消费者模式（还憨憨地在内部分了customer、producer、tray的包……方便自己看orz）。</p><p>其中“生产者”为输入线程，将读取到的Request放到“货架”Scheduler上；“消费者”则是每个电梯线程，以一种类似观察者模式的方式追踪“货架”Scheduler的变化。之所以说是类似，是因为我每次都是在电梯自身状态发生改变后获取当前的“货架”Scheduler内容，而不是Scheduler一有更新就通知Elevator（也可能这是某种设计模式但我不知道）。</p><p>这样设计的好处是，我只有Scheduler类的方法是上锁的，其他类调用时不需要考虑是否会引发线程不安全问题，写起来很方便；坏处是我现在还不是很熟悉lock的用法……</p><p>电梯内部则采用状态模式，设置了WAIT, OPEN, CLOSE, CLOSED, PASS, UP, DOWN多个枚举状态类型。</p><p>而对于对于存储人群信息的队列，我采用了单独的WaitMul、ElevatorMul封装<code>HashMap&lt;Integer, Queue&lt;Person&gt;&gt;</code>的方式，指向来去楼层，并配置各种方法，外部可以对Multitude进行塞人取人的操作，Multitude内部的存储方式是不透明的。</p><h3>1.2 性能优化策略</h3><h4>1.2.1 第五次作业</h4><p>性能上，本次作业我采用的是在SSTF的基础上，自己瞎琢磨的“选择最短路径”贪心算法，比较电梯原目标与反方向新目标的最短距离：</p><pre><code class="language-java">private static int minDistance(int cntFloor, int goalFloor, int tmpFloor, int tmpGoal) {
    int dis1 = Math.abs(goalFloor - cntFloor) + Math.abs(goalFloor - tmpFloor) 
        + Math.abs(tmpGoal - tmpFloor);
    int dis2 = Math.abs(cntFloor - tmpFloor) + Math.abs(tmpGoal - tmpFloor) 
        + Math.abs(goalFloor - tmpGoal);
    if (dis1 &gt; dis2) {
        return tmpGoal;
    } else {
        return goalFloor;
    }
}
</code></pre><p>然而这种方法有很大的缺陷……在某些特定楼层会有小几率出现反复横跳……最后逼近截止时间一直在改，又增加了防止锁死的机制（当检测到死循环时弃用这一优化），代价是拉低了性能，最后性能分16多。</p><h4>1.2.2 第六次作业</h4><p>感谢CJB，他在第五次作业得到很高的性能分，也慷概地将他的算法分享给了我们——</p><blockquote><p>sstf的基础上，当电梯里有人时候，选择最近上楼或最近出楼层的，就行，其他不变。</p><p>​		——《CJB语录》第二卷上册</p></blockquote><p>所以在第六次多电梯，我的单电梯也采用了相同（也许）的策略。</p><pre><code class="language-java">/***************
 * SSTF
 * *************/
private int getGoalFloor(int cnt, boolean isEleFull) {
    // 传入参数：电梯当前楼层、电梯满员状态
    if (elevator.isEmpty()) {
        return scheduler.getMinDisWhenEmpty(cnt, eleId);
        // 电梯为空时，按情况进入wait状态
    } else {
        int inReq = elevator.getMinDisReq(cnt, goalFloor);
        if (isEleFull) {
            return inReq;
            // 电梯满员时，不考虑外部新请求
        }
        int outReq = scheduler.getMinDis(cnt, inReq, eleId);
        if (outReq == LOST) {
            return inReq;
            // 外部没有请求，直接相应内部请求
        } else {
            return Math.abs(outReq - cnt) &lt; Math.abs(inReq - cnt) ? outReq : inReq;
            // 选择最近上楼或最近出电梯的
        }
    }
}
</code></pre><p>射射CJB！CJB, YYDS! 最后性能分19多。</p><h4>1.2.3 第七次作业</h4><p>在第七次作业沿用了CJB的SSTF策略以及部分，为啥不用LOOK呢？我感觉这种性能分权重还是优先接人收益高。</p><p>而对于换乘，我用到了两组数组：</p><pre><code class="language-java">private static final int[][] canStopOfType = {
    /*********1***********************9****************15****************/
    {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
    {0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0}
    /*********1***********************9****************15****************/
};
private static final int[][] mustFromName = {
    /********(1)**********************9***************(15)***************/
    {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0}
    /*********1***********************9****************15****************/
};
/*** A B C ***/
</code></pre><p><code>canStopOfType</code>存储的是电梯可以停的楼层，<code>mustFromName</code>数组则是电梯必须接受这一楼层的请求（1和15层三个类型都可以，就让电梯自由竞争）。</p><p>换乘时会把人从电梯重新塞进等待队列，所以之后就与没有换乘的情况一样了。其实感觉5层作为换乘站也不错……后来不想改了……最后性能分19多。</p><h2>二、可扩展性</h2><p>(2)从功能设计和性能设计的平衡方面，更细和总结自己<strong>第三次作业</strong>架构设计的可扩展性</p><p>可扩展性方面，这一次一开始就希望能为后续的扩展留好迭代空间，在正式开始之前读了好多学长的博客，其中PMXM助教的博客给了我很大启发：</p><blockquote><p><a href="https://www.cnblogs.com/i-love-ange-and-oo-forever/p/10756828.html">https://www.cnblogs.com/i-love-ange-and-oo-forever/p/10756828.html</a></p></blockquote><p>最后迭代开发的效果还算马马虎虎……但每次加入新功能都会引入不少Bug，测试花的时间很多。</p><h3>功能设计</h3><p>电梯是一台有限状态机，有WAIT, OPEN, CLOSE, CLOSED, PASS, UP, DOWN一共7种状态，三次作业的状态转移图都差不多，如下：![](G:\OneDrive\OneDrive - buaa.edu.cn\MWD\学习\面向对象设计与构造\博客2\电梯流程图.jpg)</p><p>这样做的优势是每部电梯自身都独挡一面，人可以随时选择最近的电梯、呼叫多部电梯，方便增加电梯数量的扩展。</p><h3>性能设计</h3><p>根据上面那个丑哭的状态转移图可知，在CLOSED, PASS两种状态下会调用获取目标楼层的方法，因此我所有的优化都只要写在获取目标楼层的方法getGoalFloor中，同样有利于迭代开发，比如第七次作业的getGoalFloor方法和前面提到过的第六次作业getGoalFloor方法比较，完全没有变化。</p><h3>SOLID原则分析</h3><p>以第七次作业分析：</p><ul><li>SRP原则：感觉还行，RequestParser将读取到的PersonRequest放到Scheduler上，ElevatorRequest则传入Controller用于创造新电梯；ElevatorController运送Scheduler上的乘客。</li><li>OCP原则：电梯封装的好，便于扩展数量，感觉这方面还行。</li><li>LSP原则：在第五次作业，对于WaitMul、ElevatorMul采用了继承的方式，但后来在第六、七次作业的优化中取消……所以应该没有怎么实现。</li><li>LOD原则：RequestParser与ElevatorController通过Scheduler转发调用，有独立性。</li><li>ISP原则：在本单元作业没有创建接口，部分线程实现了Runnable接口。三种电梯我是采用构造时传参的方式，配置工厂类Controller用于创造新电梯，所以也就没有实现接口的必要了。</li><li>DIP原则：感觉做的还可以……因为我都是人自己刷新要乘坐的电梯（但是因为没有给人开线程，所以都是由电梯调用人的选电梯方法，其实实现上来说更类似于电梯抢人），避免了为了优化带来的倒置依赖。</li></ul><h2>三、度量分析</h2><h3>3.1 第五次作业</h3><p>▼ 基本结构图，MainClass启动输入线程和电梯线程，外部的楼层等待人群和内部的电梯货运人群采用了继承抽象类人群的方式，将对人的存储方式封装起来。</p><p>▼ 时序图，用插件自动生成的，感觉不是很准确……感觉参看我的有限状态机图更好一点……</p><p>▼ 依赖关系，还可以。</p><table><thead><tr><th>Class</th><th>Cyclic</th><th>Dcy</th><th>Dcy*</th><th>Dpt</th><th>Dpt*</th></tr></thead><tbody><tr><td>homework.MainClass</td><td>0</td><td>3</td><td>10</td><td>0</td><td>0</td></tr><tr><td>homework.custumer.Elevator</td><td>0</td><td>4</td><td>5</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.Elevator.Status</td><td>0</td><td>0</td><td>0</td><td>2</td><td>3</td></tr><tr><td>homework.custumer.ElevatorController</td><td>0</td><td>3</td><td>8</td><td>1</td><td>1</td></tr><tr><td>homework.producer.RequestParser</td><td>0</td><td>2</td><td>5</td><td>1</td><td>1</td></tr><tr><td>homework.tray.MulInside</td><td>0</td><td>3</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.tray.MulOutside</td><td>0</td><td>3</td><td>3</td><td>1</td><td>4</td></tr><tr><td>homework.tray.Multitude</td><td>0</td><td>2</td><td>2</td><td>4</td><td>7</td></tr><tr><td>homework.tray.Multitude.Type</td><td>0</td><td>0</td><td>0</td><td>3</td><td>8</td></tr><tr><td>homework.tray.Person</td><td>0</td><td>0</td><td>0</td><td>6</td><td>8</td></tr><tr><td>homework.tray.Scheduler</td><td>0</td><td>3</td><td>4</td><td>3</td><td>3</td></tr></tbody></table><p>▼ 复杂度，ElevatorController作为一台大状态机以及“抢人”的独立个体，自身的run方法作为状态机判断条件很多，圈复杂度也飘红；获取最优目标的getGoal方法这次写的很复杂……</p><table><thead><tr><th>Method</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>homework.MainClass.main(String[])</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.Elevator()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.close(HashMap&lt;Person,  Integer&gt;)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getCurrentFloor()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getMinTimeReq(int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getStatus()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.isEmpty()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.move(boolean)</td><td>1</td><td>4</td><td>4</td></tr><tr><td>homework.custumer.Elevator.open()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.setStatus(Status)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.sleepTime(int)</td><td>1</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorController.ElevatorController(Scheduler)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.ElevatorController.getGoal1(int)</td><td>5</td><td>3</td><td>5</td></tr><tr><td>homework.custumer.ElevatorController.getGoal2(int)</td><td>6</td><td>3</td><td>7</td></tr><tr><td>homework.custumer.ElevatorController.getGoalFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.ElevatorController.getGoalFloor2(int)</td><td>2</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.ElevatorController.moveJudge(int)</td><td>2</td><td>2</td><td>6</td></tr><tr><td>homework.custumer.ElevatorController.run()</td><td>2</td><td>8</td><td>15</td></tr><tr><td>homework.custumer.ElevatorController.setDie2(boolean)</td><td>2</td><td>1</td><td>10</td></tr><tr><td>homework.producer.RequestParser.RequestParser(Scheduler)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.producer.RequestParser.run()</td><td>3</td><td>3</td><td>4</td></tr><tr><td>homework.tray.MulInside.MulInside()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.MulInside.addInsideMul(HashMap&lt;Person,  Integer&gt;)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.MulInside.makeMultitudeOut(int)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.MulOutside.MulOutside()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.MulOutside.addOutsideMul(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.Multitude(Type)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.Multitude.cloneMulInFloor(int)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.Multitude.convertFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.getList()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.getMaxFloor()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.getMinDisFloor(int,int,int)</td><td>14</td><td>3</td><td>17</td></tr><tr><td>homework.tray.Multitude.getMinFloor()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.getMulInFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.isEmpty()</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.tray.Multitude.isEmptyFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Multitude.removeMulInFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.Person(PersonRequest)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.Person(int,int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.clone()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.equals(Object)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.Person.getFr()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getTo()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.hashCode()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.makePersonIn()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.makePersonOut()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.moveUp()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.Scheduler()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.getMinDisFloor(int,int)</td><td>1</td><td>4</td><td>4</td></tr><tr><td>homework.tray.Scheduler.getOtherReq(int,int)</td><td>7</td><td>11</td><td>13</td></tr><tr><td>homework.tray.Scheduler.hasPassReqInFloor(int,int)</td><td>4</td><td>3</td><td>4</td></tr><tr><td>homework.tray.Scheduler.hasRequestInFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.makeMulIn(int)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.Scheduler.minDistance(int,int,int,int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.Scheduler.readNewRequest(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.stopReading()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.stopTask()</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>类复杂度上，ElevatorController飘红。</p><table><thead><tr><th>homework.MainClass</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>homework.custumer.Elevator</td><td>1.3</td><td>13</td></tr><tr><td>homework.custumer.Elevator.Status</td><td>n/a</td><td>0</td></tr><tr><td>homework.custumer.ElevatorController</td><td>5.12</td><td>41</td></tr><tr><td>homework.producer.RequestParser</td><td>2</td><td>4</td></tr><tr><td>homework.tray.MulInside</td><td>1.67</td><td>5</td></tr><tr><td>homework.tray.MulOutside</td><td>1</td><td>2</td></tr><tr><td>homework.tray.Multitude</td><td>2.55</td><td>28</td></tr><tr><td>homework.tray.Multitude.Type</td><td>n/a</td><td>0</td></tr><tr><td>homework.tray.Person</td><td>1.1</td><td>11</td></tr><tr><td>homework.tray.Scheduler</td><td>2.6</td><td>26</td></tr></tbody></table><h3>3.2 第六次作业</h3><p>▼ 基本结构图，MainClass启动输入线程和多个电梯线程，这次放弃了继承，并且优化了传递人员的方式，降低了耦合性。</p><p>▼ 时序图。</p><p>▼ 依赖关系，这次的架构是在第五次的基础上修改，也差不多。</p><table><thead><tr><th>Class</th><th>Cyclic</th><th>Dcy</th><th>Dcy*</th><th>Dpt</th><th>Dpt*</th></tr></thead><tbody><tr><td>homework.MainClass</td><td>0</td><td>3</td><td>9</td><td>0</td><td>0</td></tr><tr><td>homework.custumer.Controller</td><td>0</td><td>2</td><td>7</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator</td><td>0</td><td>3</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.custumer.Elevator.Status</td><td>0</td><td>0</td><td>0</td><td>2</td><td>4</td></tr><tr><td>homework.custumer.ElevatorController</td><td>0</td><td>3</td><td>6</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul</td><td>0</td><td>1</td><td>1</td><td>1</td><td>4</td></tr><tr><td>homework.producer.RequestParser</td><td>0</td><td>2</td><td>3</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person</td><td>0</td><td>0</td><td>0</td><td>5</td><td>8</td></tr><tr><td>homework.tray.Scheduler</td><td>0</td><td>2</td><td>2</td><td>4</td><td>4</td></tr><tr><td>homework.tray.WaitMul</td><td>0</td><td>1</td><td>1</td><td>1</td><td>5</td></tr></tbody></table><p>▼ 复杂度，几个寻找最优解的方法都较为复杂，比如getBestOne中用了大量循环遍历比较获取最小值，基本复杂度和圈复杂度都比较差。</p><table><thead><tr><th>Method</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>homework.MainClass.main(String[])</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller.Controller(int,Scheduler)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller.run()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.Elevator.Elevator(char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.close()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getCurrentFloor()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getMinDisReq(int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getStatus()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.isEmpty()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.isFull()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.move(boolean)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.open()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.putOne(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.setStatus(Status)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.sleepTime(int)</td><td>1</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.Elevator.updateCurrentFloor(boolean)</td><td>1</td><td>1</td><td>4</td></tr><tr><td>homework.custumer.ElevatorController.ElevatorController(Scheduler,char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.ElevatorController.eleClose(int)</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.custumer.ElevatorController.eleClosed(int,boolean)</td><td>1</td><td>5</td><td>6</td></tr><tr><td>homework.custumer.ElevatorController.eleWait(int,boolean)</td><td>2</td><td>4</td><td>4</td></tr><tr><td>homework.custumer.ElevatorController.getGoalFloor(int,boolean)</td><td>4</td><td>3</td><td>5</td></tr><tr><td>homework.custumer.ElevatorController.run()</td><td>2</td><td>4</td><td>11</td></tr><tr><td>homework.custumer.ElevatorMul.ElevatorMul()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.convertInFloor(int)</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.custumer.ElevatorMul.convertOutFloor(int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.getMinDisReq(int,int)</td><td>8</td><td>3</td><td>12</td></tr><tr><td>homework.custumer.ElevatorMul.isEleEmpty()</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.isEleFull()</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.mulOut(int)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.putOne(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.ElevatorMul.updateEleSize(boolean)</td><td>1</td><td>1</td><td>2</td></tr><tr><td>homework.producer.RequestParser.RequestParser(Scheduler,ElevatorInput)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.producer.RequestParser.run()</td><td>3</td><td>3</td><td>4</td></tr><tr><td>homework.tray.Person.Person(PersonRequest)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.eleIdNull()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.equals(Object)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.Person.getEl()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getFr()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getId()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getMoveDis()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getTo()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getWaitDis()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.hashCode()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.makePersonIn()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.makePersonOut()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.moveUp()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.sameForward(boolean)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.setEl(char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.setWaitDis(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.toString()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.Scheduler()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.failToGetOne(int,char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.getMinDis(int,int,char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.getMinDisWhenEmpty(int,char)</td><td>1</td><td>4</td><td>4</td></tr><tr><td>homework.tray.Scheduler.getOne(int,int,char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.hasRequestInFloor(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.readNewRequest(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.stopReading()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.stopTask()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.updateFlag(int,char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.WaitMul()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.WaitMul.addOutsideMul(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.convertInFloor(int)</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.tray.WaitMul.convertOutFloor(int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.WaitMul.failToGetOne(int,char)</td><td>6</td><td>5</td><td>7</td></tr><tr><td>homework.tray.WaitMul.getBestOne(int,int,char)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.getMinDisFloor(int,int,char)</td><td>8</td><td>3</td><td>12</td></tr><tr><td>homework.tray.WaitMul.hasRequestInFloor(int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.WaitMul.isEmpty()</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.tray.WaitMul.searchBestOne(int,int,int,char)</td><td>4</td><td>7</td><td>9</td></tr><tr><td>homework.tray.WaitMul.updateFlag(int,char)</td><td>1</td><td>4</td><td>4</td></tr></tbody></table><p>类复杂度上，这次的WaitMul设计由于放弃了继承关系，也不是很乐观。</p><table><thead><tr><th>Class</th><th>OCavg</th><th>WMC</th></tr></thead><tbody><tr><td>homework.MainClass</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller</td><td>1.5</td><td>3</td></tr><tr><td>homework.custumer.Elevator</td><td>1.23</td><td>16</td></tr><tr><td>homework.custumer.Elevator.Status</td><td>n/a</td><td>0</td></tr><tr><td>homework.custumer.ElevatorController</td><td>4.17</td><td>25</td></tr><tr><td>homework.custumer.ElevatorMul</td><td>3</td><td>27</td></tr><tr><td>homework.producer.RequestParser</td><td>2</td><td>4</td></tr><tr><td>homework.tray.Person</td><td>1.06</td><td>18</td></tr><tr><td>homework.tray.Scheduler</td><td>1.1</td><td>11</td></tr><tr><td>homework.tray.WaitMul</td><td>3.91</td><td>43</td></tr></tbody></table><h3>3.3 第七次作业</h3><p>▼ 基本结构图，MainClass启动输入线程和电梯线程。</p><p>▼ 时序图，这次加了SafeOutput的封装，虽然不加也没什么影响……</p><p>▼ 依赖关系，同第六次作业。</p><table><thead><tr><th>Class</th><th>Cyclic</th><th>Dcy</th><th>Dcy*</th><th>Dpt</th><th>Dpt*</th></tr></thead><tbody><tr><td>homework.MainClass</td><td>6</td><td>2</td><td>12</td><td>3</td><td>6</td></tr><tr><td>homework.SafeOutput</td><td>0</td><td>0</td><td>0</td><td>2</td><td>9</td></tr><tr><td>homework.custumer.Controller</td><td>6</td><td>2</td><td>12</td><td>1</td><td>6</td></tr><tr><td>homework.custumer.Elevator</td><td>6</td><td>6</td><td>12</td><td>1</td><td>6</td></tr><tr><td>homework.custumer.Elevator.EleTime</td><td>0</td><td>0</td><td>0</td><td>2</td><td>7</td></tr><tr><td>homework.custumer.Elevator.Status</td><td>0</td><td>0</td><td>0</td><td>2</td><td>7</td></tr><tr><td>homework.custumer.ElevatorController</td><td>6</td><td>6</td><td>12</td><td>1</td><td>6</td></tr><tr><td>homework.custumer.ElevatorMul</td><td>0</td><td>1</td><td>2</td><td>1</td><td>7</td></tr><tr><td>homework.producer.RequestParser</td><td>6</td><td>3</td><td>12</td><td>1</td><td>6</td></tr><tr><td>homework.tray.Person</td><td>0</td><td>1</td><td>1</td><td>6</td><td>8</td></tr><tr><td>homework.tray.Scheduler</td><td>6</td><td>2</td><td>12</td><td>4</td><td>6</td></tr><tr><td>homework.tray.WaitMul</td><td>6</td><td>3</td><td>12</td><td>1</td><td>6</td></tr></tbody></table><p>▼ 复杂度，问题和之前的都差不多。</p><table><thead><tr><th>Method</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>homework.MainClass.main(String[])</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.SafeOutput.println(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller.Controller(Scheduler)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller.addElevator(ElevatorRequest)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller.convertType(String)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.custumer.Controller.run()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.Elevator(String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.close()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getCurrentFloor()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getMinDisReq(int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.getStatus()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.inOne(Person)</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.custumer.Elevator.isEmpty()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.isFull()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.move(boolean)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.open()</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.custumer.Elevator.outOne()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.setStatus(Status)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Elevator.sleepTime(EleTime)</td><td>2</td><td>2</td><td>5</td></tr><tr><td>homework.custumer.Elevator.updateCurrentFloor(boolean)</td><td>1</td><td>1</td><td>4</td></tr><tr><td>homework.custumer.ElevatorController.ElevatorController(Scheduler,String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.ElevatorController.eleClose(int)</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.custumer.ElevatorController.eleClosed(int,boolean)</td><td>1</td><td>5</td><td>6</td></tr><tr><td>homework.custumer.ElevatorController.eleOpen(int)</td><td>3</td><td>4</td><td>4</td></tr><tr><td>homework.custumer.ElevatorController.eleWait(int,boolean)</td><td>2</td><td>5</td><td>5</td></tr><tr><td>homework.custumer.ElevatorController.getGoalFloor(int,boolean)</td><td>4</td><td>3</td><td>5</td></tr><tr><td>homework.custumer.ElevatorController.run()</td><td>2</td><td>5</td><td>12</td></tr><tr><td>homework.custumer.ElevatorMul.ElevatorMul(int,int[])</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.convertIn(int)</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.custumer.ElevatorMul.convertOut(int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.getMinDisReq(int,int)</td><td>8</td><td>3</td><td>12</td></tr><tr><td>homework.custumer.ElevatorMul.inOne(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.ElevatorMul.isEleEmpty()</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.isEleFull()</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.mulOut(int)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.outOne(int)</td><td>2</td><td>2</td><td>2</td></tr><tr><td>homework.custumer.ElevatorMul.updateEleSize(boolean)</td><td>1</td><td>1</td><td>2</td></tr><tr><td>homework.producer.RequestParser.RequestParser(Scheduler)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.producer.RequestParser.run()</td><td>3</td><td>5</td><td>6</td></tr><tr><td>homework.tray.Person.Person(PersonRequest)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.eleIdNull()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.equals(Object)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.Person.getEl()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getFr()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getId()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getMoveDis()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getTo()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getTransfer()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.getWaitTime()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.hashCode()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.makePersonIn()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.makePersonOut()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.moveUp()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.sameForward(boolean)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.setEl(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.setFr(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.setTransfer(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.setWaitTime(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.toString()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Person.transferPerson(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.Scheduler()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.failToGetOne(int,String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.getMinDis(int,int,String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.getMinDisWhenEmpty(int,String,int)</td><td>2</td><td>5</td><td>6</td></tr><tr><td>homework.tray.Scheduler.getOne(int,int,String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.hasRequestInFloor(int,String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.readNewRequest(Person)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.stopReading()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.stopTask()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.tranOfTypeIsEmpty(int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.Scheduler.updateFlag(int,String,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.WaitMul()</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.tray.WaitMul.addOutsideMul(Person)</td><td>3</td><td>2</td><td>5</td></tr><tr><td>homework.tray.WaitMul.canStopIn(int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.convertIn(int)</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.tray.WaitMul.convertOut(int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.WaitMul.failToGetOne(int,String,int)</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.tray.WaitMul.getBestOne(int,int,String,int)</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.tray.WaitMul.getDisOfTran(int,int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.getEleType(int)</td><td>3</td><td>1</td><td>3</td></tr><tr><td>homework.tray.WaitMul.getInsideTransfer(int,int)</td><td>4</td><td>4</td><td>14</td></tr><tr><td>homework.tray.WaitMul.getInsideTransfer(int,int,int,int)</td><td>2</td><td>3</td><td>4</td></tr><tr><td>homework.tray.WaitMul.getMinDisFloor(int,int,String,int)</td><td>2</td><td>4</td><td>4</td></tr><tr><td>homework.tray.WaitMul.getMinDisPerson(int,int,String,int)</td><td>4</td><td>2</td><td>8</td></tr><tr><td>homework.tray.WaitMul.getMinDownFloorReq(int,int,String,int)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.tray.WaitMul.getMinUpFloorReq(int,int,String,int)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.tray.WaitMul.getTranOfType(int)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.tray.WaitMul.hasRequestInFloor(int,int,String,int)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.tray.WaitMul.isEmpty()</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.tray.WaitMul.mustTakeIn(int,int)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.tray.WaitMul.removeOneInTran(int)</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.tray.WaitMul.searchInFloor(int,int,int,String,int)</td><td>6</td><td>7</td><td>12</td></tr><tr><td>homework.tray.WaitMul.tranOfTypeIsEmpty(int)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.tray.WaitMul.tranPut(int,int,int)</td><td>1</td><td>4</td><td>4</td></tr><tr><td>homework.tray.WaitMul.tranWait(int,int)</td><td>2</td><td>1</td><td>3</td></tr><tr><td>homework.tray.WaitMul.updateFlag(int,String,int)</td><td>1</td><td>4</td><td>4</td></tr></tbody></table><p>类复杂度也一样。</p><table><thead><tr><th>Class</th><th>OCavg</th><th>WMC</th></tr></thead><tbody><tr><td>homework.MainClass</td><td>1</td><td>1</td></tr><tr><td>homework.SafeOutput</td><td>1</td><td>1</td></tr><tr><td>homework.custumer.Controller</td><td>1.5</td><td>6</td></tr><tr><td>homework.custumer.Elevator</td><td>1.57</td><td>22</td></tr><tr><td>homework.custumer.Elevator.EleTime</td><td>n/a</td><td>0</td></tr><tr><td>homework.custumer.Elevator.Status</td><td>n/a</td><td>0</td></tr><tr><td>homework.custumer.ElevatorController</td><td>4.29</td><td>30</td></tr><tr><td>homework.custumer.ElevatorMul</td><td>2.9</td><td>29</td></tr><tr><td>homework.producer.RequestParser</td><td>3</td><td>6</td></tr><tr><td>homework.tray.Person</td><td>1.05</td><td>22</td></tr><tr><td>homework.tray.Scheduler</td><td>1.18</td><td>13</td></tr><tr><td>homework.tray.WaitMul</td><td>3.24</td><td>81</td></tr></tbody></table><h2>四、三省吾身</h2><h3>4.1 第五次作业</h3><p>本次作业在强测中没有出现Bug，在互测中没有被Hack。</p><h3>4.2 第六次作业</h3><p>本次作业在强测中没有出现Bug，在互测中没有被Hack。</p><h3>4.3 第七次作业</h3><p>本次作业在强测中没有出现Bug，在互测中被Hack一次。</p><p>这次很惨地被Rider暴捶，Rider实在是一个居住在OO网站上的狠人，最终战绩30 / 168，从头到尾穷追不舍Berserker，hack了我试了好几次也打不到的Alterego（我本地会测出他有死锁的情况），用运行超时死锁虐了我和Saber……</p><p>Rider从头到尾就在提交一个数据（除了固定欺负Berserker，还会捎带暴捶我们）：</p><pre><code>[1.0]651-FROM-5-TO-15
[1.0]404-FROM-9-TO-1
[5.0]797-FROM-10-TO-1
[5.0]75-FROM-2-TO--2
[5.0]816-FROM-1-TO-7
[5.0]699-FROM-9-TO--3
[9.0]46-FROM-11-TO-2
[9.0]592-FROM--3-TO--2
[9.0]152-FROM-1-TO--3
[9.0]480-FROM-1-TO-2
[9.0]385-FROM--3-TO-6
[9.0]199-FROM--3-TO-1
[9.0]632-FROM-13-TO-20
[9.0]562-FROM-6-TO-12
[9.0]72-FROM-9-TO-4
[13.0]995-FROM-1-TO--2
[13.0]977-FROM-1-TO-12
[13.0]633-FROM-1-TO-3
[13.0]176-FROM-1-TO-11
[13.0]865-FROM-2-TO-1
[13.0]471-FROM-8-TO-1
[13.0]594-FROM-11-TO-4
[13.0]765-FROM-3-TO--3
[13.0]478-FROM-1-TO--3
[17.0]357-FROM-1-TO-11
[17.0]604-FROM-9-TO-8
[17.0]447-FROM-1-TO-10
[17.0]106-FROM-9-TO-14
[17.0]194-FROM-7-TO-1
[17.0]387-FROM-12-TO-1
[17.0]760-FROM-1-TO-14
[17.0]X1-ADD-ELEVATOR-C
[17.0]874-FROM-16-TO--3
[17.0]369-FROM-1-TO-9
[17.0]268-FROM-8-TO--3
[17.0]498-FROM--3-TO-5
[17.0]340-FROM-10-TO-4
[17.0]859-FROM-1-TO-8
[17.0]423-FROM-1-TO-14
[17.0]211-FROM--1-TO-2
[21.0]518-FROM-17-TO-14
[21.0]242-FROM-10-TO-1
[25.0]871-FROM--3-TO-6
[25.0]427-FROM--1-TO-1
[25.0]X2-ADD-ELEVATOR-A
[29.0]975-FROM-14-TO-1
[29.0]504-FROM-1-TO--1
[29.0]942-FROM-1-TO--1
[29.0]96-FROM-1-TO--1
[29.0]133-FROM--3-TO-1
[29.0]558-FROM-15-TO--3
[29.0]X3-ADD-ELEVATOR-A
</code></pre><p>单看数据，这组数据的特点是分几个时间段，在同一时刻进行大量乘客投放和电梯增加操作。</p><p>那么为什么会发生死锁呢？相信我们房间的同学都很想了解为什么会发生死锁，小编对于会发生死锁这件事也感到很惊讶，但是就是发生死锁了，那么这就是发生死锁的故事了。对于这件事情大家有什么看法呢，欢迎在评论区留言哦。</p><p>……言归正传……我本地将这个数据跑了1000次，也没有成功复现。而根据课程组提供的加密输出，可以发现产生死锁的样例输出中间有明显间隔期，然而CPU时间为1.2s，说明没有发生暴力轮询，而我所采用的架构是人类在每次电梯发生楼层改变时都会重新呼叫当前最近的电梯，所以……我是真的想不出来原因了……解决办法就是给wait价格时间限制试试？但我也不清楚这个的作用，毕竟直接再交一遍也过了……</p><p>以上，互测被扣分了是我能力不够，等解禁了一定要加Rider膜拜一下，对于这个问题我也不会忘记的，以后姿势水平提升了要努力弄明白。</p><h2>五、互测策略</h2><p>第五、六次没有发现他人Bug，但是第六次有房间成员发现他人Bug……第七次发现3处Bug，Hack成功2处。</p><p>在互测时发现了别人的线程不安全Bug：</p><ul><li>调度器类使用for each遍历当前电梯列表，如果这时出现新的电梯添加请求（迭代过程中进行了修改），就会抛异常。（提交4次数据成功1次）</li></ul><p>而互测策略上，这次就没有对拍……多线程主要依赖自动测试，感谢HDL学长的定时输入轮子和某位学长的自动化测试机和WPB的多线程评测机。这里再次膜拜一下一个样例提交20多次的居住在OO网站上的Rider。</p><p>一些卡时间点的数据我试了下无人中招……毕竟对自己的性能有一点自信，所以当时互测就没有深入测试……这里再次膜拜一下卡RTLE的居住在OO网站上的Rider。</p><h2>六、心得体会</h2><p>从难度上来说，我觉得第二单元比第一单元略小。第一单元为了性能和正确性，需要考虑的东西还挺多的。而虽然说相比去年今年第二单元的进度提早、需求增加，但是有了第一单元学习到的经验，迭代开发使得三次作业的改进更加方便。</p><p>这一单元关于锁的概念理解与实际操作非常重要，我主要使用synchronized关键字修饰单一类的方法，发生死锁的概率较低。而多线程也对自动化测试有了更高的要求，之后也要强化Python编程能力。</p><p>不过这三次还是花了很多时间在修复Bug上，希望下次可以避免。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week6]]></title>
        <id>《航空航天概论》Week6</id>
        <link href="https://mondaycha.github.io/blog/2020/04/09/《航空航天概论》Week6"/>
        <updated>2020-04-09T17:20:43.000Z</updated>
        <summary type="html"><![CDATA[爱课程 3.2 飞机飞行性能]]></summary>
        <content type="html"><![CDATA[<h2>爱课程 3.2 飞机飞行性能</h2><p>在这节课我学习到，由于流程之间有内摩擦，在靠近管壁的时候流速慢一点。空气和空气之间的流程会产生摩擦，空气与飞行器的表面也会产生摩擦。空气的粘性低表面光滑度，气流流动状态，体表面积大小都是粘性摩擦阻力的影响因素。相同的迎风截面积条件下，不同形状和尺寸的物体上有相同的阻力。</p><h2>爱课程 3.3 飞机操纵性与稳定性</h2><p>在这节课我学习到，飞机的三种操纵、飞机的稳定性。比如说古代的箭尾部增加羽毛，重心与焦点位置，重心越靠前越稳定，这是纵向稳定性；而方向稳定性以及横向稳定性也有各自的依据。另一个指标则是机动性，与稳定性不可兼得。</p><h2>爱课程 4.1 直升机的飞行</h2><p>在这节课我学习到，直升机采用旋转机翼，与固定翼不一样。直升机相比固定翼，可以垂直起降、空中悬停等，有着自己的优势。直升机旋翼的工作原理，反作用力矩，为了平衡这个反作用力，直升机有了很多细分的类别，由尾桨、双旋、带翼、倾转、旋转定翼等方式实现平衡。</p><h2>爱课程 4.2 直升机的操纵</h2><p>在这节课我学习到，直升机的操纵也比固定翼要复杂很多。有总距操纵、变距操纵、前飞操纵、航向操纵等。直升机的稳定性差，悬停操纵也不是一件简单的事情。无人机的动力学特性比较复杂，对驾驶员也有很高的要求，危险程度大。</p><h2>学堂在线 6.4/6.5 无人机的发射与起飞/无人机的回收与着陆</h2><p>在学堂在线的这一节我学习到，无人机是一个很有发展前景的航空器（虽然昨日刚刚曝出大疆裁员的消息，2020的新冠对各行各业都是严峻的挑战）。无人机的起飞有多种发射方式，比如有零长度发射、载机空中发射、垂直起飞、人力投掷等。无人机的回收方式也有多种，比起飞更有挑战，需要注意对机上设备的保护。</p><h2>歼-15是什么气动布局？为什么采用这样的布局？</h2><p>歼15是以T10K原型机为基础研制的一代国产舰载战斗机，</p><p>气动布局：气动外形类似于苏联（俄罗斯）的苏33舰载战斗机。歼15是双发，双垂尾的重型战斗机，带鸭翼的三翼面气动布局，带有着舰拦阻钩，采用电传飞行控制系统，具有优异的机动性能。</p><p>采用原因：适应舰载战斗机的作战需求，便于实现折叠机翼等功能。</p><h2>飞机操纵性和稳定性之间有什么关系？</h2><p>在其他条件不变之下,稳定性大的飞机操纵起来就一定费力些，两者不可兼得。其中稳定性需要飞机重心适当靠前，操作性需要飞机重心适当靠后。在两个要求的重叠范围内，就是飞机起飞前配载工作的主要目的。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab2 实验报告]]></title>
        <id>操作系统 OS Lab2 实验报告</id>
        <link href="https://mondaycha.github.io/blog/2020/04/04/操作系统-OS-Lab2-实验报告"/>
        <updated>2020-04-04T18:37:09.000Z</updated>
        <summary type="html"><![CDATA[感谢PB，PB大救星。]]></summary>
        <content type="html"><![CDATA[<h1>OS Lab2 实验报告</h1><p>感谢PB，PB大救星。</p><h2>一、实验思考题</h2><h3>Thinking 2.1</h3><p>请思考cache用虚拟地址来查询的可能性，并且给出这种方式对访存带来的好处和坏处。另外，你能否能根据前一个问题的解答来得出用物理地址来查询的优势?</p><p><strong>答：</strong></p><p>如果使用虚拟地址来查询cache：</p><ul><li>好处：当TLB未命中，cache命中时，可以直接用虚拟地址查询，不需要经过MMU的转换。</li><li>坏处：一个物理地址可映射到多个虚拟地址，多进程共用cache可能会造成数据访问错误，最终还是需要通过物理地址校验是否命中。</li></ul><p>用物理地址来查询的优势：</p><ul><li>用物理地址查询，物理地址命中则必命中。</li></ul><h3>Thinking 2.2</h3><p>请查阅相关资料，针对我们提出的疑问，给出一个上述流程的优化版本，新的版本需要有更快的访存效率。（提示：考虑并行执行某些步骤）</p><p><strong>答：</strong></p><p>优化版本：</p><ol><li>CPU给出虚拟地址来访问数据，TLB接收到这个地址之后查找是否有对应的页表项。</li><li>假设页表项存在，则根据物理地址在cache中查询；如果不存在，则MMU执行正常的页表查询工作之后再根据物理地址在cache中查询，同时更新TLB中的内容。</li><li>如果cache命中，则直接返回给CPU数据；如果没有命中则按照相应的算法进行cache的替换或者装填，同时并行返回给CPU数据。</li></ol><h3>Thinking 2.3</h3><p>在我们的实验中，有许多对虚拟地址或者物理地址操作的宏函数(详见include/mmu.h ),那么我们在调用这些宏的时候需要弄清楚需要操作的地址是物理地址还是虚拟地址，阅读下面的代码，指出x是一个物理地址还是虚拟地址。</p><pre><code>int x;
char *value = return_a_pointer();
*value = 10;
x = (int) value;
</code></pre><p><strong>答：</strong></p><p>x是虚拟地址。</p><h3>Thinking 2.4</h3><p>我们在 include/queue.h 中定义了一系列的宏函数来简化对链表的操作。实际上，我们在 include/queue.h 文件中定义的链表和 glibc 相关源码较为相似，这一链表设计也应用于 Linux 系统中 (sys/queue.h 文件)。请阅读这些宏函数的代码，说说它们的原理和巧妙之处。</p><p><strong>答：</strong></p><p>原理：通过宏定义的形式描述双向链表。</p><p>巧妙之处：</p><ol><li>不依赖具体的类型，由宏定义的传参决定。</li><li>采用特殊的双重链表结构，好处是删除方便。比如在<code>Page</code>结构体中，<code>pp_link</code>有两个域，其中<code>le_next</code>指向下一个页结构体，<code>le_prev</code>指向上一个页结构体的<code>pp_link</code>的<code>le_next</code>。这样在进行删除的时候主要知道需要删除的节点就可以了。</li></ol><h3>Thinking 2.5</h3><p>我们注意到我们把宏函数的函数体写成了 <code>do { /* ... */ } while(0)</code>的形式，而不是仅仅写成形如 <code>{ /* ... */ }</code> 的语句块，这样的写法好处是什么？</p><p><strong>答：</strong></p><p>辅助定义复杂的宏，避免在进行引用时出错，使宏在展开后保留语义。</p><h3>Thinking 2.6</h3><p>注意，我们定义的 Page 结构体只是一个信息的载体，它只代表了相应物理内存页的信息，它本身并不是物理内存页。 那我们的物理内存页究竟在哪呢？Page 结构体又是通过怎样的方式找到它代表的物理内存页的地址呢？ 请你阅读 include/pmap.h 与 mm/pmap.c 中相关代码，给出你的想法。</p><p><strong>答：</strong></p><p>物理内存页在设备的物理内存中，Page 结构体由alloc初始化入口，根据Page 结构体指针，通过page2pa，减去起始位找到它的页号，乘以页面大小，得到其代表的物理内存页的地址。</p><h3>Thinking 2.7</h3><p>请阅读 include/queue.h 以及 include/pmap.h, 将Page<!-- -->_<!-- -->list的结构梳理清楚,选择正确的展开结构(请注意指针)。</p><p><strong>答：</strong></p><p><strong>C:</strong></p><pre><code>struct Page_list{
    struct {
        struct {
            struct Page *le_next;
            struct Page **le_prev;
        } pp_link;
        u_short pp_ref;
    }* lh_first;
}
</code></pre><h3>Thinking 2.8</h3><p>在 <code>mmu.h</code> 中定义了 <code>bzero(void *b, size_t)</code> 这样一个函数,请你思考，此处的b指针是一个物理地址， 还是一个虚拟地址呢？</p><p><strong>答：</strong></p><p>虚拟地址。</p><h3>Thinking 2.9</h3><p>了解了二级页表页目录自映射的原理之后，我们知道，Win2k内核的虚存管理也是采用了二级页表的形式，其页表所占的 4M 空间对应的虚存起始地址为 <code>0xC0000000</code>，那么，它的页目录的起始地址是多少呢？</p><p><strong>答：</strong></p><p><code>0xC0030000</code></p><p>计算方式：<code>0xC0000000 + (0xC0000000 &gt;&gt; 12) * 4 = 0xC0030000</code>。</p><h3>Thinking 2.10</h3><p>注意到页表在进程地址空间中连续存放，并线性映射到整个地址空间，思考：是否可以由虚拟地址直接得到对应页表项的虚拟地址？上一节末尾所述转换过程中，第一步查页目录有必要吗，为什么？</p><p><strong>答：</strong></p><p>由页表与虚拟地址空间的映射关系，可以根据虚拟地址得到对应页表项的虚拟地址。</p><p>有必要。第一步查页目录获取的时二级页表的物理地址。</p><h3>Thinking 2.11</h3><p>思考一下tlb_out 汇编函数，结合代码阐述一下跳转到NOFOUND的流程？从MIPS手册中查找tlbp和tlbwi指令，明确其用途，并解释为何第10行处指令后有4条nop指令。</p><p><strong>答：</strong></p><p>跳转到NOFOUND的流程：</p><ul><li>保存CP0_ENTRYHI的值，刷新CP0_ENTRYHI，查询TLB表项，如无效跳转到NOFOUND，并恢复CP0_ENTRYHI的值；若有效，valid写入0，跳转到NOFOUND，并恢复CP0_ENTRYHI的值。</li></ul><p>指令：</p><blockquote><p>Format: TLBP MIPS32
Purpose: To find a matching entry in the TLB.</p><p>Format: TLBWI MIPS32
Purpose: To write a TLB entry indexed by the Index register.</p></blockquote><ul><li>TLBP用于查找TLB，TLBWI用于向TLB指定位置写入。</li></ul><p>4条nop指令：</p><ul><li>清空流水线，防止异常出现影响CP0工作。</li></ul><h3>Thinking 2.12</h3><p>显然，运行后结果与我们预期的不符，va值为0x88888，相应的pa中的值为0。这说明我们的代码中存在问题，请你仔细思考我们的访存模型，指出问题所在。</p><p><strong>答：</strong></p><p>在代码中使用了va2pa函数，返回的是页的起始地址，转换过程中清空了低12位，因此获取的pa并不是0x88888对应的值。</p><h3>Thinking 2.13</h3><p>在X86体系结构下的操作系统，有一个特殊的寄存器CR4，在其中有一个PSE位，当该位设为1时将开启4MB大物理页面模式，请查阅相关资料，说明当PSE开启时的页表组织形式与我们当前的页表组织形式的区别。</p><p><strong>答：</strong></p><p>目前是二级页表组织形式，开启4MB大物理页面模式后是一个一级页表表项直接映射到4MB大小的页。在Xv6系统初始化时，会使用到4MB大页。</p><h3>Thinking 2.11（指导书）</h3><p>观察给出的代码可以发现，page_insert 会默认为页面设置PTE_V的权限。请问，你认为是否应该将PTE_R 也作为默认权限？并说明理由。</p><p><strong>答：</strong></p><p>不应该，PTE_R为写权限位，而在进行page_insert时并不知道页面是否可写。</p><h2>二、实验难点图示</h2><p>实验中比较难的地方，一个是这里的地址转换：</p><p><img src="http://cscore.net.cn/assets/courseware/v1/79285678df7ddb18b4761b7d88a87de9/asset-v1:Internal+B3I062140+2019_T2+type@asset+block/lab2-pic-2.jpg"/></p><p>另外一个地方就是双重链表的操作，这边的链表操作函数实在是绕……比如<code>LIST_INSERT_BEFORE</code>函数：</p><pre><code class="language-c">/*
 * Insert the element &quot;elm&quot; *before* the element &quot;listelm&quot; which is
 * already in the list.  The &quot;field&quot; name is the link element
 * as above.
 */
#define LIST_INSERT_BEFORE(listelm, elm, field) do {                    \
                (elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;        \
                LIST_NEXT((elm), field) = (listelm);                    \
                *(listelm)-&gt;field.le_prev = (elm);                      \   
                (listelm)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);    \   
        } while (0)
</code></pre><p>这里的9是<code>*((listelm)-&gt;field.le_prev)</code>，也就是<code>listelm</code>的上一个<code>preelm</code>的<code>next</code>指向插入的<code>elm</code>；10则是让<code>listelm</code>的<code>prev</code>指针指向<code>elm</code>的<code>next</code>指针，从而实现链表的前插操作。</p><p>再次祭出这张群友发的图（现在想想数据结构是大一下，彼时是大二下的助教们大概率就是从OS课上获得的灵感）：</p><p><img src="https://pic.downk.cc/item/5e78981c5c56091129c65218.png"/></p><p>所以<code>LIST_REMOVE</code>函数就是这么写的：</p><pre><code class="language-c">/*
 * Remove the element &quot;elm&quot; from the list.
 * The &quot;field&quot; name is the link element as above.
 */
#define LIST_REMOVE(elm, field) do {                                    \
                if (LIST_NEXT((elm), field) != NULL)                    \
                        LIST_NEXT((elm), field)-&gt;field.le_prev =        \
                                        (elm)-&gt;field.le_prev;           \
                *(elm)-&gt;field.le_prev = LIST_NEXT((elm), fieldc);       \
        } while (0)
</code></pre><p>要从链表中删除<code>elm</code>，那么就先把<code>elm</code>的下一个元素的<code>prev</code>指针设置为<code>elm</code>的前一个元素的<code>next</code>，再将<code>elm</code>的上一个<code>preelm</code>的<code>next</code>指向后一个<code>elm</code>。删除这个元素只需知道其自身。</p><p>最后是思维导图式的难点树——</p><p>![](G:\OneDrive\OneDrive - buaa.edu.cn\MWD\学习\操作系统\作业\Refer\内存管理难点.png)</p><h2>三、体会与感想</h2><p><strong>Lab2难度评价：</strong>★★★★☆</p><p><strong>Lab2-extra难度评价：</strong>★★★☆☆</p><p><strong>花费时间：</strong>Lab2 15h，Lab2-extra 4h</p><p><strong>体会和感想：</strong></p><p>第二次Lab我也写了很久，总结发在了自己的暂定·博客里——<a href="https://mondaycha.github.io/2020/03/29/329-1/%E3%80%82">https://mondaycha.github.io/2020/03/29/329-1/。</a></p><p>这也是一次很有挑战性的Lab，分值也很高。感谢学长的资料以及群里的讨论，让我学到了很多。OS对自学的要求很高，之后也要继续加油。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week5]]></title>
        <id>《航空航天概论》Week5</id>
        <link href="https://mondaycha.github.io/blog/2020/04/02/《航空航天概论》Week5"/>
        <updated>2020-04-02T17:20:43.000Z</updated>
        <summary type="html"><![CDATA[爱课程 2.3 飞机的阻力]]></summary>
        <content type="html"><![CDATA[<h2>爱课程 2.3 飞机的阻力</h2><p>在这节课我学习到，由于流程之间有内摩擦，在靠近管壁的时候流速慢一点。空气和空气之间的流程会产生摩擦，空气与飞行器的表面也会产生摩擦。空气的粘性低表面光滑度，气流流动状态，体表面积大小都是粘性摩擦阻力的影响因素。相同的迎风截面积条件下，不同形状和尺寸的物体上有相同的阻力。</p><h2>爱课程 3.1 超声速飞行特点</h2><p>在这节课我学习到，超声速飞机的多种翼型，尽可能兼顾高速飞行与低速飞行之间的矛盾。国产歼十使用的是鸭式翼。超声速飞行还会产生声爆和热障，对周围环境和飞机的飞行都有着比较大的影响。超声速飞行器比低亚声速飞行器有了很大的外形区别。</p><h2>为什么飞机设计时要尽量增大升力？</h2><p>如同奥运精神是更高更快更强，飞行器也在追求更高更快更远更安全更舒适。在飞机设计时要尽量增大升力，因为这样就可以承载更大的重量。更加符合人们对航空运输的飞行器实际应用的需求。</p><h2>为什么飞机设计时要尽量减小阻力？</h2><p>影响飞机飞行的因素主要是升力和阻力，通过减小阻力在进行飞行的过程中就可以采用更小的发动机功率，更加经济。另外阻力较大时也会产生粘性摩擦等，对飞机的制造材料也有了更高的要求，所以尽量减小阻力有利于飞机的安全稳定性。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shields 测试]]></title>
        <id>Shields 测试</id>
        <link href="https://mondaycha.github.io/blog/2020/03/31/Shields-测试"/>
        <updated>2020-03-31T08:12:26.000Z</updated>
        <summary type="html"><![CDATA[这是测试页，如果正常，下方有图片——]]></summary>
        <content type="html"><![CDATA[<p>这是测试页，如果正常，下方有图片——</p><p><img src="https://img.shields.io/badge/dynamic/json?color=pink&amp;label=Bilibili%20fans&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dbilibili%26queryKey%3D95736001"/></p><p>感谢YLS给我的Bilibili粉丝做的小牌牌</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab2 学习笔记 「Part 2」]]></title>
        <id>操作系统 OS Lab2 学习笔记 「Part 2」</id>
        <link href="https://mondaycha.github.io/blog/2020/03/30/操作系统-OS-Lab2-学习笔记-「Part-2」"/>
        <updated>2020-03-30T01:46:36.000Z</updated>
        <summary type="html"><![CDATA[OS Lab2的难度还是比较大的，为了更好的掌握，我希望能通过撰写博客加深对相关知识点的理解。]]></summary>
        <content type="html"><![CDATA[<p>OS Lab2的难度还是比较大的，为了更好的掌握，我希望能通过撰写博客加深对相关知识点的理解。</p><h2>学习时的参考资料</h2><p>在学习Lab2的过程中，最正经的方式应该是认真阅读所有相关的代码与宏……不过发现了两名学长的博客，对于Lab2的介绍很充分——</p><blockquote><p>LAB2初始化流程的梳理：<a href="https://ausar.xyz/index.php/archives/66/#comments">https://ausar.xyz/index.php/archives/66/#comments</a></p><p>操作系统lab2实验总结——Part1：<a href="https://www.cnblogs.com/puublog/p/10657916.html">https://www.cnblogs.com/puublog/p/10657916.html</a></p></blockquote><p>希望能边写边理清思路……要不然课上测试biss……</p><h2>MMU/TLB和内存访问</h2><p>Lab2的内容主要与内存管理有关。内存翻译中的两大部件：MMU和TLB，其中MMU是硬件设备，将逻辑地址映射为物理地址，并可以实现内存访问的权限检查。TLB则是为了解决多级页表带来的访存低效的问题，是页表的一部分高速缓存，让计算机能够不经过页表就把虚拟地址映射成物理地址。</p><p>而关于Cache，这部分我其实还不是特别理解，在做思考题的时候再想清楚。</p><h2>MIPS虚拟映射布局</h2><p>32位的MIPS CPU最大寻址空间为4GB(2^32字节)，被划分为4部分——</p><ol><li>kuseg，2G，用户内存空间，需要通过MMU进行虚拟地址到物理地址的转换。</li><li>kseg0，512M，内核地址，将最高位清零就可以被转换为物理地址，使用缓存。</li><li>kseg1，512M，内核地址，高三位清零可转换，不使用缓存，通常用来实现对外设的访问。</li><li>kseg2，1G，只能在内核态使用，需要MMU的转换。</li></ol><p>其他小Point:</p><ol><li>内核态上述虚存空间都可以访问</li><li>kuseg、kseg2访问需要通过MMU</li></ol><h2>物理内存管理</h2><h3>初始化流程说明</h3><p>在Lab2，内核加载完毕后跳转到<code>init/main.c</code>下执行程序， <code>main.c</code>内部调用了<code>mips_init();</code>，这是一个死循环函数，如果停止则会通过<code>panic</code>报错。那么<code>panic</code>是啥呢？在<code>include/printf.h</code>下可以找到定义：</p><pre><code class="language-c">#define panic(...) _panic(__FILE__, __LINE__, __VA_ARGS__)
</code></pre><p>具体查看<code>include/printf.c</code>，发现在打印错误信息之后就陷入死循环等待中断处理。</p><p><code>mips_init();</code>通过<code>mips_detect_memory();</code>，<code>mips_vm_init();</code>，<code>page_init();</code>三个函数来实现物理内存管理的相关数据结构的初始化。</p><h3>内存控制块</h3><p>4KB为一页，内存分配也是以页为基本单位进行。为了记录分配情况，课程中使用Page结构体保存一页内存相关信息，定义在<code>include/pamp.h</code>中：</p><pre><code class="language-c">typedef LIST_ENTRY(Page) Page_LIST_entry_t;

struct Page {
    Page_LIST_entry_t pp_link;  /* free list link */

    // Ref is the count of pointers (usually in page table entries)
    // to this page.  This only holds for pages allocated using
    // page_alloc.  Pages allocated at boot time using pmap.c&#x27;s &quot;alloc&quot;
    // do not have valid reference count fields.

    u_short pp_ref;
};
</code></pre><p><code>pp_link</code>的类型为<code>LIST_ENTRY(Page)</code>，其定义可以在<code>include/queue.h</code>中找到：</p><pre><code class="language-c">/*
 * Use this inside a structure &quot;LIST_ENTRY(type) field&quot; to use
 * x as the list piece.
 *
 * The le_prev points at the pointer to the structure containing
 * this very LIST_ENTRY, so that if we want to remove this list entry,
 * we can do *le_prev = le_next to update the structure pointing at us.
 */
#define LIST_ENTRY(type)                                                \
        struct {                                                                \
                struct type *le_next;   /* next element */                      \
                struct type **le_prev;  /* address of previous next element */  \
        }
</code></pre><p>这就是在上次的总结中提过的特殊的双重链表结构，好处是删除方便。所以在<code>Page</code>结构体中，<code>pp_link</code>有两个域，其中<code>le_next</code>指向下一个页结构体，<code>le_prev</code>指向上一个页结构体的<code>pp_link</code>的<code>le_next</code>。<code>(listelm)-&gt;field.le_prev</code>是<code>listelm</code>上一个<code>elm</code>的<code>le_next</code>，让它指向新增的<code>elm</code>。关于这一点可以在<code>include/queue.h</code>中的<code>LIST_INSERT_AFTER</code>定义中找到：</p><pre><code class="language-c">(elm)-&gt;field.le_prev = &amp;((listelm)-&gt;field.le_next);
</code></pre><p><code>pp_ref</code>则是这一页面的引用次数。所以Page结构体大概就是一张存储页使用信息、地址的链表，本身并不是物理内存页。之后的exercise2.1就是关于链表操作函数<code>LIST_INSERT_HEAD</code>和<code>LIST_INSERT_TAIL</code>的补全。单从插入效率的角度<code>LIST_INSERT_HEAD</code>函数显然更好一些，后者还要遍历链表。</p><p>这边的链表操作函数实在是绕……比如<code>LIST_INSERT_BEFORE</code>函数：</p><pre><code class="language-c">/*
 * Insert the element &quot;elm&quot; *before* the element &quot;listelm&quot; which is
 * already in the list.  The &quot;field&quot; name is the link element
 * as above.
 */
#define LIST_INSERT_BEFORE(listelm, elm, field) do {                    \
                (elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;        \
                LIST_NEXT((elm), field) = (listelm);                    \
                *(listelm)-&gt;field.le_prev = (elm);                      \   
                (listelm)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);    \   
        } while (0)
</code></pre><p>这里的9是<code>*((listelm)-&gt;field.le_prev)</code>，也就是<code>listelm</code>的上一个<code>preelm</code>的<code>next</code>指向插入的<code>elm</code>；10则是让<code>listelm</code>的<code>prev</code>指针指向<code>elm</code>的<code>next</code>指针，从而实现链表的前插操作。</p><p>再次祭出这张群友发的图（现在想想数据结构是大一下，彼时是大二下的助教们大概率就是从OS课上获得的灵感）：</p><p><img src="https://pic.downk.cc/item/5e78981c5c56091129c65218.png"/></p><p>所以<code>LIST_REMOVE</code>函数就是这么写的：</p><pre><code class="language-c">/*
 * Remove the element &quot;elm&quot; from the list.
 * The &quot;field&quot; name is the link element as above.
 */
#define LIST_REMOVE(elm, field) do {                                    \
                if (LIST_NEXT((elm), field) != NULL)                    \
                        LIST_NEXT((elm), field)-&gt;field.le_prev =        \
                                        (elm)-&gt;field.le_prev;           \
                *(elm)-&gt;field.le_prev = LIST_NEXT((elm), fieldc);       \
        } while (0)
</code></pre><p>要从链表中删除<code>elm</code>，那么就先把<code>elm</code>的下一个元素的<code>prev</code>指针设置为<code>elm</code>的前一个元素的<code>next</code>，再将<code>elm</code>的上一个<code>preelm</code>的<code>next</code>指向后一个<code>elm</code>。删除这个元素只需知道其自身。</p><h3>内存分配和释放</h3><p>在exercise2.2需要补全<code>mips_detect_memory()</code>函数，这是我们init的第一步。这里需要让操作系统知道可用的物理内存的大小和范围，也就是对提示的四个全局变量进行设置。根据输出判断extra为0，gxemul模拟内核运行环境的时候并没有模拟插外置存储的情况。</p><p>之后在<code>mips_vm_init()</code>中完成了对操作系统内核所必须的数据结构 – 页目录（pgdir）、内存控制块数组（pages）和进程控制块数组（envs）所需的物理内存的分配，这一部分会在最后的启动流程中再梳理一遍。在完成对这几个关键部分的内存分配之后，剩余的内存就可以加入到空闲链表中，这一步需要用到<code>page_init()</code>函数，也就是exercise2.3的实验内容。</p><p>在<code>page_init()</code>函数的注释突然出现了一个全局变量——<code>freemem</code>，那么它是啥呢？它的类型是物理地址、虚拟地址还是内核虚拟地址？C语言中long的全局变量初值为0，在<code>mips_vm_init()</code>中调用了<code>alloc</code>函数，就涉及对<code>freemem</code>的赋值，这里用到了<code>extern</code>指向的<code>end[]</code>数组来赋初值，但我没有在文件中找到最开始的定义……奇了怪了；而从这里用到的<code>PADDR(kva)</code>宏也可以得出<code>freemem</code>是内核虚拟地址的结论，这一点在我们后续的操作中十分重要。</p><p>总之由于内存的分配是连续的，所以<code>freemem</code>之前指向的就是已经分配完毕的页，应该要将其<code>pp_ref</code>置1，之后则是未分配的，将其<code>pp_ref</code>置0并加入到空闲页的链表中，由此就可以进行以页为单位的物理内存分配与释放。</p><p>在exercise2.4里，<code>page_alloc</code>函数用来从空闲链表中分配一页物理内存，而<code>page_free</code>函数则用于将一页之前分配的内存重新加入到空闲链表中。</p><h2>虚拟内存管理</h2><h3>地址转换</h3><ul><li>内核虚拟地址：0x80010000，kseg0</li><li>PADDR(kva)：虚拟地址到物理地址的转换</li><li>KADDR(pa)：物理地址到虚拟地址的转换</li><li>PDX(va)：获得一个虚拟地址对应的页目录索引</li><li>PTX(va)：获得这个虚存地址对应的页表索引</li></ul><h3>页目录自映射</h3><ul><li>进程的页表位置：UVPT(0x7fc00000) 到 ULIM(0x80000000) 之间的空间，4MB</li></ul><h3>创建页表</h3><p>在exercise2.5，需要对<code>mm/pmap.c</code>中的<code>boot_pgdir_walk</code>和<code>pgdir_walk</code>函数进行填充，其中<code>boot_pgdir_walk</code>是在内核刚启动的时候运行，通过<code>alloc</code>直接以字节为单位分配物理内存；后者在空闲页面链表初始化之后运行，使用<code>page_alloc</code>以页为单位分配物理内存。</p><p>首先来看看<code>boot_pgdir_walk</code>：</p><pre><code class="language-c">/* Overview:
    Get the page table entry for virtual address `va` in the given
    page directory `pgdir`.
    If the page table is not exist and the parameter `create` is set to 1,
    then create it.*/
static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create)
{

    Pde *pgdir_entryp;
    Pte *pgtable, *pgtable_entry;

    /* Step 1: Get the corresponding page directory entry and page table. */
    /* Hint: Use KADDR and PTE_ADDR to get the page table from page directory
     * entry value. */
    pgdir_entryp = pgdir + PDX(va);
    // 通过 PDX(va) 来获得一个虚拟地址对应的页目录索引
    // 凭借索引在页目录中得到对应的二级页表的基址(物理地址)

    if ((*pgdir_entryp) &amp;&amp; PTE_V)       // 检测地址是否有效
    {
        pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));
        // 把这个物理地址转化为内核虚拟地址(KADDR)
    }

    /* Step 2: If the corresponding page table is not exist and parameter `create`
     * is set, create one. And set the correct permission bits for this new page
     * table. */
    // 如果虚拟地址所对应的二级页表不存在
    else if (create == 1)
    // 为这个虚拟地址创建一个新的页表
    {
        pgtable = (Pte *)alloc(BY2PG, BY2PG, 1);
        // 申请一页物理内存来存放这个页表
        // 将它的物理地址赋值给对应的页目录项
        
        *pgdir_entryp = PADDR(pgtable) | PTE_V;
        // 设置好页目录项的权限位
    }

    /* Step 3: Get the page table entry for `va`, and return it. */
    pgtable_entry = &amp;pgtable[PTX(va)];
    // 通过 PTX(va) 获得这个虚存地址对应的页表索引
    
    return pgtable_entry;
    // 从页表中得到对应的页面的物理地址
}
</code></pre><p>返回值是<code>Pte</code>，输入值则包括<code>Pde</code>的指针，这两者的定义在<code>include/mmu.h</code>中可以找到：</p><pre><code class="language-c">typedef u_long Pde;
typedef u_long Pte;
</code></pre><p>两者都是<code>unsigned long</code>类型，长度为32位，而虚拟地址的长度也是32位，方便转换。</p><p>这里理解还不够深入，援引学长的解释：</p><blockquote><p>下面说明一下<code>Pde*</code>的理解（<code>Pde*</code>和<code>Pte*</code>是一样的）</p><pre><code class="language-c">Pde *pgdir_entryp;
</code></pre><p>在<code>include/mmu.h</code>中定义了</p><pre><code class="language-c">typedef` `u_long Pde;
</code></pre><p><code>Pde</code>的类型就是<code>unsigned long</code>，占4B。它的指针是要寻找虚拟空间，大小也是一个页表项，4B。<code>Pde</code>和<code>Pde*</code>都是4B，使它们的转换非常方便。指针实际上一块以它为地址的内存单元。所以<code>Pde</code>的指针(<code>Pde*</code>)所指的地址就是虚拟地址，而这块地址的内容(<code>Pde</code>)是物理地址，所以实现了虚拟地址和物理地址的映射关系。</p></blockquote><p>而<code>pgdir_walk</code>函数也与之类似，区别在于创建时的处理：</p><pre><code class="language-c">else if (create == 1)
    {
        if (page_alloc(&amp;ppage) == -E_NO_MEM) // out of memory.
        {
            return -E_NO_MEM;
        }
        // 已经申请好了页，传入的指针已经改变
        pgtable = page2kva(ppage);
        *pgdir_entryp = PADDR(pgtable) | PTE_R | PTE_V;
        // PTE_R：脏位
        ppage-&gt;pp_ref++;
        // 这个设置ref的操作不要忘了……
    }
</code></pre><h3>地址映射</h3><p>将相应的物理页面地址填入对应虚拟地址的页表项，填充<code>mm/pmap.c</code>中的<code>boot_map_segment</code>函数。</p><p>在exercise2.6，将[va, va+size)的虚拟地址映射到物理地址[pa,pa+size)中，根据perm对这个地址标记位更新，实现了在虚拟地址所对应的二级页表里存放（物理页框的）物理地址。</p><p>通过for循环实现，函数内还给了临时变量。</p><pre><code class="language-c">    /* Step 2: Map virtual address space to physical address. */
    /* Hint: Use `boot_pgdir_walk` to get the page table 
     * entry of virtual address `va`. */
    for (i = 0; i &lt; (size / BY2PG); i++)
    // 这里回头记得修改，感觉Pb说的很有道理……
    {
        va_temp = va + i * BY2PG;   
        // 突然发现这里可以用更好的方式……
        pgtable_entry = boot_pgdir_walk(pgdir, va_temp, 1);
        // 返回页表项的虚拟地址
        *pgtable_entry = (pa + i * BY2PG) | perm | PTE_V;
        // 指向物理地址，设置标记位
    }
</code></pre><p>这个函数完成了对于[va,va+size)这一片虚拟地址的页表的设置，把对应的物理地址存入了对应的页表中。</p><h3>page insert and page remove</h3><p>在exercise2.7，需要填充<code>page_insert</code>函数，该函数将va虚拟地址和其要对应的物理页pp的映射关系以perm的权限设置加入页目录。</p><pre><code class="language-c">int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm);
</code></pre><p>然后就是复习汇编知识……想到我的78分祭祖理论课瑟瑟发抖……从MIPS手册中查找tlbp和tlbwi指令。</p><blockquote><p>Format: TLBP MIPS32
Purpose: To find a matching entry in the TLB.</p><p>Format: TLBWI MIPS32
Purpose: To write a TLB entry indexed by the Index register.</p></blockquote><h3>最后的最后</h3><p>啊，真的好多……</p><p>写到这里脑子确实清楚了一些，明天写Extra吧。</p><p>加油！奥里给！</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS 第五次作业]]></title>
        <id>操作系统 OS 第五次作业</id>
        <link href="https://mondaycha.github.io/blog/2020/03/26/操作系统-OS-第五次作业"/>
        <updated>2020-03-26T06:14:10.000Z</updated>
        <summary type="html"><![CDATA[1）叙述缺页中断的处理流程。]]></summary>
        <content type="html"><![CDATA[<p>1）叙述缺页中断的处理流程。</p><ol><li>现场保护：陷入内核态，保存必要的信息。</li><li>页面定位：查找出发生缺页中断的虚拟页面。</li><li>权限检查：检查虚拟地址的有效性以及安全保护位，如果发生保护错误，则杀死该进程。</li><li>分配页框：查找一个空闲的页框；如果没有则通过页面置换算法找到一个需要换出的页框。</li><li>页面写回：如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。</li><li>页面调入：将保持在磁盘上的页面内容复制到该页框中。</li><li>更新页表：当磁盘中的页面内容全部装入页框后，向CPU发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。</li><li>恢复现场：恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。</li><li>继续执行：退出内核态，程序重新执行引发缺页中断的指令，进行存储访问。</li></ol><hr/><p>2）假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：
(1) LRU、FIFO和Clock算法的效果如何？
(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？</p><ol><li>LRU、FIFO和Clock算法的效果均相同。</li><li>算法：尽可能减少替换的页面。将其中499页框用于固定页面的映射，剩下1个页面可替换。</li></ol><hr/><p>3）假设有10个页面，n个页框。页面的访问顺序为0, 9, 8, 4, 4, 3, 6, 5, 1, 5, 0, 2, 1, 1, 1, 1, 8, 8, 5, 3, 9, 8, 9, 9, 6, 1, 8, 4, 6, 4, 3, 7, 1, 3, 2, 9, 8, 6, 2, 9, 2, 7, 2, 7, 8, 4, 2, 3, 0, 1, 9, 4, 7, 1, 5, 9, 1, 7, 3, 4, 3, 7, 1, 0, 3, 5, 9, 9, 4, 9, 6, 1, 7, 5, 9, 4, 9, 7, 3, 6, 7, 7, 4, 5, 3, 5, 3, 1, 5, 6, 1, 1, 9, 6, 6, 4, 0, 9, 4, 3。
当n在<!-- -->[1,10]<!-- -->中取值时，请编写程序实现OPT、LRU、FIFO页面置换算法，并根据页面访问顺序模拟执行，分别计算缺页数量，画出缺页数量随页框数n的变化曲线（3条线）</p><p><img src="https://pic.downk.cc/item/5e7b6422504f4bcb040f2bb5.png"/></p><p>（代码附作业末）</p><hr/><p>4）一个32位的虚拟存储系统有两级页表，其逻辑地址中，第22到31位是第一级页表，12位到21位是第二级页表，页内偏移占0到11位。一个进程的地址空间为4GB，如果从0x80000000开始映射4MB大小页表空间，请问第一级页表所占4KB空间的起始地址？并说明理由。（注意B代表字节，一个32位地址占4字节）</p><p>计算方式与页目录自映射计算公式类似，</p><p>第一级页表所占4KB空间的起始地址为<code>0x80000000|0x80000000&gt;&gt;10 = 0x80200000</code>。</p><hr/><p>5）</p><ol><li><p>进程整个的地址空间有<code>2^32</code>字节？一页有<code>2^10</code>字节。</p></li><li><p><strong>0x0</strong></p><p>过程：页目录地址为<code>0x0</code>，页表地址为<code>0x0</code>，页内偏移为<code>0x0</code>。</p><p>访问页目录<code>0x0</code>，有效位为0，访问无效。</p><p><strong>0x00803004</strong></p><p>过程：页目录地址为<code>0x2</code>，页表地址为<code>0x3</code>，页内偏移为<code>0x4</code>。</p><p>访问页目录<code>0x2</code>，得到页表的页框地址为<code>0x5000</code>且有效，访问页表<code>0x3</code>项，得到页框地址为<code>0x20000</code>且有效，加上偏移量即得到转换后的物理地址——<code>0x20004</code>。</p><p>最终访存获取到的数据为<code>0x0</code>。</p><p><strong>0x00402001</strong></p><p>过程：页目录地址为<code>0x1</code>，页表地址为<code>0x2</code>，页内偏移为<code>0x1</code>。</p><p>访问页目录<code>0x1</code>，得到页表的页框地址为<code>0x1000</code>且有效，访问页表<code>0x2</code>项，得到页框地址为<code>0x5000</code>且有效，加上偏移量即得到转换后的物理地址——<code>0x5001</code>。</p><p>最终访存获取到的数据为<code>0x4e001</code>。</p></li><li><p>物理地址<code>0x326028</code>对应的偏移量为0x28，对应的页框地址为<code>0x32600</code>，查找二级页表得，位于页框地址为<code>0x20000</code>的页表的第<code>0x1</code>项中，该页表信息位于页目录的第<code>0x3</code>项。</p><p>对应的虚拟地址为<code>0x00c01028</code>。</p></li></ol><hr/><h3>附：第三题代码</h3><pre><code class="language-java">import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

public class MainClass {
    public static final int[] readpage = {
            0, 9, 8, 4, 4, 3, 6, 5, 1, 5,
            0, 2, 1, 1, 1, 1, 8, 8, 5, 3,
            9, 8, 9, 9, 6, 1, 8, 4, 6, 4,
            3, 7, 1, 3, 2, 9, 8, 6, 2, 9,
            2, 7, 2, 7, 8, 4, 2, 3, 0, 1,
            9, 4, 7, 1, 5, 9, 1, 7, 3, 4,
            3, 7, 1, 0, 3, 5, 9, 9, 4, 9,
            6, 1, 7, 5, 9, 4, 9, 7, 3, 6,
            7, 7, 4, 5, 3, 5, 3, 1, 5, 6,
            1, 1, 9, 6, 6, 4, 0, 9, 4, 3
    };

    public static void main(String[] args) {
        System.out.print(&quot;OPT:  &quot;);
        for (int n = 1; n &lt;= 10; n++) {
            System.out.print(getFaultCountOfOPT(n) + &quot; &quot;);
        }
        System.out.print(&quot;\nLRU:  &quot;);
        for (int n = 1; n &lt;= 10; n++) {
            System.out.print(getFaultCountOfLRU(n) + &quot; &quot;);
        }
        System.out.print(&quot;\nFIFO: &quot;);
        for (int n = 1; n &lt;= 10; n++) {
            System.out.print(getFaultCountOfFIFO(n) + &quot; &quot;);
        }
    }

    public static int getFaultCountOfFIFO(int n) {
        int answer = 0;
        Queue&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; 100; i++) {
            if (list.contains(readpage[i])) {
                continue;
            } else {
                if (list.size() == n) {
                    list.poll();
                }
                list.offer(readpage[i]);
                answer++;
            }
        }
        return answer;
    }

    public static int getFaultCountOfLRU(int n) {
        int answer = 0;
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; 100; i++) {
            int page = readpage[i];
            if (map.containsKey(page)) {
                map.put(page, i);
                continue;
            } else {
                if (map.size() == n) {
                    int minread = 101;
                    int minkey = 0;
                    for (Map.Entry&lt;Integer, Integer&gt; ii : map.entrySet()) {
                        if (minread &gt; ii.getValue()) {
                            minread = ii.getValue();
                            minkey = ii.getKey();
                        }
                    }
                    map.remove(minkey);
                }
                map.put(page, i);
                answer++;
            }
        }
        return answer;
    }

    public static int getFaultCountOfOPT(int n) {
        int answer = 0;
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; 100; i++) {
            int page = readpage[i];
            if (map.containsKey(page)) {
                map.put(page, betweenUse(page,i));
                continue;
            } else {
                if (map.size() == n) {
                    int maxpause = -1;
                    int maxkey = 0;
                    for (Map.Entry&lt;Integer, Integer&gt; ii : map.entrySet()) {
                        if (maxpause &lt; ii.getValue()) {
                            maxpause = ii.getValue();
                            maxkey = ii.getKey();
                        }
                    }
                    map.remove(maxkey);
                }
                map.put(page, betweenUse(page,i));
                answer++;
            }
        }
        return answer;
    }

    public static int betweenUse(int page, int now) {
        for (int i = now + 1; i &lt; 100; i++) {
            if (readpage[i] == page) {
                return i - now;
            }
        }
        return 101;
    }
}
</code></pre><p>输出结果：</p><pre><code class="language-shell">OPT:  90 64 50 39 29 23 17 12 11 10 
LRU:  90 79 71 58 52 42 28 17 13 10 
FIFO: 90 80 67 59 47 39 30 20 12 10 
Process finished with exit code 0
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab2 学习笔记 「Part 1」]]></title>
        <id>操作系统 OS Lab2 学习笔记 「Part 1」</id>
        <link href="https://mondaycha.github.io/blog/2020/03/24/操作系统-OS-Lab2-学习笔记-「Part-1」"/>
        <updated>2020-03-24T01:54:36.000Z</updated>
        <summary type="html"><![CDATA[前言]]></summary>
        <content type="html"><![CDATA[<h3>前言</h3><p>挑战开始了，加油！！！</p><h3>双向链表操作拾遗</h3><p>在Exercise2.1，需要对双向链表进行操作。</p><p><img src="https://pic.downk.cc/item/5e78981c5c56091129c65218.png"/></p><p>在这里采用了一种特殊的链表形式，如上图（我找不到这个课件了，图片来自群成员）</p><p>链表的插入操作，对注释做了一点修正——</p><pre><code class="language-c">// Note: assign a to b &lt;==&gt; a = b
//Step 1, assign elm.next to listelem.next.
//Step 2: Judge whether listelm.next is NULL, if not, then assign listelm.next.pre to a proper value.
//step 3: Assign listelm.next to a proper value.
//step 4: Assign elm.pre to a proper value.
</code></pre><p>这个设计感觉还是很巧妙的。</p><h3>关于全局变量</h3><pre><code class="language-c">/* Step 1: Initialize basemem.
* (When use real computer, CMOS tells us how many kilobytes there are). */
basemem = 0x4000000;
maxpa = 0x4000000;
extmem = 0x0;
// Step 2: Calculate corresponding npage value.
npage = basenum &gt;&gt; 12;
</code></pre><p>后来看了一下在mmu.h里面有对SHIFT的定义，更严谨的来说应该是要写那个吧。</p><h3>如何用命令行压缩文件</h3><p>压缩服务器上当前目录的内容为xxx.zip文件</p><pre><code>zip -r xxx.zip ./*
</code></pre><p>解压zip文件到当前目录</p><pre><code>unzip filename.zip
</code></pre><p>这样就可以从实验环境copy代码了！</p><h3>如何运行内核</h3><pre><code>gxemul -E testmips -C R3000 -M 64
</code></pre><p>后面可以跟vmlinux的地址，也可以写个sh脚本来运行。</p><h3>课程群零散知识点收集</h3><h4>2.1</h4><ol><li>助教提示：typeof的使用</li><li>注释提示错误：应该是listelm-&gt;field.next-&gt;field.prev</li></ol><h4>2.2</h4><ol><li>npage指的是64MB/4KB</li><li>extra那个填0（原因：根据输出判断为0，另一方面我们就没有外置存储，gx模拟的时候没有模拟你额外插内存条）</li></ol><h3>Debug记录</h3><h4>1</h4><p>Exercise2.1 双向链表操作错误</p><p>借助pb的test程序</p><h4>2</h4><p>Exercise 2.4，输出如下结果——</p><pre><code>-------------------------------------------------------------------------------

main.c: main is start ...

init.c: mips_init() is called

Physical memory: 65536K available, base = 65536K, extended = 0K

to memory 80401000 for struct page directory.

to memory 80431000 for struct Pages.

pmap.c:  mips vm init success

[ dev_mp: unimplemented relative addr 0x8 ]
[ dev_mp: unimplemented relative addr 0x14 ]
Segmentation fault (core dumped)
</code></pre><p>初步分析：与pmap.c中的三个函数填写有关</p><p>检查警告——</p><pre><code>pmap.c: In function &#x27;page_init&#x27;:
pmap.c:183: warning: passing argument 1 of &#x27;va2pa&#x27; from incompatible pointer type
pmap.c: In function &#x27;page_alloc&#x27;:
pmap.c:230: warning: passing argument 1 of &#x27;bzero&#x27; makes pointer from integer without a cast
</code></pre><p>说明type不对，进行修改完成debug工作。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用Git从远程仓库获取所有分支]]></title>
        <id>如何使用Git从远程仓库获取所有分支</id>
        <link href="https://mondaycha.github.io/blog/2020/03/24/如何使用Git从远程仓库获取所有分支"/>
        <updated>2020-03-24T01:00:36.000Z</updated>
        <summary type="html"><![CDATA[来源：Stackoverflow]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-shell">git branch -r | grep -v &#x27;\-&gt;&#x27; | while read remote; do git branch --track &quot;${remote#origin/}&quot; &quot;$remote&quot;; done
git fetch --all
git pull --all
</code></pre><blockquote><p>来源：Stackoverflow</p><p>链接：<a href="http://stackoverflow.com/questions/10312521/how-to-fetch-all-git-branches">http://stackoverflow.com/questions/10312521/how-to-fetch-all-git-branches</a></p></blockquote>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab1 实验报告]]></title>
        <id>操作系统 OS Lab1 实验报告</id>
        <link href="https://mondaycha.github.io/blog/2020/03/21/操作系统-OS-Lab1-实验报告"/>
        <updated>2020-03-21T18:37:09.000Z</updated>
        <summary type="html"><![CDATA[一、实验思考题]]></summary>
        <content type="html"><![CDATA[<h1>OS Lab1 实验报告</h1><h2>一、实验思考题</h2><h3>思考题0.1</h3><p>也许你会发现我们的readelf程序是不能解析之前生成的内核文件(内核文件是可执行文件)的，而我们之后将要介绍的工具readelf则可以解析，这是为什么呢？(提示：尝试使用readelf -h，观察不同)</p><p><strong>答：</strong></p><p>通过<code>readelf -h</code>可以发现，我们之前生成的内核文件vmlinux是大尾端elf文件，而测试使用的testELF是小尾端elf文件。</p><pre><code class="language-shell">~/work/18373580-lab/gxemul$ readelf -h vmlinux
ELF Header:
  Magic:   7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#x27;s complement, big endian
  ...
  
~/work/18373580-lab/gxemul$ readelf -h ../readelf/testELF
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#x27;s complement, little endian
  ...
</code></pre><p>由于我们的readelf程序尚未完善，目前只能在小尾端环境下运行，无法正确读取大尾端elf文件的内容，因此不能正确输出段头表内信息。在Lab1-extra中通过对readelf的补充修改，就可以进行解析了。</p><h3>思考题0.2</h3><p>内核入口在什么地方？main 函数在什么地方？我们是怎么让内核进入到想要的 main 函数的呢？又是怎么进行跨文件调用函数的呢？</p><p><strong>答：</strong></p><p>内核在kseg0内，main 函数在User Space(kuseg)内。</p><p>在本次Lab1中，scse0_3.lds里通过<code>ENTRY(_start)</code>指令指定了<code>start.S</code>中的<code>_start()</code>函数指向内核入口。main 函数路径为<code>init/main.c</code>。</p><p><code>_start()</code>函数初始化CPU，设置栈指针，通过<code>jal</code>指令让内核跳转到main函数。在链接可执行文件之后通过跳转指令跨文件调用函数。</p><h2>二、实验难点图示</h2><p>不传图了</p><h2>三、体会与感想</h2><p><strong>Lab1难度评价：</strong>★★★☆☆</p><p><strong>Lab1-extra难度评价：</strong>★★★☆☆</p><p><strong>花费时间：</strong>Lab1 9h，Lab1-extra2h</p><p><strong>体会和感想：</strong></p><p>在Lab1我感受到了深深的恐惧。我意识到了如果我不再采取策略，很快我就会难以跟上目前的进度。</p><p>在这一节中难点是print函数的补充，然而一开始我却毫无思路，参考PPT和Ausar的指导书补充才填写出来；而在Lab1-extra，我花费了大量的时间de翻转函数的bug，如果是课上测试的话根本做不出；思考题0.2更是让我一头雾水，不清楚题目表达的意思。</p><p>目前正在读指导书和ELF手册，我非常迷茫，但OO将占据我的另一大半时间……完全不清楚要采取什么策略来学习，也只能走一步看一步了。</p><p>最后是对于接下来Lab的想法：</p><ul><li>在开始Lab之前，获取全部资料（Lab1的资料我觉得很分散，让人摸不到头脑）</li><li>对于不理解的内容，搜集相关资料（但真的太杂了，系统差别也大）</li></ul><p>祈祷我能存活下去吧。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week4]]></title>
        <id>《航空航天概论》Week4</id>
        <link href="https://mondaycha.github.io/blog/2020/03/21/《航空航天概论》Week4"/>
        <updated>2020-03-21T01:26:43.000Z</updated>
        <summary type="html"><![CDATA[爱课程 3.4 探月工程发展]]></summary>
        <content type="html"><![CDATA[<h2>爱课程 3.4 探月工程发展</h2><p>在这节课我学习到，嫦娥三期工程，中国整个探月工程分为“绕”、“落”、“回”3个阶段。第一步，第一颗月球探测卫星“嫦娥一号”已于2007年10月24日发射；第二步是发射月球软着陆器，突破地外天体的着陆技术；第三步是发射月球软着陆器，突破自地外天体返回地球的技术，进行月球样品自动取样并返回地球。</p><h2>爱课程 2.1 流体流动基本规律</h2><p>在这节课我学习到，航空基于空气动力学原理，航空器需要有足够的升力。航空器能够良好的飞行需要三个要素——足够升力、足够动力、良好的稳定性。流体流动基本规律有质量守恒与连续性方程，得到速度与截面的关系——截面积大，流速变小。能量守恒与伯努利方程，静压加动压为常数，流速大，动压大。课上的“茅屋为秋风所破”的例子也很生动形象。</p><h2>爱课程 2.2 飞机的升力</h2><p>在第二节，我学习到，飞机上下翼的流速不同，上下翼面形成压强差，从而产生了升力，使得飞机平衡了重力。影响升力的因素有——翼面积、飞行速度、空气密度、翼型和迎角（风筝产生升力的原因）。迎角过大会引起失速，不利于起降，借助襟翼增升装置可以实现平稳起降。高升力、低阻力是设计飞机的永恒目标。</p><h2>学堂在线 3 探月工程</h2><p>在学堂在线的3.7/9/9，我学习到，“嫦娥一号”是我国第一颗月球探测卫星，突破了很多关键技术，飞行轨道设计就是关键的一环。中国整个探月工程分为“绕”、“落”、“回”3个阶段。嫦娥三号在月球上成功软着陆，有着非常重要的意义。嫦娥五号则将实现“回”，与前面几个探测器不同，预计于2020年发射。</p><h2>嫦娥四号在月球背面着陆有什么意义？</h2><p>之所以人类对于月球的探索都集中在正面，是因为在背面的着陆难度远远大于正面。月球背面接收不到来自地球的任何辐射干扰，飞行器无法与地面取得联络。中国成功部署了“鹊桥号”中继卫星，为嫦娥四号在月球背面着陆做好了准备。嫦娥四号在月球背面着陆，可以采集月球背面的特有信息，而嫦娥四号任务更是为中国航天迈出了突破性的一步。</p><h2>我国北斗卫星导航系统有哪些功能？</h2><p>我国北斗卫星导航系统已广泛应用于交通运输、基础测绘、工程勘测、资源调查、地震监测、气象探测和海洋勘测等领域。具体的功能如下：</p><p>基本导航服务。为全球用户提供服务，空间信号精度将优于0.5米；全球定位精度将优于10米，测速精度优于0.2米/秒，授时精度优于20纳秒；亚太地区定位精度将优于5米，测速精度优于0.1米/秒，授时精度优于10纳秒，整体性能大幅提升。</p><p>短报文通信服务。中国及周边地区短报文通信服务，服务容量提高10倍，用户机发射功率降低到原来的1/10，单次通信能力1000汉字（14000比特）；全球短报文通信服务，单次通信能力40汉字（560比特）。</p><p>星基增强服务。按照国际民航组织标准，服务中国及周边地区用户，支持单频及双频多星座两种增强服务模式，满足国际民航组织相关性能要求。</p><p>国际搜救服务。按照国际海事组织及国际搜索和救援卫星系统标准，服务全球用户。与其他卫星导航系统共同组成全球中轨搜救系统，同时提供返向链路，极大提升搜救效率和能力。</p><p>精密单点定位服务。服务中国及周边地区用户，具备动态分米级、静态厘米级的精密定位服务能力。</p><p>（参考资料：百度百科）</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[OO 第一单元总结 表达式求导]]></title>
        <id>OO 第一单元总结 表达式求导</id>
        <link href="https://mondaycha.github.io/blog/2020/03/20/OO-第一单元总结-表达式求导"/>
        <updated>2020-03-20T04:53:41.000Z</updated>
        <summary type="html"><![CDATA[OO第一单元通过三次递进式的作业让我们实现表达式求导，在这几次作业中我也有很多收获。下面就回顾一下前三次作业中存在的问题。]]></summary>
        <content type="html"><![CDATA[<h1>OO 第一单元总结 表达式求导</h1><p>OO第一单元通过三次递进式的作业让我们实现表达式求导，在这几次作业中我也有很多收获。下面就回顾一下前三次作业中存在的问题。</p><p>在个人看来，表达式求导的难点主要有三部分——对输入的处理、表达式的存储结构以及化简。这三次作业我所采用的表达式存储结构都不相同，不过重构的速度还是比较快的（安慰自己）。</p><h2>第一次作业</h2><p>在第一次作业中，我的程序总体架构为提取幂函数为Poly对象，建立Polynomial类解析表达式创建幂函数对象，在主类Derivative中进行部分性能优化工作。</p><h3>① 程序结构分析</h3><p>UML类图：</p><p>第一次作业的幂函数因子较为简单，代码中仅提炼出Poly对象，并在其内部实现求导方法。</p><p><strong>Method复杂度：</strong></p><table><thead><tr><th>Method</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Derivative.main(String[])</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Derivative.printAnswer(HashMap&lt;BigInteger,  Poly&gt;)</td><td>4</td><td>5</td><td>7</td></tr><tr><td>Poly.Poly(BigInteger,BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addCoef(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.compareTo(Object)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.derivative()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Poly.equals(Object)</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Poly.getCoeff()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.getIndex()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.hashCode()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.toString()</td><td>1</td><td>11</td><td>12</td></tr><tr><td>Polynomial.Polynomial(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Polynomial.getPolyitem()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Polynomial.getfirstitem()</td><td>1</td><td>9</td><td>10</td></tr></tbody></table><p>第一次作业中，化简主要在主类Derivative的printAnswer()方法（将第一个正项优先输出）和Poly类的toString()方法中，printAnswer()涉及对表达式的遍历，基本复杂性高；toString()则包含大量条件语句，多次调用了BigInteger中的方法，循环依赖性高。而表达式解析我采用的是正则+状态机的策略（这个策略三次作业均沿用，感觉还是很舒服的），在getfirstitem()中处理不同类型输入并归一化，代码较为复杂。</p><h3>② 程序Bug分析</h3><p>第一次作业在强测、互测中均未出现Bug。</p><h3>③ 互测采用策略</h3><p>互测时我采用的策略是“补刀”。我先是用简单的自动测试程序跑了下房间内成员的代码，不过貌似没有出现问题；然而圣杯战争发生了转机——Rider竟然拿下了一血！</p><p>于是我一一检查其他成员的代码，发现Berserker的正则存在问题：在正则中匹配的是“<code>[+|-]{0,2}(\\d*.)?x(..[+|-]?\\d+)?</code>”，其中的“.”可匹配任意字符，就会错误解析表达式。</p><p>第一次互测时认真读了屋内其他同学的代码，感觉还是很有收获的。之后两次大部分都读不下去，可读性实在是让人肝疼……放到评测姬里自生自灭吧！另外这次互测也让我意识到了高工同学的可怕之处（误），全屋子就这一个Bug，大佬换着花样hack……卷卷更健康。</p><h3>④ 对象创建模式</h3><p>在第一次作业中，我并没有应用对象创建模式，表达式解析就顺便new了新因子，Polynomial类的紧耦合比较严重。</p><h2>第二次作业</h2><p>第二次作业增加了三角函数因子，这个时候我也偷偷看了一下去年的第三次作业题目，新增加的嵌套对于表达式的化简无疑是不小的挑战。所以在规划第二次作业的总体架构时，我就面临着一个选择——是要建立终将在第三次作业重构的四元组项；还是要采用“表达式-项-因子”三层结构，为第三次作业留好迭代的空间？</p><p>经过一番挣扎（其实并没有，因为我还不会写三层结构），我选择了势必带来重构的四元组形式，也就是将表达式的每一项以“<code>coeff*x**powindex*sin(x)**sinindex*cos(x)**cosindex</code>”的形式存储，这样处理方式就和第一次作业基本一致。在基本架构沿用第一次作业的情况下，第二次作业给我最大的挑战反而是三角函数的化简，我的化简类Simplify的行数是最多的。</p><h3>① 程序结构分析</h3><p><strong>UML类图</strong>：</p><p>架构基本沿用第一次作业，UML也差不多，不过这次的简化更复杂一些。</p><p><strong>Method复杂度：</strong></p><table><thead><tr><th>Method</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>DeriPrinter.DeriPrinter(HashMap&lt;String,  MutiItem&gt;)</td><td>1</td><td>7</td><td>7</td></tr><tr><td>DeriPrinter.getAnswer(HashMap&lt;String,  MutiItem&gt;)</td><td>4</td><td>5</td><td>7</td></tr><tr><td>DeriPrinter.printAnswer()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Item.Item(BigInteger,BigInteger,BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Item.compareTo(Object)</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Item.equals(Object)</td><td>2</td><td>4</td><td>4</td></tr><tr><td>Item.getCosin()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Item.getPowin()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Item.getSinin()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Item.hashCode()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Item.toString()</td><td>1</td><td>5</td><td>8</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.MutiItem(BigInteger,BigInteger,BigInteger,BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.MutiItem(BigInteger,Item)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.addCoeff(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.compareTo(Object)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.derivate()</td><td>1</td><td>5</td><td>5</td></tr><tr><td>MutiItem.equals(Object)</td><td>2</td><td>2</td><td>2</td></tr><tr><td>MutiItem.getCoeff()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.getCosin()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.getIdentity()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.getItem()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.getPowin()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.getSinin()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.hashCode()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MutiItem.toString()</td><td>1</td><td>5</td><td>5</td></tr><tr><td>ParseExp.MutiItemSign()</td><td>2</td><td>3</td><td>4</td></tr><tr><td>ParseExp.ParseExp(String)</td><td>1</td><td>5</td><td>6</td></tr><tr><td>ParseExp.WrongFormat(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>ParseExp.getExpression()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>ParseExp.getFirstitem()</td><td>3</td><td><strong>13</strong></td><td><strong>14</strong></td></tr><tr><td>Simplify.Simplify(HashMap&lt;String,  MutiItem&gt;)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Simplify.exitmatch(BigInteger,Item,Item,Item,HashMap&lt;Item,  BigInteger&gt;)</td><td>2</td><td>3</td><td>4</td></tr><tr><td>Simplify.searchcos(HashMap&lt;Item,  BigInteger&gt;)</td><td><strong>4</strong></td><td>6</td><td>9</td></tr><tr><td>Simplify.simplify()</td><td>1</td><td>3</td><td>4</td></tr></tbody></table><p>由于一开始并没有明确的化简思路，在第一遍实现了基本求导功能的代码通过中测之后，我为了实现化简功能，又对代码内类的结构做了很多修改，在这一过程中，尽管我确实用类将表达式中的Item与MulItem做了封装，但我却胡乱修改内部方法，这并不符合面向对象的思想，也导致最后代码可读性极差，也为互测时被发现的Bug埋下了祸根。具体表现到MetricReloaded的分析上，就是ParseExp类的getFirstitem()依然是复杂度重灾区，没有采用工厂模式也使得它与其他类的依赖极为严重，优化输出的内容依然有很高的基本复杂性。</p><h3>② 程序Bug分析</h3><p>强测中获得性能分为16.545/20，在处理表达式化简时，我所采用的是暴力搜索的方式，每次搜索到可以合并的项就将其合并，然后进行重新搜索。</p><p>这种方法显然只能找到一个极优解，却不能找到最优解，表达式项存储顺序对结果也有很大影响。一种更加可行的方式是采用深度优先搜索，不过当时并没有想出具体的实现方法，只好作罢。</p><p>互测时被找出来一个Bug，同时发现Berserker的一个Bug（狂战士日常躺枪）。而我的Bug是HashMap的Key写错，在生成MulItem的Key时，我采用的是将指数拼接为String的方式，在指数较大时，可能会导致不同项被当作同一项存入HashMap中，造成求导错误。</p><p>修改也很简单，只需要在生成String的时候给不同指数加个分隔符就好了——</p><pre><code class="language-java">public MutiItem(BigInteger a, BigInteger b, BigInteger c, BigInteger d) {
    this.coeff = a;
    this.item = new Item(b, c, d);
    // before: identity = &quot;&quot; + b + c + d;
    identity = &quot;&quot; + b + &quot;.&quot; + c + &quot;.&quot; + d;
}
</code></pre><p>可以发现这里我的MutiItem的构造方法是非常混乱的，不过没有发现这么明显的Bug，一方面就是混乱的优化带来的副作用；另一方面也是因为这样的数据出现几率确实很小，同屋里也只有一个同学发现了这个Bug（我后来和hack我的同学交流了下，果然是长时间跑随机自动测试程序才找到的……）</p><h3>③ 互测采用策略</h3><p>在这次互测是采用对拍+手动构造样例+Python生成随机数据自动评测的方式。屋内除我只有一个Bug，大家很快找到之后也比较佛系。</p><p>互测中阅读了同屋子大佬处理简化的DFS，确实厉害；另外还拜读了另一个房间Alterego的架构，类似Sympy的表达式结构简直叫人拍案叫绝，计算方式优美，让我看到了什么是真正的封装、多态、继承，也有更多信心去面对第三次作业。（不过听说在那个屋Alterego被hack的很惨，悲）</p><h3>④ 对象创建模式</h3><p>在第二次作业中，由于使用的是和第一次作业类似的四元组项，我依然没有应用对象创建模式，表达式解析里又new了新因子，紧耦合依然严重。这在第三次作业中有一定改善。</p><h2>第三次作业</h2><p>前两次作业都没有对表达式进行结构化处理，导致了第三次作业表达式的存储结构必须大改。</p><p>好在表达式求导的三大难点——对输入的处理、表达式的存储结构以及化简，这次都处理得比较好——</p><ul><li>对输入的处理上，有了前两次作业中采用的正则表达式加有限状态机读入的经验，修改很快；</li><li>表达式的存储结构上吸取了Alterego的架构（感谢Alterego！！！！），在进行重构的时候思路比较清晰，避免了第二次作业惨剧的重演；</li><li>化简上，层次化的表达式存储方式发挥出了它的优越性，通过统一的接口进行因子类型的转换，效果好；</li></ul><p>在第三次作业我也首次采用了Package来管理类，也是一个小进步。</p><h3>① 程序结构分析</h3><p><strong>UML类图：</strong></p><p>这一次的类图很乱，主要原因还是在于表达式也可以作为一个因子嵌套进三角函数中，类之间的相互调用也比较明显。</p><p><strong>Method复杂度：</strong></p><table><thead><tr><th>Method</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>homework.MainClass.main(String[])</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.expression.ExpFunction.Exception.Exception(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.expression.ExpFunction.deleteSpace(String)</td><td>3</td><td>7</td><td>10</td></tr><tr><td>homework.expression.ExpFunction.matchParentheses(String,int)</td><td>6</td><td>6</td><td>7</td></tr><tr><td>homework.expression.ExpFunction.readIndex(String)</td><td>2</td><td>1</td><td>2</td></tr><tr><td>homework.expression.ExpFunction.simplifyExpParentheses(String)</td><td>9</td><td>11</td><td>14</td></tr><tr><td>homework.expression.ExpFunction.simplifyParentheses(String,int[])</td><td>1</td><td>1</td><td>8</td></tr><tr><td>homework.expression.ExpFunction.simplifySign(String)</td><td>4</td><td>3</td><td>4</td></tr><tr><td>homework.expression.ExpParser.Exception.Exception(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.expression.ExpParser.ExpParser(String)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.expression.ExpParser.getItemAdd(String,boolean)</td><td>5</td><td>6</td><td>9</td></tr><tr><td>homework.expression.ExpParser.getItemMul(String)</td><td>4</td><td>3</td><td>5</td></tr><tr><td>homework.expression.ExpParser.matchParentheses()</td><td>7</td><td>4</td><td>8</td></tr><tr><td>homework.expression.ExpParser.readOneItem(String)</td><td>6</td><td>9</td><td>12</td></tr><tr><td>homework.expression.ExpParser.spliter()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.expression.ExpSimplify.ExpSimplify(Derivable)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.expression.ExpSimplify.OnlyOneDiff(Derivable,Derivable)</td><td>9</td><td>17</td><td>26</td></tr><tr><td>homework.expression.ExpSimplify.getDiff(boolean,int,int,ItemMul,ItemMul)</td><td>1</td><td>4</td><td>6</td></tr><tr><td>homework.expression.ExpSimplify.searchSimplify(ItemAdd)</td><td>4</td><td>4</td><td>4</td></tr><tr><td>homework.expression.ExpSimplify.simplify()</td><td>2</td><td>2</td><td>4</td></tr><tr><td>homework.polyitem.factor.Factor.Factor()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.Factor.Factor(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.Factor.getIndex()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.Factor.setIndex(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.Factor.updateIndex(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.FactorExp()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.FactorExp(ItemAdd)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.FactorExp(ItemAdd,BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.clone()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.derivate()</td><td>4</td><td>4</td><td>5</td></tr><tr><td>homework.polyitem.factor.FactorExp.equals(Object)</td><td>3</td><td>3</td><td>4</td></tr><tr><td>homework.polyitem.factor.FactorExp.equalsZero()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.getExpression()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.identity()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FactorExp.toString()</td><td>1</td><td>4</td><td>4</td></tr><tr><td>homework.polyitem.factor.FactorFactory.readPower(Matcher)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.factor.FactorFactory.readTrian(Matcher)</td><td>1</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.factor.FactorFactory.simplifyFunc(Derivable)</td><td>2</td><td>4</td><td>5</td></tr><tr><td>homework.polyitem.factor.FuncConst.FuncConst()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.FuncConst(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.FuncConst(String)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.clone()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.derivate()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.equals(Object)</td><td>2</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.factor.FuncConst.equalsOne()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.equalsZero()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.getValue()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.identity()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.setValue(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.toString()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncConst.updateValue(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncPower.FuncPower()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncPower.FuncPower(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncPower.clone()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncPower.derivate()</td><td>1</td><td>1</td><td>2</td></tr><tr><td>homework.polyitem.factor.FuncPower.equals(Object)</td><td>2</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.factor.FuncPower.equalsZero()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncPower.identity()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncPower.toString()</td><td>1</td><td>1</td><td>2</td></tr><tr><td>homework.polyitem.factor.FuncTrian.FuncTrian()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncTrian.FuncTrian(boolean)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncTrian.FuncTrian(boolean,BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncTrian.FuncTrian(boolean,ItemAdd)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncTrian.FuncTrian(boolean,ItemAdd,BigInteger)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.factor.FuncTrian.clone()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.factor.FuncTrian.derivate()</td><td>4</td><td>4</td><td>6</td></tr><tr><td>homework.polyitem.factor.FuncTrian.equals(Object)</td><td>6</td><td>4</td><td>8</td></tr><tr><td>homework.polyitem.factor.FuncTrian.equalsZero()</td><td>3</td><td>3</td><td>4</td></tr><tr><td>homework.polyitem.factor.FuncTrian.identity()</td><td>1</td><td>4</td><td>5</td></tr><tr><td>homework.polyitem.factor.FuncTrian.toString()</td><td>1</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemAdd.ItemAdd()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemAdd.ItemAdd(Derivable...)</td><td>1</td><td>3</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemAdd.ItemAdd(HashMap&lt;String,  Derivable&gt;)</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemAdd.ItemAddPut(Derivable)</td><td>1</td><td>4</td><td>4</td></tr><tr><td>homework.polyitem.item.ItemAdd.PutItemMul(ItemMul)</td><td>1</td><td>5</td><td>5</td></tr><tr><td>homework.polyitem.item.ItemAdd.clone()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.item.ItemAdd.derivate()</td><td>2</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemAdd.equals(Object)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemAdd.equalsZero()</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemAdd.getAdditem()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemAdd.getOnlyOne()</td><td>4</td><td>2</td><td>4</td></tr><tr><td>homework.polyitem.item.ItemAdd.identity()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemAdd.onlyContainOne()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemAdd.toString()</td><td>6</td><td>5</td><td>7</td></tr><tr><td>homework.polyitem.item.ItemMul.ItemMul()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemMul.ItemMul(Derivable...)</td><td>3</td><td>3</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemMul.ItemMulPut(Derivable)</td><td>3</td><td>5</td><td>6</td></tr><tr><td>homework.polyitem.item.ItemMul.PutFactor(Factor)</td><td>6</td><td>10</td><td>10</td></tr><tr><td>homework.polyitem.item.ItemMul.PutItemMul(ItemMul)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.item.ItemMul.clone()</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.item.ItemMul.derivate()</td><td>6</td><td>2</td><td>7</td></tr><tr><td>homework.polyitem.item.ItemMul.equals(Object)</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemMul.equalsZero()</td><td>3</td><td>2</td><td>3</td></tr><tr><td>homework.polyitem.item.ItemMul.getCoeff()</td><td>2</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.item.ItemMul.getMutiitem()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemMul.getOneExp()</td><td>5</td><td>2</td><td>5</td></tr><tr><td>homework.polyitem.item.ItemMul.identity()</td><td>2</td><td>3</td><td>4</td></tr><tr><td>homework.polyitem.item.ItemMul.negateCoeff(boolean)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.item.ItemMul.onlyOneExp()</td><td>3</td><td>3</td><td>7</td></tr><tr><td>homework.polyitem.item.ItemMul.onlyOneFactor()</td><td>4</td><td>3</td><td>7</td></tr><tr><td>homework.polyitem.item.ItemMul.removeItem(Derivable)</td><td>1</td><td>2</td><td>2</td></tr><tr><td>homework.polyitem.item.ItemMul.setCoeffOne()</td><td>1</td><td>1</td><td>1</td></tr><tr><td>homework.polyitem.item.ItemMul.toString()</td><td>1</td><td>7</td><td>7</td></tr><tr><td>homework.polyitem.item.ItemMul.updateCoeff(BigInteger)</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>MetricReloaded分析程序复杂度更加病态了，大量方法的结构化程度存在问题，并且集中在与化简有关的方法中。表达式解析中的readOneItem()方法三项均超标，虽然我已经进行了采用了一部分的工厂模式、将正则表达式存入单独的类中以被调用的解耦合的努力。</p><p><strong>Package复杂度：</strong></p><table><thead><tr><th>Package</th><th>v(G)avg</th><th>v(G)tot</th></tr></thead><tbody><tr><td>homework</td><td>2</td><td>2</td></tr><tr><td>homework.expression</td><td>6.68</td><td>127</td></tr><tr><td>homework.polyitem.factor</td><td>1.86</td><td>93</td></tr><tr><td>homework.polyitem.item</td><td>3.38</td><td>115</td></tr></tbody></table><p>通过分包，将几大功能区分开（不过这次看到20%的性能分，增加了暴力搜索提取公因式的简化方法，还是放在Exp处理中，所以耦合度也有点高）。</p><h3>② 程序Bug分析</h3><p>“OO中最惨的，不是被同屋hack了50个同质Bug，而是在截止提交的下一秒意识到了自己的Bug”</p><p align="right">——沃茨基·硕德</p> 在第三次作业中，我为了简化做了不少工作，也用随机数据自动测试程序做了大量的检验。然而就在周六晚上截止提交后的几秒，我突然意识到我的输出是有问题的——对于表达式因子，我将其设置为继承了Factor类，同样拥有指数Index属性，在输出时，采用的是和幂函数、三角函数一样的输出方式——“`(exp)**index`”，但在输入时表达式因子是不允许有指数的，因此属于WF。但对于Sympy，表达式的格式限定很宽松，通过计算并不能找到错误。 <p>那能咋办……周六晚上看番转移注意力，周日在互测中尽可能挽回损失……最后发现强测没有出现这种输出，但互测时被同屋两名Servent发现了这个Bug。好在修复工作也比较简单，实在是侥幸。</p><h3>③ 互测采用策略</h3><p>在这次互测依然是采用对拍（对军宝具）+手动构造样例（我自己构造了可能会TLE的样例，也分享到了群里）+Python生成随机数据自动评测的方式。</p><p>在这次对Python生成随机数据做了优化，比如Caster在指数为0时会出现各种吊诡的错误，然而互测限定指数&gt;0，于是我将对Caster的随机数据设为指数始终&gt;0，其他成员照旧，避免了反复查看不能hack的Bug带来的失落感。</p><p>最后稍微吐槽一下“不优化就不会Die”，在这次互测中，房间内8名成员，4名优化输出4名不优化，最后出Bug的都是那4名优化输出的……其中Berserker还会在表达式嵌套过多时陷入死循环，截止至本文发稿时已被修好。</p><h3>④ 对象创建模式</h3><p>在这次的作业中终于用到了工厂模式！虽然原因是表达式解析方法太长，不得不将生成项的代码独立开来。不过我也只用工厂模式处理了幂函数、不含嵌套因子的三角函数、常数，含嵌套因子的三角函数的生成与我的状态机密切相关，难以抽象出来，这也是我的架构中的不足。</p><h2>心得体会</h2><p>在寒假的时候，我曾看到知乎上@HansBug学长关于OO课程改革的回答，而通过这一个多月的实际体验，OO给我的感受还是很赞的，通过互测阅读同学代码、与舍友们的交流（感谢@VOIDMalkuth！！！）、水讨论区以及学习理论课，收获很大。</p><p>第一单元也只是从面向过程到面向对象的过渡篇章，通过这次反思，我也发现了过去几次代码中自己结构较为不合理的部分，希望能够在接下来多线程等知识的学习中进一步改善。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week3]]></title>
        <id>《航空航天概论》Week3</id>
        <link href="https://mondaycha.github.io/blog/2020/03/19/《航空航天概论》Week3"/>
        <updated>2020-03-19T20:26:47.000Z</updated>
        <summary type="html"><![CDATA[1.3 中国航空航天技术的发展]]></summary>
        <content type="html"><![CDATA[<h2>1.3 中国航空航天技术的发展</h2><p>在这次的慕课中我学习到，中国航空事业的蓬勃发展是从新中国成立之后开始的，中国航天事业是在上世纪50年代中期开始的，1956年，我国制定了12年科学发展远景规划，把火箭和喷气技术列为重点发展项目。从开国大典时的17架飞机绕回再飞，到今天的强大航空航天力量，中国的发展让人心潮澎湃。</p><h2>2 中国航空技术的发展</h2><p>在第二章我学习到，为中国航空做出巨大贡献，被称为中国“航空先驱”的是冯如。一直以来，听说北航的“冯如书院”、“冯如杯”，没有想到原来冯如先生的成就如此之高。当今中国航空界也以“冯如一号”首飞成功的1909年为中国航空元年。</p><h2>3 中国航天技术的发展</h2><p>在这一章我学习到，1956年，我国制定了12年科学发展远景规划，两弹一星、载人航天八大系统、中国载人航天的第一步——将航天员送上太空，第二步——太空行走与太空对接；第三步——建设空间站。虽然最近的长七改发射失利，但未来一定会更好。</p><h2>C919的市场前景</h2><ol><li>在国内，C919还有着广阔的市场</li><li>中国的商用大飞机的路还很长，更多是改变既有的国际贸易规则；</li><li>新型冠状病毒疫情下，航空运输业面临着严峻的挑战，不容乐观</li><li>疫情也是中国的机会，借C919打破现有的国际贸易规则，飞向未来</li></ol><h2>太空站的建设有什么意义？</h2><ol><li>航天事业的发展，离不开空间站。</li><li>为从事科学实验，提供良好研究条件。是地面上无法复制、无法替代的特殊科研环境。</li><li>2024年国际空间站退役，为中国带来新的机会</li><li>提升我国国际地位，向星辰大海探索</li></ol>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《航空航天概论》Week2]]></title>
        <id>《航空航天概论》Week2</id>
        <link href="https://mondaycha.github.io/blog/2020/03/09/《航空航天概论》Week2"/>
        <updated>2020-03-09T22:40:49.000Z</updated>
        <summary type="html"><![CDATA[2.1 世界航空技术发展]]></summary>
        <content type="html"><![CDATA[<h2>2.1 世界航空技术发展</h2><p>在第一节，我学习到了大气层划分为对流层、平流层、中间层、热层和散逸层（外大气层）等5个层次。航空器的大气飞行环境是对流层和平流层。老师介绍了最早的航空器——热气球（轻于空气的航空器）、飞艇等，美国的莱特兄弟制作的第一架有动力飞机飞行者一号立下了航空的里程碑。而之后一战、二战的作战飞机的设计也让人惊叹，从活塞发动机到喷气时代的变化也让人感受到航空航天的魅力。而对于目前的四代机来说，隐身、超声速巡航、过失速机动，超视距攻击四种能力也非常重要。第二节则重点介绍了关于飞机的内容。从第四代直升机的研发，到现代民用飞机的发展。超声速客机与新一代的民用客机，让我们不禁开始展望航空的美好未来。航空也有着更高、更快、更远、更大的发展方向，民用飞机将更加安全，更加舒适，更加经济，更加环保。</p><h2>2.2</h2><p>关于世界航天技术发展，在第一节，我了解到了齐奥尔尔科夫斯基的多级火箭成为了现在航天器发展的基础。v2火箭成为了现代大型火箭的鼻祖。在太空竞赛之中，航天也得到了长足的发展。对于今天的我们来说，航天探索已经变得稀松平常，但人类要想要迈出太阳系，还有很长的路要走。</p><h2>2.3</h2><p>人造地球卫星。</p><p>航天器有无人航天器与载人航天器、军用航天器与民用航天器的划分，与我们的日常生活、经济发展、科研探测等密切相关的就是人造地球卫星。</p><p>人造地球卫星中的科学卫星可用于空间天文的探测技术；试验卫星可用于新技术的实验应用；应用卫星可用于日常勘测行为。</p><p>中国目前的北斗导航系统也让我们不再受制于GPS。</p><p>歼-10。</p><p>首先对于中国来说，它是我国国防现代化建设的一个里程碑，意味着中国成为了世界上第五个具备独立研制四代机能力的国家。</p><p>其次，歼-10所采用的数字电传飞控系统优良的气动外形，也无不是21世纪人类科技的结晶。</p><p>对于中国来说，歼-10的出现也提高了我国的制空能力，增强了我们的民族信心。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab0 实验报告]]></title>
        <id>操作系统 OS Lab0 实验报告</id>
        <link href="https://mondaycha.github.io/blog/2020/03/06/操作系统-OS-Lab0-实验报告"/>
        <updated>2020-03-06T08:30:59.000Z</updated>
        <summary type="html"><![CDATA[一、实验思考题]]></summary>
        <content type="html"><![CDATA[<h1>OS Lab0实验报告</h1><h2>一、实验思考题</h2><h3>思考题0.1</h3><p>通过你的使用经验，简单分析 CLI Shell，GUI Shell 在你使用过程中的各自优劣（100 字以内）</p><p><strong>CLI Shell：</strong></p><ul><li>优点：操作符合计算机工作逻辑，有利于我们理解计算机的工作方式；大部分情况下比GUI效率高</li><li>缺点：不直观，上手有一定门槛</li></ul><p><strong>GUI Shell：</strong></p><ul><li>优点：易用，更加直观，所见即所得</li><li>缺点：消耗资源大，效率低</li></ul><h3>思考题0.2</h3><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）</p><p>具体实现的过程中思考下列问题：<code>echo echo Shell Start</code> 与 <code>echo &#x27;echo Shell Start&#x27;</code>效果是否有区别；<code>echo echo \$c&gt;file1</code> 与 <code>echo &#x27;echo \$c&gt;file1&#x27;</code> 效果是否有区别？</p><p><strong>command文件：</strong></p><pre><code class="language-shell">touch test
echo &#x27;echo Shell Start...&#x27; &gt; test
echo &#x27;echo set a = 1&#x27; &gt;&gt; test
echo &#x27;a=1&#x27; &gt;&gt; test
echo &#x27;echo set b = 2&#x27; &gt;&gt; test
echo &#x27;b=2&#x27; &gt;&gt; test
echo &#x27;echo set c = a+b&#x27; &gt;&gt; test
echo &#x27;c=$[$a+$b]&#x27; &gt;&gt; test
echo &#x27;echo c = $c&#x27; &gt;&gt; test
echo &#x27;echo save c to ./file1&#x27; &gt;&gt; test
echo &#x27;echo $c&gt;file1&#x27; &gt;&gt; test
echo &#x27;echo save b to ./file2&#x27; &gt;&gt; test
echo &#x27;echo $b&gt;file2&#x27; &gt;&gt; test
echo &#x27;echo save a to ./file3&#x27; &gt;&gt; test
echo &#x27;echo $a&gt;file3&#x27; &gt;&gt; test
echo &#x27;echo save file1 file2 file3 to file4&#x27; &gt;&gt; test
echo &#x27;cat file1&gt;file4&#x27; &gt;&gt; test
echo &#x27;cat file2&gt;&gt;file4&#x27; &gt;&gt; test
echo &#x27;cat file3&gt;&gt;file4&#x27; &gt;&gt; test
echo &#x27;echo save file4 to ./result&#x27; &gt;&gt; test
echo &#x27;cat file4&gt;&gt;result&#x27; &gt;&gt; test
</code></pre><p><strong>result文件：</strong></p><pre><code class="language-shell">3
2
1
</code></pre><p><strong>效果是否有区别：</strong></p><p><code>echo echo Shell Start</code> 与 <code>echo &#x27;echo Shell Start&#x27;</code>效果没有区别，均在Shell中打印<code>echo Shell Start</code>内容。</p><pre><code class="language-shell">$ echo echo Shell Start
echo Shell Start

$ echo &#x27;echo Shell Start&#x27;
echo Shell Start
</code></pre><p><code>echo echo \$c&gt;file1</code> 与 <code>echo &#x27;echo \$c&gt;file1&#x27;</code> 效果有区别：前者将<code>echo $c</code>重定向至file1，后者在Shell中打印<code>echo \$c&gt;file1</code>内容。</p><pre><code class="language-shell">$ cat file1
3

$ echo echo \$c&gt;file1

$ cat file1
echo $c

$ echo &#x27;echo \$c&gt;file1&#x27;
echo \$c&gt;file1
</code></pre><h3>思考题0.3</h3><p>仔细看看这张图，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</p><pre><code class="language-shell">git add     // add the file
git add     // stage the file
git commit  // commit
</code></pre><h3>思考题0.4</h3><p>深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。苦恼的小明向你求助，你该怎样帮他把代码文件恢复呢？</p><p>正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘上敲下了git rm printf.c，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？</p><p>处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使Tucao.txt在不从工作区删除的情况下不会被git commit指令提交到版本库？</p><p><strong>(1)帮小明把代码文件恢复：</strong></p><pre><code class="language-shell">git checkout -- printf.c
</code></pre><p><strong>(2)弥补小红的过错：</strong></p><pre><code class="language-shell">git reset HEAD printf.c
git checkout -- printf.c
</code></pre><p><strong>(3)删除暂存区文件：</strong></p><pre><code class="language-shell">git rm --cached Tucao.txt
</code></pre><h3>思考题0.5</h3><p>思考下面四个描述，你觉得哪些正确，哪些错误，请给出你参考的资料或实验证据。</p><ol><li><p>克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。</p><p>错误。<code>git clone &lt;远程仓库地址&gt;</code>命令默认克隆master分支。</p><p>如果要克隆子分支可以使用<code>git clone -b  &lt;指定分支名&gt; &lt;远程仓库地址&gt;</code>命令。</p></li><li><p>克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。</p><p>正确。克隆出的工作区执行以上操作均是对本地版本库操作，需要用<code>git push</code>命令访问修改远程版本库。</p></li><li><p>克隆时只有远程版本库HEAD指向的分支被克隆。</p><p>正确。证据同(1)。</p></li><li><p>克隆后工作区的默认分支处于master分支。</p><p>正确。证据同(1)。</p></li></ol><h2>二、实验难点图示</h2><p>不传图了……</p><h2>三、体会与感想</h2><p><strong>难度评价：</strong>★★☆☆☆</p><p><strong>花费时间：</strong>平台时间3h，查阅资料等5h左右</p><p><strong>体会和感想：</strong></p><p>Lab0要求我们了解实验环境，熟悉Linux 操作系统（Ubuntu），了解控制终端，掌握一些常用工具并能够脱离可视化界面进行工作。</p><p>虽然“本章节难度非常低”，但在进行实验时我还是遇到了不少阻力——对命令行界面不熟悉、编写Shell脚本时不清楚步骤的内涵、在使用Vim时忍不住“Ctrl+S”却阻断输入……要学习与熟悉的还有很多。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java求解一类特定表达式的化简思路探讨]]></title>
        <id>Java求解一类特定表达式的化简思路探讨</id>
        <link href="https://mondaycha.github.io/blog/2020/03/05/Java求解一类特定表达式的化简思路探讨"/>
        <updated>2020-03-05T08:30:59.000Z</updated>
        <summary type="html"><![CDATA[为了获得更多的性能分，个人目前想到了以下注意点：]]></summary>
        <content type="html"><![CDATA[<h1>如何获取更多Homework2性能分？</h1><p>为了获得更多的性能分，个人目前想到了以下注意点：</p><p>Homework2与Homework1还是有不少相似之处的，因此在上次作业中的这些性能提升点，此次依然有效——</p><ul><li>表达式之间不含空格</li><li>如果存在正项，则表达式以正项为首项（且省略）</li><li>合并同类项</li><li>函数指数部分为0时不输出</li><li>非常数项：系数为1时不输出，系数为-1时仅保留负号</li><li>指数为1时不输出</li><li>0项不输出</li></ul><p>而也有一些此次作业中新出现的抢分点：</p><ul><li>x<!-- -->*<!-- -->*<!-- -->2以x<!-- -->*<!-- -->x形式输出</li><li>$sin^2(x)+cos^2(x)=1$</li><li>$sin^2(x)-cos^2(x)=1-2cos^2(x)$</li></ul><p>其中三角函数的化简较为复杂。</p><p>前者，我们注意到，对于形如
$$
a<em>x^i</em>sin^j(x)<em>cos^k(x)
$$
的项，能够以此规则化简的只有两种形式——
$$
a</em>x^i<em>sin^{j+2}(x)</em>cos^{k-2}(x)
$$</p><p>$$
a<em>x^i</em>sin^{j-2}(x)*cos^{k+2}(x)
$$</p><p>化简后两项合并为——
$$
2<em>a</em>x^i<em>sin^{j-2}(x)</em>cos^{k-2}(x)
$$
因此我们可以遍历容器并检查邻项是否存在，从而化简；而后者，在<code>j=2|k=2</code>时是肯定可以提升性能分的，方法与$sin^2(x)+cos^2(x)=1$的类似。</p><p>当然，个人觉得除非针对后两点构造数据，其出现的机率并不大，是否要为了性能分牺牲性能也是一个问题。</p><p><strong>也求有想法的大佬交流下更好的方法与隐藏的内卷点(～￣▽￣)～</strong></p><p>为了获得更多的性能分，个人目前想到了以下注意点：</p><p>Homework2与Homework1还是有不少相似之处的，因此在上次作业中的这些性能提升点，此次依然有效——</p><ul><li>表达式之间不含空格</li><li>如果存在正项，则表达式以正项为首项（且省略）</li><li>合并同类项</li><li>函数指数部分为0时不输出</li><li>非常数项：系数为1时不输出，系数为-1时仅保留负号</li><li>指数为1时不输出</li><li>0项不输出</li></ul><p>而也有一些此次作业中新出现的抢分点：</p><ul><li>x<!-- -->*<!-- -->*<!-- -->2以x<!-- -->*<!-- -->x形式输出</li><li>$sin^2(x)+cos^2(x)=1$</li><li>$sin^2(x)-cos^2(x)=1-2 cos^2(x)$</li></ul><p>其中三角函数的化简较为复杂。</p><p>前者，我们注意到，对于形如$a<!-- -->*<!-- -->x^i<!-- -->*<!-- -->sin^j(x)<!-- -->*<!-- -->cos^k(x) $
的项，能够以此规则化简的只有两种形式——</p><p>$$
a<!-- -->*<!-- -->x^i<!-- -->*<!-- -->sin^{j+2}(x)<!-- -->*<!-- -->cos^{k-2}(x)
$$</p><p>$$
a<!-- -->*<!-- -->x^i<!-- -->*<!-- -->sin^{j-2}(x)<!-- -->*<!-- -->cos^{k+2}(x)
$$</p><p>化简后两项合并为——$2<!-- -->*<!-- -->a<!-- -->*<!-- -->x^i<!-- -->*<!-- -->sin^{j-2}(x)<!-- -->*<!-- -->cos^{k-2}(x)$</p><p>因此我们可以遍历容器并检查邻项是否存在，从而化简；而后者，在<code>j=2|k=2</code>时是肯定可以提升性能分的，方法与$sin^2(x)+cos^2(x)=1$的类似。</p><p>当然，个人觉得除非针对后两点构造数据，其出现的机率并不大，是否要为了性能分牺牲性能也是一个问题。</p><p><strong>也求有想法的大佬交流下更好的方法与隐藏的内卷点(～￣▽￣)～</strong></p><p>既然无法贪心，只好搜索。</p><p>dfs，每次找到可合并的两个项去合并，然后回溯，不断记录最短答案，其中，两个项合并的次数(即合并之后的系数)要满足至少要用完其中一个项。</p><p>改完dfs发现要T（爆栈），就把每次dfs前的答案扔进set判重，即记忆化。</p><p>合并的话一开始只考虑了sin(x)2+cos(x)2=1然后用1−sin(x)2=cos(x)2以拆分常数项 和不含sin(x)sin(x)或cos(x)cos(x)的项来体现。后来发现速度很快但效果不好。</p><p>在队友丁总对我的指导下，我把1−sin(x)2=cos(x)2放进了dfs，成为合并两个项的新选择。</p><p>关于极端数据爆栈，卡住dfs次数和程序运行时间即可。最终性能分满分。</p><p>正常随机数据或项数不多的数据可以随便跑完，评论区里面的数据应该都能搜完。</p><p>欢迎大佬们批评指正，本数学弱鸡，码力选手只能想到这种暴力做法，写了快10k的优化类，累死。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统 OS Lab0]]></title>
        <id>操作系统 OS Lab0</id>
        <link href="https://mondaycha.github.io/blog/2020/03/02/操作系统-OS-Lab0"/>
        <updated>2020-03-02T07:59:59.000Z</updated>
        <summary type="html"><![CDATA[练习0.1]]></summary>
        <content type="html"><![CDATA[<h2>练习0.1</h2><p>在 bash 中分别输入</p><pre><code>echo “Hello Ubuntu”

bash –version

ls
</code></pre><p>三条命令，简单思考其回显结果</p><h2>思考0.1</h2><p>通过你的使用经验，简单分析 CLI Shell，GUI Shell 在你使用过程中的各自优劣（100 字以内）</p><h2>练习 0.2</h2><p>执行如下命令,并查看结果</p><pre><code>echo first
echo second &gt; output.txt
echo third &gt; output.txt
echo forth &gt; &gt; output.txt
</code></pre><p>ctags，很好用的小工具</p><p>(若实验环境中tree命令无效，输入sudo apt-get install tree命令安装，后面locate、tmux等同理)</p><h2>练习0.3</h2><p>在/home/17xxxxxx_2019_jac/learnGit（已init）目录下创建一个名为README.txt的文件。这时使用 git status &gt; Untracked.txt 。</p><p>在 README.txt 文件中随便写点什么，然后使用刚刚学到的 add 命令，再使用 git status &gt; Stage.txt 。</p><p>之后使用上面学到的 Git 提交有关的知识把 README.txt 提交，并在提交说明里写入自己的学号。</p><p>使用 cat Untracked.txt 和 cat Stage.txt，对比一下两次的结果，体会一下README.txt 两次所处位置的不同。</p><p>修改 README.txt 文件，再使用 git status &gt; Modified.txt 。</p><p>使用 cat Modified.txt ，观察它和第一次 add 之前的 status 一样吗，思考一 下为什么？</p><h2>思考题 0.2</h2><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）             具体实现的过程中思考下列问题：echo echo Shell Start 与 echo &#x27;echo Shell Start&#x27;效果是否有区别                    echo echo \$c&gt;file1 与 echo &#x27;echo \$c&gt;file1&#x27; 效果是否有区别</p><h2>思考题 0.3</h2><p>仔细看看这张图，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</p><h2>思考题0.4</h2><p>深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。苦恼的小明向你求助，你该怎样帮他把代码文件恢复呢？</p><p>正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘上敲下了git rm printf.c，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？</p><p>处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使Tucao.txt在不从工作区删除的情况下不会被git commit指令提交到版本库？</p><h2>练习0.4</h2><p>找到我们在/home/17xxxxxx_2019_jac/下刚刚创建的README.txt，没有的话就新建一个。</p><p>在文件里加入Testing 1，add，commit，提交说明写 1。</p><p>模仿上述做法，把1分别改为 2 和 3，再提交两次。</p><p>使用 git log命令查看一下提交日志，看是否已经有三次提交了？记下提交说明为 3 的哈希值1。</p><p>开动时光机！使用 git reset --hard HEAD^ ，现在再使用git log，看看什么没了？</p><p>找到提交说明为1的哈希值，使用 <code>git reset --hard &lt;Hash-code&gt;</code> ，再使用git log，看看什么没了？</p><p>现在我们已经回到过去了，为了再次回到未来，使用 <code>git reset --hard &lt;Hash-code&gt;</code> ，再使用git log，我胡汉三又回来了！</p><h2>思考题0.5</h2><p>思考下面四个描述，你觉得哪些正确，哪些错误，请给出你参考的资料或实验证据。</p><p>克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。</p><p>克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。</p><p>克隆时只有远程版本库HEAD指向的分支被克隆。</p><p>克隆后工作区的默认分支处于master分支。</p><h2>练习0.5</h2><p>仔细回顾一下上面这些指令，然后完成下面的任务</p><p>在 /home/17xxxxxx_2019_jac/17xxxxxx-lab下新建分支，名字为Test</p><p>切换到Test分支，添加一份readme.txt，内容写入自己的学号</p><p>将文件提交到本地版本库，然后建立相应的远程分支。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向过程的设计，和面向对象的设计异同点到底在哪？]]></title>
        <id>面向过程的设计，和面向对象的设计异同点到底在哪？</id>
        <link href="https://mondaycha.github.io/blog/2020/03/02/面向过程的设计，和面向对象的设计异同点到底在哪？"/>
        <updated>2020-03-02T07:59:59.000Z</updated>
        <summary type="html"><![CDATA[抛砖引玉]]></summary>
        <content type="html"><![CDATA[<p>抛砖引玉</p><h2>不同点：</h2><ul><li>面向过程的设计以函数为核心，接近问题处理过程；面向对象的设计以类为核心，将不同类的属性区分开来（比如students的学分属性与course的学分属性），符合人类认知规律。</li><li>面向对象的设计有继承、多态的特性，低耦合高内聚，便于添加需求，在处理大型项目时也有着更好的可读性。</li></ul><h2>相同点：</h2><ul><li>在设计过程中，为了简化复杂度，面向过程与面向对象都存在封装性。</li><li>都是用来解决问题的程序思想</li></ul>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[《一堂好课》观后感]]></title>
        <id>《一堂好课》观后感</id>
        <link href="https://mondaycha.github.io/blog/2020/02/24/《一堂好课》观后感"/>
        <updated>2020-02-24T04:57:06.000Z</updated>
        <summary type="html"><![CDATA[《一堂好课》观后感]]></summary>
        <content type="html"><![CDATA[<h3>《一堂好课》观后感</h3><p>今天20:30，我观看了由戚发轫院士主讲，康辉担任班主任的综艺节目《一堂好课》。在课上，戚发轫院士讲述了自己的亲身经历，讲述了今年将要探索火星的规划，讲述了中国作为航天大国面临的机遇与挑战。期间流露出的北航人的航天精神令我深深地被触动了。</p><p>而课间的航天员助教与小朋友宇航员的互动也很有趣，航天员乐观灿烂的回答，也是他们坚守使命勇往直前的真实写照。</p><p>几十亿年前的一次意外孕育出生命的奇迹，相信未来人类也将跨出银河之摇篮，遨游星海！</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[对马克思主义的理解]]></title>
        <id>对马克思主义的理解</id>
        <link href="https://mondaycha.github.io/blog/2020/02/24/对马克思主义的理解"/>
        <updated>2020-02-24T04:57:06.000Z</updated>
        <summary type="html"><![CDATA[在参加本学期马克思主义基本原理概论课程之前，我对于马克思主义的理解主要是这样的：]]></summary>
        <content type="html"><![CDATA[<p>在参加本学期马克思主义基本原理概论课程之前，我对于马克思主义的理解主要是这样的：</p><p>① 马克思主义不是“马克思的主义”。“马克思主义”是由马克思、恩格斯创立，以及广义上由后续社会主义的践行者们一同发展与完善的理论体系。因此，并非所有马克思本人的学说都是马克思主义。</p><p>② 马克思主义包含辩证唯物主义认知与科学社会主义理论。其中唯物主义哲学观是与当时科学发现相结合的成果，意味着人类对于自然的认知进入了一个全新的阶段；科学社会主义理论则成为了工人阶级捍卫自身权益的有力武器，引导着俄国十月革命以及中国共产党的发展。</p><p>③ 马克思主义对于人类的意义非常重大。它有着对于资本主义弊端切中肯綮的剖析，也让社会主义从“空想”变为“现实”。在马克思主义的指导下，资本主义与社会主义都不断完善与发展，人类文明也在其影响下向前迈进。</p><p>④ 马克思主义具有蓬勃的生命力。马克思主义不是一成不变的，是结合具体国情，在辩证中不断发展的。因此，马克思主义的生命力将长期伴随人类文明，在螺旋式的上升中与人类共同进步。</p><p>以上就是我对马克思主义的粗浅理解，希望在上完本课程之后能将有更深入的理解。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[OO预习第三弹]]></title>
        <id>OO预习第三弹</id>
        <link href="https://mondaycha.github.io/blog/2020/02/14/OO预习第三弹"/>
        <updated>2020-02-14T04:57:41.000Z</updated>
        <summary type="html"><![CDATA[OO预习第三弹]]></summary>
        <content type="html"><![CDATA[<h3>OO预习第三弹</h3><p>今天终于做完了Pre1的Task6，借助TreeSet类。</p><p>OO第三弹也出了，与IO/正则表达式等有关，明天继续加油。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[为圣杯战争的开始献上礼炮]]></title>
        <id>为圣杯战争的开始献上礼炮</id>
        <link href="https://mondaycha.github.io/blog/2020/02/10/为圣杯战争的开始献上礼炮"/>
        <updated>2020-02-10T18:27:50.000Z</updated>
        <summary type="html"><![CDATA[BUAA-OO]]></summary>
        <content type="html"><![CDATA[<h3>BUAA-OO</h3><p>从昨天开始，BUAA 2020年春季的面向对象课程就算是拉开帷幕了。</p><h4>2月9日</h4><p>为 Github 和 Gitlab 配置不同的 SSH</p><p>参考资料：</p><blockquote><p><a href="https://segmentfault.com/a/1190000009572470?_ea=1985120">https://segmentfault.com/a/1190000009572470?_ea=1985120</a></p></blockquote><h4>2月10日</h4><p>为 Github 配置单独的 Git 用户名与邮箱</p><p>参考资料：</p><blockquote><p><a href="https://www.cnblogs.com/itbsl/p/10469523.html">https://www.cnblogs.com/itbsl/p/10469523.html</a></p></blockquote>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-Day3]]></title>
        <id>Git-Day3</id>
        <link href="https://mondaycha.github.io/blog/2020/02/09/Git-Day3"/>
        <updated>2020-02-09T20:34:45.000Z</updated>
        <summary type="html"><![CDATA[工作区和暂存区]]></summary>
        <content type="html"><![CDATA[<h3>工作区和暂存区</h3><ul><li>工作区：在电脑下的工作目录</li><li>版本库：工作区下的隐藏目录<code>.git</code></li><li>暂存区：stage(index)</li></ul><p>引评论区 @九只蜗牛Leo 的例子：</p><blockquote><p>感觉大家把简单问题复杂化了，看着头晕，</p><p>Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)</p><p>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</p><p>git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p><p>git diff查看工作区和暂存区差异，</p><p>git diff --cached查看暂存区和仓库差异，</p><p>git diff HEAD 查看工作区和仓库的差异，</p><p>git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，</p><p>git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</p></blockquote><h3>管理修改</h3><p>如果不使用<code>git add</code>添加到暂存区，那么就不会添加到<code>commit</code>中。</p><h3>撤销修改</h3><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD </code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h3>删除文件</h3><p>从版本库中删除文件<code>git rm</code></p><p>并且使用<code>git commit</code>进行提交操作</p><pre><code class="language-c">$ git rm test.txt
rm &#x27;test.txt&#x27;

$ git commit -m &quot;remove test.txt&quot;
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
</code></pre><p><code>git checkout</code>是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h3>远程仓库</h3><p>ssh密钥的配置在研究HEXO的时候做过了，感动！</p><h3>添加远程库</h3><p>origin: Git远程库的名字</p><pre><code>$ git push -u origin master
</code></pre><p>只要本地作了提交，就可以通过命令：</p><pre><code class="language-c">$ git push origin master
</code></pre><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><ul><li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li><li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li></ul><h3>从远程库克隆</h3><ul><li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li><li>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</li></ul><p>我在学习Hexo的时候用的是<code>https</code>协议，而采用<code>git</code>协议的参考样例如下——</p><pre><code>$ git clone git@github.com:michaelliao/gitskills.git
Cloning into &#x27;gitskills&#x27;...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Receiving objects: 100% (3/3), done.
</code></pre>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[『ePub资源』有时间谈恋爱不如去抽卡！02]]></title>
        <id>『ePub资源』有时间谈恋爱不如去抽卡！02</id>
        <link href="https://mondaycha.github.io/blog/2020/02/09/『ePub资源』有时间谈恋爱不如去抽卡！02"/>
        <updated>2020-02-09T17:15:24.000Z</updated>
        <summary type="html"><![CDATA[哇，这次终于准备好了“精排版”的第二册。]]></summary>
        <content type="html"><![CDATA[<p>哇，这次终于准备好了“精排版”的第二册。</p><p><img src="https://pic.downk.cc/item/5e3f5e3f2fb38b8c3c3ed2e9.jpg"/></p><p>下载渠道：</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1oBC-fIF3JKi1swqB23l8ag">https://pan.baidu.com/s/1oBC-fIF3JKi1swqB23l8ag</a>
提取码：2333</p></blockquote><p>嘿嘿，冲鸭！！！</p><p><img src="https://pic.downk.cc/item/5e3f5e1d2fb38b8c3c3ecf23.jpg"/></p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-Day2]]></title>
        <id>Git-Day2</id>
        <link href="https://mondaycha.github.io/blog/2020/02/08/Git-Day2"/>
        <updated>2020-02-08T05:37:26.000Z</updated>
        <summary type="html"><![CDATA[从一次尝试说起]]></summary>
        <content type="html"><![CDATA[<h3>从一次尝试说起</h3><p>今天试着把自己的祭祖代码提交到 Github 上，总结一下操作：</p><ol><li>进入本地项目文件夹，右键“Git Bash Here”</li><li>输入<code>git init</code>，完成初始化</li><li>输入<code>git add .</code>，将当前目录下所有文件添加到仓库</li><li>输入<code>git commit -m &quot;xxxx&quot;</code>，提交修改</li><li>首次提交要git pull 一下，<code>git pull origin master</code></li><li>将代码提交到GitHub上，<code>git push -f origin master</code></li></ol><p>这里，关于第六步，有两种办法：</p><pre><code>git push -u origin master
git push -f origin master
</code></pre><p>后者是强制上传覆盖远程文件。</p><p>最后总算是提交成功了，附上仓库地址——</p><p><a href="https://github.com/MondayCha/BUAA-CO-2019">https://github.com/MondayCha/BUAA-CO-2019</a></p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-Day1]]></title>
        <id>Git-Day1</id>
        <link href="https://mondaycha.github.io/blog/2020/02/07/Git-Day1"/>
        <updated>2020-02-07T04:56:57.000Z</updated>
        <summary type="html"><![CDATA[创建版本库]]></summary>
        <content type="html"><![CDATA[<h3>创建版本库</h3><p>选择一个合适的地方，创建一个空目录：</p><pre><code>$ mkdir learngit
$ cd learngit
$ pwd
</code></pre><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add </code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m </code>，完成。</li></ol><h3>时光机穿梭</h3><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[『ePub资源』有时间谈恋爱不如去抽卡！01]]></title>
        <id>『ePub资源』有时间谈恋爱不如去抽卡！01</id>
        <link href="https://mondaycha.github.io/blog/2020/02/03/『ePub资源』有时间谈恋爱不如去抽卡！01"/>
        <updated>2020-02-03T17:16:26.000Z</updated>
        <summary type="html"><![CDATA[最近有点沉迷氪金手游，所以自己学习了一点Sigil的皮毛，制作了这个充满讽刺意味的轻小说的ePub文件。]]></summary>
        <content type="html"><![CDATA[<p>最近有点沉迷氪金手游，所以自己学习了一点Sigil的皮毛，制作了这个充满讽刺意味的轻小说的ePub文件。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1zQX7l1PDzjMx3rv4U-c34w">https://pan.baidu.com/s/1zQX7l1PDzjMx3rv4U-c34w</a>
提取码：2333 </p></blockquote><p>感想的话……不知道我的舞猫能不能满宝啊QAQ        </p><p>刚刚又歪池子了……</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一篇文章！]]></title>
        <id>第一篇文章！</id>
        <link href="https://mondaycha.github.io/blog/2020/02/02/第一篇文章！"/>
        <updated>2020-02-02T19:44:22.000Z</updated>
        <summary type="html"><![CDATA[前前后后配置了一天终于搭建好了，接下来也加油吧！]]></summary>
        <content type="html"><![CDATA[<h1>第一篇文章！</h1><p>前前后后配置了一天终于搭建好了，接下来也加油吧！</p>]]></content>
        <author>
            <name>L1l</name>
            <uri>https://github.com/MondayCha</uri>
        </author>
    </entry>
</feed>